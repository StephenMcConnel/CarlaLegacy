\input pcparse % common TeX setup  @c -*-texinfo-*-
\input texinfo
@c %**start of header
@setfilename patrlib.info
@settitle PC-PATR Function Library Reference Manual
@c %**end of header

@set TITLE PC-PATR Function Library Reference Manual
@set SUBTITLE functions for unification based parsing
@set VERSION version 1.2
@set DATE January 2000
@set AUTHOR by Stephen McConnel
@set COPYRIGHT Copyright @copyright{} 2000 SIL International

@include front.txi

@c ----------------------------------------------------------------------------
@node    Top,       Introduction,  (dir),    (dir)
@comment node-name, next,          previous, up
@menu
* Introduction::

* Naming Conventions::

* Data Structures::

* Global Variables::

* Functions::
@end menu
@c ----------------------------------------------------------------------------
@node    Introduction, Naming Conventions, Top,      Top
@comment node-name,    next,               previous, up
@chapter Introduction to the PC-PATR function library

PC-PATR is an implementation for personal computers of the PATR-II
computational linguistic formalism.  The PATR-II formalism can be
viewed as a computer language for encoding linguistic information.  It
does not presuppose any particular theory of syntax.  It was originally
developed by Stuart M. Shieber at Stanford University in the early
1980's.  A PATR-II grammar consists of a set of rules and a lexicon.
Each rule consists of a context-free @emph{phrase structure rule} and a
set of @emph{feature constraints}, that is, @emph{unifications} on the
@emph{feature structures} associated with the constituents of the
phrase structure rules.  The lexicon provides the items that can
replace the terminal symbols of the phrase structure rules, that is,
the words of the language together with their relevant features.

This function library contains the processing functions used by PC-PATR
and related programs.  It has been developed with the goal of making it
easier to cast PATR-II style parsing into different frameworks.  The
first use of this library has been to add a morphotactic component to
PC-Kimmo consisting of a PC-PATR word parser.

PC-PATR (and thus this function library) is still under development.
The author would appreciate feedback directed to the following address:

@example
Stephen McConnel                 (972)708-7361 (office)
Language Software Development    (972)708-7561 (fax)
SIL International
7500 W. Camp Wisdom Road
Dallas, TX 75236                 steve@@acadcomp.sil.org
U.S.A.                        or Stephen_McConnel@@Sil.org
@end example

@c ----------------------------------------------------------------------------
@node Naming Conventions, Data Structures, Introduction, Top
@set library-name PC-PATR
@set library-tag PATR
@include naming.txi

@c ----------------------------------------------------------------------------
@node Data Structures, Global Variables, Naming Conventions, Top
@chapter PC-PATR data structures

The PC-PATR functions operate on a number of different data structures.
The most important of these are described in the following sections.
The PC-PATR functions also use a number of other data structures
internally, but it should not be necessary for a programmer to
manipulate them directly.

@menu
* PATRData::
* PATREdgeList::
* PATRFeatureTags::
* PATRLabeledFeature::
* PATRWord::
@end menu

@c PATRFeature  * addPATRLexItem::
@c PATRFeature  * buildPATRWord::
@c PATRFeature  * freePATRFeature::
@c PATRFeature  * storePATRFeature::
@c PATRFeature  * parsePATRFeatureString::
@c
@c PATRLexItem  * parseWithPATRLexicon::
@c PATRLexItem  * parseWithAmpleForPATRLexicon::
@c PATRLexItem  * parseWithKimmoForPATRLexicon::

@c ----------------------------------------------------------------------------
@page
@node PATRData, PATREdgeList, Data Structures, Data Structures
@section PATRData
@subheading Definition
@example
/*
 *  forward declarations of internal PATR data types
 */
typedef struct patr_grammar     PATRGrammar;
typedef struct patr_lexicon     PATRLexicon;

typedef struct @{
	char                bFailure;
	char                bUnification;
	char                eTreeDisplay;
	char                bGloss;
	char                bGlossesExist;
	char                iFeatureDisplay;
	char                bCheckCycles;
	char                bTopDownFilter;
	short               iMaxAmbiguities;
	short               iDebugLevel;
	char                cComment;
	char                bSilent;
	char                bShowWarnings;
	char                bPromoteDefAtoms;
	time_t              iMaxProcTime;
	FILE *              pLogFP;
	char *              pszGrammarFile;
	PATRGrammar *       pGrammar;
	char *              pszRecordMarker;
	char *              pszWordMarker;
	char *              pszGlossMarker;
	char *              pszCategoryMarker;
	char *              pszFeatureMarker;
	PATRLexicon *       pLexicon;
	int                 iCurrentIndex;
	int                 iParseCount;
	@} PATRData;
@end example
@subheading Description
The @code{PATRData} data structure collects the information used for
data processing within the PC-PATR functions.  Its general purpose is
to reduce the number of parameters needed by the various functions.
@table @code
@item bFailure
causes parser failures to be preserved and displayed if @code{TRUE}
(nonzero).

@item bUnification
enables unification while parsing if @code{TRUE} (nonzero).  If
@code{FALSE}, the parser acts only as a context free chart parser,
which usually produces much more ambiguous output.

@item eTreeDisplay
is the tree display mode, one of these symbolic constant values:
@table @code
@item PATR_NO_TREE
prevents any output of parse trees.
@item PATR_FLAT_TREE
displays parse trees as parenthesized, nested lists.  For example,
@example
(S (NP (N  cows))(VP (VerbalP (V  eat))(NP (N  grass))))
@end example
@item PATR_FULL_TREE
displays parse trees with a text representation of the tree structure.
For example,
@example
@group
		S
   _____|_____
  NP        VP
   |      ___|____
   N   VerbalP  NP
 cows     |      |
		  V      N
		 eat   grass
@end group
@end example
@item PATR_INDENTED_TREE
displays parse trees in an indented (outline) fashion.  For example,
@example
@group
S
	NP
		N  cows
	VP
		VerbalP
			V  eat
		NP
			N  grass
@end group
@end example
@end table

@item bGloss
causes glosses (if they exist) to be displayed if @code{TRUE}.

@item bGlossesExist
is set automatically according to whether or not glosses exist when the
lexicon is loaded.

@item iFeatureDisplay
is a bit vector that encodes the feature display mode:
@table @code
@item iFeatureDisplay & PATR_FEATURE_ON
allows the output of feature structures.  If this bit is cleared (zero),
feature structures are not written to the output, but may still be used
in parsing.
@item iFeatureDisplay & PATR_FEATURE_FLAT
causes feature output to be ``flattened'' into a compact form which is
less readable for humans, but just as easily parsed by a computer
program.  If this bit is cleared, a top level feature structure looks
like this in the output:
@example
@group
S:
[ cat:   S
  head:    [ agr:   $1[ 3sg:   - ]
			 finite:+
			 pos:   V
			 vform: BASE ]
  subj:    [ cat:   NP
			 head:    [ agr:   $1
						case:  NOM
						number:PL
						pos:   N
						proper:-
						verbal:- ] ] ]
@end group
@end example
@noindent
On the other hand, if this bit is set, the same feature structure would
be written like this:
@example
@group
S:      [ cat:S head:[ agr:$1[ 3sg:- ] finite:+ pos:V vform:BASE ]
		  subj:[ cat:NP head:[ agr:$1 case:NOM number:PL pos:N
		  proper:- verbal:- ] ] ]
@end group
@end example
@item iFeatureDisplay & PATR_FEATURE_ALL
causes all of the feature structures to be written to the output, not
just the top level feature structure.  If this bit is cleared, the
feature structure output associated with a parse might look like one of
the previous two examples.  If this bit is set, the output might look
like the following instead:
@example
@group
S_1:    [ cat:S head:[ agr:$1[ 3sg:- ] finite:+ pos:V vform:BASE ]
		  subj:[ cat:NP head:[ agr:$1 case:NOM number:PL pos:N
		  proper:- verbal:- ] ] ]
@end group

@group
NP_2:   [ cat:NP head:[ agr:[ 3sg:- ] number:PL pos:N proper:-
		  verbal:- ] ]
@end group

@group
N_3:    [ cat:N gloss:`cow head:[ agr:[ 3sg:- ] number:PL pos:N
		  proper:- verbal:- ] lex:cows root_pos:N ]
@end group

VP_4:   [ cat:VP head:[ finite:+ pos:V vform:BASE ] ]

VerbalP_5:      [ cat:VerbalP head:[ finite:+ pos:V vform:BASE ] ]

@group
V_6:    [ cat:V gloss:`eat head:[ pos:V vform:BASE ] lex:eat
		  root_pos:V ]
@end group

@group
NP_7:   [ cat:NP head:[ agr:[ 3sg:+ ] number:SG pos:N proper:-
		  verbal:- ] ]
@end group

@group
N_8:    [ cat:N gloss:`grass head:[ agr:[ 3sg:+ ] number:SG pos:N
		  proper:- verbal:- ] lex:grass root_pos:N ]
@end group
@end example
@item iFeatureDisplay & PATR_FEATURE_TRIM
prevents empty feature structures from being written to the output.  If
this bit is cleared, then a feature structure might look like this:
@example
@group
VP_3:
[ cat:   VP
  head:    [ form:  finite
			 trans:   [ pred:  sleep
						arg1:  $1[]
						arg2:  [] ] ]
  syncat:  [ first:   [ cat:   NP
						head:    [ agreement:  [ person:third
											  number:singular ]
								   trans: $1 ] ]
			 rest:  end ] ]
@end group
@end example
@noindent
If this bit is set, the same data structure would look like this:
@example
@group
VP_3:
[ cat:   VP
  head:    [ form:  finite
			 trans:   [ pred:  sleep ] ]
  syncat:  [ first:   [ cat:   NP
						head:    [ agreement:  [ person:third
											  number:singular ] ] ]
			 rest:  end ] ]
@end group
@end example
@end table

@item bCheckCycles
determines whether to enable checking for parse cycles while parsing.

@item bTopDownFilter
determines whether to enable top down filtering while parsing.

@item iMaxAmbiguities
is the maximum number of alternative parse trees to show in the output.

@item iDebugLevel
is the degree of debugging output desired (0 means none).

@item cComment
is the character that begins a comment in an input line.
(@code{PATR_DEFAULT_COMMENT} is a symbol for the default value.)

@item bSilent
determines whether to disable messages to the ``standard error'' stream
(@code{stderr}).

@item bShowWarnings
determines whether to enable warnings as well as error messages.

@item bPromoteDefAtoms
determines whether default atomic values in features loaded from the
lexicon are ``promoted'' to ordinary atomic values before parsing.  (This
can affect feature unification since a conflicting default value does not
cause a failure: the default value merely disappears.)

@item iMaxProcTime
determines the maximum number of seconds a parse is allowed to take.  A
value of @code{0} means no limit.

@item pLogFP
is the @code{FILE} pointer for an output log file (@code{NULL} means
none).

@item pszGrammarFile
points to the name of the current PC-PATR grammar file (@code{NULL}
means none).

@item pGrammar
points to the current PC-PATR grammar data (@code{NULL} means none).

@item pszRecordMarker
points to the standard format marker for lexicon records.

@item pszWordMarker
points to the standard format marker for lexicon word fields.

@item pszGlossMarker
points to the standard format marker for lexicon gloss fields.

@item pszCategoryMarker
points to the standard format marker for lexicon category fields.

@item pszFeatureMarker
points to the standard format marker for lexicon feature fields.

@item pLexicon
points to the current PC-PATR lexicon (@code{NULL} means none).

@item iCurrentIndex
is used for internal processing.  It records the index number of the
current edge.

@item iParseCount
is used for internal processing.  It records the number of parses
found.
@end table
@subheading Source File
@file{patr.h}

@menu
* addPATRLexItem::
* buildPATRWord::
* buildPATRWordForKimmo::
* collectPATRParseGarbage::
* convertKimmoPATRToWordAnalyses::
* freePATREdgeList::
* freePATRFeature::
* freePATRGrammar::
* freePATRInternalMemory::
* freePATRLexicon::
* loadPATRGrammar::
* loadPATRLexicon::
* loadPATRLexiconFromAmple::
* markPATRParseGarbage::
* parseAmpleSentenceWithPATR::
* parsePATRFeatureString::
* parseWithAmpleForPATRLexicon::
* parseWithKimmoForPATRLexicon::
* parseWithPATR::
* parseWithPATRLexicon::
* showPATRLexicon::
* storePATREdgeList::
* storePATRFeature::
* stringifyPATRParses::
* writePATRLexicon::
* writePATRParses::
* writePATRStyledOutput::
@end menu

@c ----------------------------------------------------------------------------
@page
@node PATREdgeList, PATRFeatureTags, PATRData, Data Structures
@section PATREdgeList
@subheading Definition
@example
/*
 *  forward declaration of an internal PATR data type
 */
typedef struct patr_edge PATREdge;

typedef struct patr_edge_list @{
	PATREdge *                  pEdge;
	struct patr_edge_list *     pNext;
	@} PATREdgeList;
@end example
@subheading Description
The @code{PATREdgeList} data structure encodes a list of parse results
returned by the PC-PATR parsing functions.
@table @code
@item pEdge
points to a parse tree encoded as an edge in the parse chart.

@item pNext
points to the next parse tree encoded as an edge in the parse chart.
@end table
@subheading Source File
@file{patr.h}

@menu
* freePATREdgeList::
* parseWithPATR::
* storePATREdgeList::
* stringifyPATRParses::
* writePATRParses::
* writePATRStyledOutput::
@end menu

@c ----------------------------------------------------------------------------
@page
@node PATRFeatureTags, PATRLabeledFeature, PATREdgeList, Data Structures
@section PATRFeatureTags
@subheading Definition
@example
#include "strlist.h"

typedef struct patr_feat_tags @{
	StringList *                pFeaturePath;
	char *                      pszStartTag;
	char *                      pszEndTag;
	struct patr_feat_tags *     pNext;
	@} PATRFeatureTags;
@end example
@subheading Description
The @code{PATRFeatureTags} data structure contains information needed
to write feature structures to an output file in a stylized fashion.
@table @code
@item pFeaturePath
points to a feature path encoded as a list of feature label strings.

@item pszStartTag
points to the text string written to the output file before the given
feature value.

@item pszEndTag
points to the text string written to the output file after the given
feature value.

@item pNext
points to another @code{PATRFeatureTags} data structure.  This
facilitates building a list of such items.
@end table
@subheading Source File
@file{patr.h}

@menu
* writePATRStyledOutput::
@end menu

@c ----------------------------------------------------------------------------
@page
@node PATRLabeledFeature, PATRWord, PATRFeatureTags, Data Structures
@section PATRLabeledFeature
@subheading Definition
@example
/*
 *  forward declaration of an internal PATR data type
 */
typedef struct patr_feature PATRFeature;

typedef struct patr_labeled_feat @{
	char *                      pszLabel;
	PATRFeature *               pFeature;
	struct patr_labeled_feat *  pNext;
	@} PATRLabeledFeature;
@end example
@subheading Description
The @code{PATRLabeledFeature} data structure contains information
needed to abbreviate a feature structure to a simple label (template
name) while writing an output file.
@table @code
@item pszLabel
points to the label (template name) associated with the @code{pFeature}
value

@item pFeature
points to a feature structure

@item pNext
points to another @code{PATRLabeledFeature} data structure.  This
facilitates building a list of such items.
@end table
@subheading Source File
@file{patr.h}

@menu
* convertKimmoPATRToWordAnalyses::
@end menu

@c ----------------------------------------------------------------------------
@page
@node PATRWord, , PATRLabeledFeature, Data Structures
@section PATRWord
@subheading Definition
@example
/*
 *  forward declaration of an internal PATR data type
 */
typedef struct patr_categ PATRWordCategory;

typedef struct patr_word @{
	int                 iWordNumber;
	char *              pszWordName;
	PATRWordCategory *  pCategories;
	struct patr_word *  pNext;
	@} PATRWord;
@end example
@subheading Description
The @code{PATRWord} data structure represents a single word of the
sentence fed to the PC-PATR parsing function.  A sentence is
represented by a linked list of these data structures.
@table @code
@item iWordNumber
is the number of the word in the sentence.

@item pszWordName
is the orthographic wordform.

@item pCategories
points to a list of word categories for this word.  (This allows words
to be syntactically ambiguous.)  Each word category contains the
feature structure associated with one sense of the word.

@item pNext
points to the next word in the sentence.  @code{NULL} marks the end of
the sentence.
@end table
@subheading Source File
@file{patr.h}

@menu
* buildPATRWord::
* buildPATRWordForKimmo::
* parseWithPATR::
@end menu

@c ----------------------------------------------------------------------------
@node Global Variables, Functions, Data Structures, Top
@chapter The PC-PATR function library global variables

This chapter gives the proper usage information about each of the
global variables found in the PC-PATR function library.  The
@file{patr.h} header file contains the extern declarations for all of
these variables.

@menu
* bCancelPATROperation_g::
* cPATRPatchSep_g::
* iPATRPatchlevel_g::
* iPATRRevision_g::
* iPATRVersion_g::
* pszPATRCompileDate_g::
* pszPATRCompileFormat_g::
* pszPATRCompileTime_g::
* pszPATRDate_g::
* pszPATRTestVersion_g::
* pszPATRYear_g::
@end menu

@c ----------------------------------------------------------------------------
@page
@node bCancelPATROperation_g, cPATRPatchSep_g, Global Variables, Global Variables
@section bCancelPATROperation_g
@subheading Syntax
@example
#include "patr.h"

extern int      bCancelPATROperation_g;
@end example
@subheading Description
@code{bCancelPATROperation_g} can be set asynchronously to interrupt a
PC-PATR parse that seems to be stuck.
@subheading Example
@smallexample
#include <signal.h>
#include "patr.h"
...
void sigint_handler(int iSignal_in)
@{
bCancelPATROperation_g = TRUE;
signal(SIGINT, sigint_handler);
@}
...
signal(SIGINT, sigint_handler);
...
@end smallexample
@subheading Source File
@file{patrdata.c}

@c ----------------------------------------------------------------------------
@page
@node cPATRPatchSep_g, iPATRPatchlevel_g, bCancelPATROperation_g, Global Variables
@section cPATRPatchSep_g
@subheading Syntax
@example
#include "patr.h"

extern const char       cPATRPatchSep_g;
@end example
@subheading Description
@code{cPATRPatchSep_g} is used to separate the revision and patch
level values when printing the PC-PATR version number.  @code{'a'}
indicates an alpha release, @code{'b'} indicates a beta release, and
@code{'.'} indicates a production release.
@subheading Example
@ifset txt
See the example for @code{iPATRVersion_g} below.
@end ifset
@ifclear txt
@xref{iPATRVersion_g, , Example}.
@end ifclear
@subheading Source File
@file{patrdata.c}

@c ----------------------------------------------------------------------------
@page
@node iPATRPatchlevel_g, iPATRRevision_g, cPATRPatchSep_g, Global Variables
@section iPATRPatchlevel_g
@subheading Syntax
@example
#include "patr.h"

extern const int        iPATRPatchlevel_g;
@end example
@subheading Description
@code{iPATRPatchlevel_g} is the current @dfn{patch level} of the
PC-PATR function library and program.  This is the third level version
number, reflecting bug fixes or internal improvements that should be
functionally invisible to users.
@subheading Example
@ifset txt
See the example for @code{iPATRVersion_g} below.
@end ifset
@ifclear txt
@xref{iPATRVersion_g, , Example}.
@end ifclear
@subheading Source File
@file{patrdata.c}

@c ----------------------------------------------------------------------------
@page
@node iPATRRevision_g, iPATRVersion_g, iPATRPatchlevel_g, Global Variables
@section iPATRRevision_g
@subheading Syntax
@example
#include "patr.h"

extern const int        iPATRRevision_g;
@end example
@subheading Description
@code{iPATRRevision_g} is the current @dfn{revision level} of the
PC-PATR function library and program.  This is the second level version
number, reflecting changes to program behavior that require changes to
the @cite{PC-PATR Reference Manual}.
@subheading Example
@ifset txt
See the example for @code{iPATRVersion_g} below.
@end ifset
@ifclear txt
@xref{iPATRVersion_g, , Example}.
@end ifclear
@subheading Source File
@file{patrdata.c}

@c ----------------------------------------------------------------------------
@page
@node iPATRVersion_g, pszPATRCompileDate_g, iPATRRevision_g, Global Variables
@section iPATRVersion_g
@subheading Syntax
@example
#include "patr.h"

extern const int        iPATRVersion_g;
@end example
@subheading Description
@code{iPATRVersion_g} is the current @dfn{version} number of the
PC-PATR function library and program.  This is the top level version
number, reflecting a major rewrite of the program or major changes that
make it incompatible with earlier versions of the program.
@subheading Example
@smallexample
#include <stdio.h>
#include "patr.h"
...
fprintf(stderr,
		"PC-PATR version %d.%d%c%d (%s), Copyright %s SIL\n",
		iPATRVersion_g, iPATRRevision_g, cPATRPatchSep_g,
		iPATRPatchlevel_g, pszPATRDate_g, pszPATRYear_g);
#ifdef __DATE__
fprintf(stderr, pszPATRCompileFormat_g,
		pszPATRCompileDate_g, pszPATRCompileTime_g);
#else
if (pszPATRTestVersion_g != NULL)
	fputs(pszPATRTestVersion_g, stderr);
#endif
...
@end smallexample
@subheading Source File
@file{patrdata.c}

@c ----------------------------------------------------------------------------
@page
@node pszPATRCompileDate_g, pszPATRCompileFormat_g, iPATRVersion_g, Global Variables
@section pszPATRCompileDate_g
@subheading Syntax
@example
#include "patr.h"

#ifdef __DATE__
extern const char *     pszPATRCompileDate_g;
#endif
@end example
@subheading Description
@code{pszPATRCompileDate_g} points to a string containing the date on
which the PC-PATR library was compiled.  It exists only if the C
compiler preprocessor supports the @code{__DATE__} constant.
@subheading Example
@ifset txt
See the example for @code{iPATRVersion_g} above.
@end ifset
@ifclear txt
@xref{iPATRVersion_g, , Example}.
@end ifclear
@subheading Source File
@file{patrdata.c}

@c ----------------------------------------------------------------------------
@page
@node pszPATRCompileFormat_g, pszPATRCompileTime_g, pszPATRCompileDate_g, Global Variables
@section pszPATRCompileFormat_g
@subheading Syntax
@example
#include "patr.h"

#ifdef __DATE__
#ifdef __TIME__
extern const char *     pszPATRCompileFormat_g;
#endif
#endif
@end example
@subheading Description
@code{pszPATRCompileFormat_g} points to a @code{printf} style format
string suitable for displaying @code{pszPATRCompileDate_g} and
@code{pszPATRCompileTime_g}.  It exists only if the C compiler
preprocessor supports the @code{__DATE__} and @code{__TIME__} constants.
@subheading Example
@ifset txt
See the example for @code{iPATRVersion_g} above.
@end ifset
@ifclear txt
@xref{iPATRVersion_g, , Example}.
@end ifclear
@subheading Source File
@file{patrdata.c}

@c ----------------------------------------------------------------------------
@page
@node pszPATRCompileTime_g, pszPATRDate_g, pszPATRCompileFormat_g, Global Variables
@section pszPATRCompileTime_g
@subheading Syntax
@example
#include "patr.h"

#ifdef __TIME__
extern const char *     pszPATRCompileTime_g;
#endif
@end example
@subheading Description
@code{pszPATRCompileTime_g} points to a string containing the time at
which the PC-PATR library was compiled.  It exists only if the C
compiler preprocessor supports the @code{__TIME__} constant.
@subheading Example
@ifset txt
See the example for @code{iPATRVersion_g} above.
@end ifset
@ifclear txt
@xref{iPATRVersion_g, , Example}.
@end ifclear
@subheading Source File
@file{patrdata.c}

@c ----------------------------------------------------------------------------
@page
@node pszPATRDate_g, pszPATRTestVersion_g, pszPATRCompileTime_g, Global Variables
@section pszPATRDate_g
@subheading Syntax
@example
#include "patr.h"

extern const char *     pszPATRDate_g;
@end example
@subheading Description
@code{pszPATRDate_g} points to a string containing the date on
which the PC-PATR library was last modified.
@subheading Example
@ifset txt
See the example for @code{iPATRVersion_g} above.
@end ifset
@ifclear txt
@xref{iPATRVersion_g, , Example}.
@end ifclear
@subheading Source File
@file{patrdata.c}

@c ----------------------------------------------------------------------------
@page
@node pszPATRTestVersion_g, pszPATRYear_g, pszPATRDate_g, Global Variables
@section pszPATRTestVersion_g
@subheading Syntax
@example
#include "patr.h"

#ifndef __DATE__
extern const char *     pszPATRTestVersion_g;
#endif
@end example
@subheading Description
@code{pszPATRTestVersion_g} points to a string describing the test
status of PC-PATR (either alpha or beta).  If this is a production
release version, it is set to @code{NULL}.  It is defined only if the C
compiler preprocessor does not support the @code{__DATE__} constant.
@subheading Example
@ifset txt
See the example for @code{iPATRVersion_g} above.
@end ifset
@ifclear txt
@xref{iPATRVersion_g, , Example}.
@end ifclear
@subheading Source File
@file{patrdata.c}

@c ----------------------------------------------------------------------------
@page
@node pszPATRYear_g, , pszPATRTestVersion_g, Global Variables
@section pszPATRYear_g
@subheading Syntax
@example
#include "patr.h"

extern const char *     pszPATRYear_g;
@end example
@subheading Description
@code{pszPATRYear_g} points to a string containing the year in
which the PC-PATR library was last modified.  This is suitable for a
copyright notice assigning the copyright to SIL International.
@subheading Example
@ifset txt
See the example for @code{iPATRVersion_g} above.
@end ifset
@ifclear txt
@xref{iPATRVersion_g, , Example}.
@end ifclear
@subheading Source File
@file{patrdata.c}

@c ----------------------------------------------------------------------------
@node Functions, , Global Variables, Top
@chapter PC-PATR functions

This document gives the proper usage information about each of the
functions found in the PC-PATR function library.  The prototypes and type
definitions relevent to the use of these functions are all found in the
@file{patr.h} header file.

@menu
* addPATRLexItem::
* collectPATRParseGarbage::
* buildPATRWord::
* buildPATRWordForKimmo::
* convertKimmoPATRToWordAnalyses::
* freePATREdgeList::
* freePATRFeature::
* freePATRGrammar::
* freePATRInternalMemory::
* freePATRLexicon::
* loadPATRGrammar::
* loadPATRLexicon::
* loadPATRLexiconFromAmple::
* markPATRParseGarbage::
* parseAmpleSentenceWithPATR::
* parsePATRFeatureString::
* parseWithAmpleForPATRLexicon::
* parseWithKimmoForPATRLexicon::
* parseWithPATR::
* parseWithPATRLexicon::
* showPATRLexicon::
* storePATREdgeList::
* storePATRFeature::
* stringifyPATRParses::
* writePATRLexicon::
* writePATRParses::
* writePATRStyledOutput::
@end menu

@c ----------------------------------------------------------------------------
@page
@node addPATRLexItem, buildPATRWord, Functions, Functions
@section addPATRLexItem
@subheading Syntax
@example
#include "patr.h"

void addPATRLexItem(char *        pszWord_in,
					char *        pszGloss_in,
					char *        pszCategory_in,
					char *        pszFeatures_in,
					PATRFeature * pFeature_in,
					PATRData *    pPATR_io);
@end example
@subheading Description
@code{addPATRLexItem} adds one entry to the PC-PATR lexicon stored in
memory.

The arguments to @code{addPATRLexItem} are as follows:
@table @code
@item pszWord_in
points to the orthographic string of the lexical item.

@item pszGloss_in
points to a gloss string for the lexical item.

@item pszCategory_in
points to the syntactic category for the lexical item.

@item pszFeatures_in
points to a space delimited list of feature (template) names associated
with the lexical item.

@item pFeature_in
points to a feature structure associated with the lexical item.  This
is an alternative to @code{pszFeatures_in}.

@item pPATR_io
points to the data structure that contains the PC-PATR language data
such as the lexicon.
@end table
@subheading Return Value
none
@subheading Example
@smallexample
#include <string.h>
#include "patr.h"
#include "opaclib.h"

void storeTemplate(WordTemplate * pTemplate_in, PATRData * pPATR_in)
@{
WordAnalysis *  pAnal;
char *          pszFeatures;
char *          p;

for ( pAnal = pTemplate_in->pAnalyses ; pAnal ; pAnal = pAnal->pNext )
	@{
	pszFeatures = NULL;
	if (pAnal->pszFeatures != NULL)
		@{
		pszFeatures = duplicateString(pAnal->pszFeatures);
		while ((p = strchr(pszFeatures, '=')) != NULL)
			*p = ' ';
		@}
	addPATRLexItem(pTemplate_in->pszSurfaceForm,
				   pAnal->pszAnalysis,
				   pAnal->pszCategory,
				   pszFeatures,
				   NULL, pPATR_in);
	if (pszFeatures != NULL)
		@{
		freeMemory(pszFeatures);
		pszFeatures = NULL;
		@}
	@}
@}
@end smallexample
@subheading Source File
@file{patrlexi.c}

@c ----------------------------------------------------------------------------
@page
@node buildPATRWord, buildPATRWordForKimmo, addPATRLexItem, Functions
@section buildPATRWord
@subheading Syntax
@example
#include "patr.h"

PATRWord * buildPATRWord(char *        pszLex_in,
						 char *        pszGloss_in,
						 char *        pszCat_in,
						 char *        pszFeatures_in,
						 PATRFeature * pPATRFeature_in,
						 PATRData *    pPATR_in);
@end example
@subheading Description
@code{buildPATRWord} converts the given information into the form needed
for a PATR parse.  This is used by the (X)AMPLE program in preparing a
proposed word analysis for parsing with a word grammar.

The arguments to @code{buildPATRWord} are as follows:
@table @code
@item pszLex_in
contains the lexical form of the morpheme.  It must not be @code{NULL}.

@item pszGloss_in
contains a short gloss of the morpheme.  It may be @code{NULL}.

@item pszCat_in
contains the category of the morpheme.  It must not be @code{NULL}.

@item pszFeatures_in
contains zero or more feature template names separated by spaces or equal
signs (@code{=}).  It may be @code{NULL}.

@item pPATRFeature_in
is reserved for future use.  It may be @code{NULL}.

@item pPATR_in
points to the data structure that contains the PC-PATR language data
such as the grammar (which includes template definitions).  It must not
be @code{NULL}.
@end table
@subheading Return Value
a pointer to a dynamically allocation PATRWord data structure containing
the morpheme information
@subheading Example
@smallexample
#include "ample.h"              /* #includes "patr.h" */
#include "ampledef.h"
...
PATREdgeList * perform_word_parse(pAnal_in, pAmple_in)
AmpleHeadList * pAnal_in;
AmpleData *     pAmple_in;
@{
AmpleHeadList *  hp;
AmpleAllomorph * ap;
AmpleMorpheme *  mp;
PATRWord *       pWord = NULL;
PATRWord *       pNewMorph  = NULL;
char *           pszLex;
char *           pszGloss;
char *           pszPATRCategory;
char *           pszFromCat;
char *           pszToCat;
char *           pszProps;
char *           pszFeatures;
/*
 * Convert the list of morphemes to what parseWithPATR() wants.
 */
for ( hp = pAnal_in ; hp ; hp = hp->pLeft )
	@{
	ap = hp->pAllomorph;
	if (ap == NULL)
		continue;               /* should never happen */
	mp = ap->pMorpheme;
	if (mp == NULL)
		continue;               /* should never happen */
	if (mp->pszUnderForm != NULL)
		pszLex = mp->pszUnderForm;
	else
		pszLex = ap->pszAllomorph;
	if ((pszLex == NULL) || (*pszLex == NUL))
		pszLex = "0";
	pszGloss = mp->pszMorphName;
	if (mp->pszPATRCat != NULL)
		@{
		pszPATRCategory = mp->pszPATRCat;
		@}
	else
		@{
		switch (hp->eType)
			@{
			case AMPLE_PFX:
				pszPATRCategory = "Prefix";
				break;
			case AMPLE_IFX:
				if (    (hp->pRight == NULL) ||
						(hp->pRight->eType == AMPLE_SFX) )
					pszPATRCategory = "Suffix";
				else
					pszPATRCategory = "Prefix";
				break;
			case AMPLE_SFX:
				pszPATRCategory = "Suffix";
				break;
			default:
				pszPATRCategory = "Root";
				break;
			@}
		@}
	if (hp->eType == AMPLE_ROOT)
		pszFromCat = NULL;
	else
		pszFromCat = findAmpleCategoryName(get_from(hp),
									   pAmple_in->pCategories);
	pszToCat    = findAmpleCategoryName(get_to(hp),
									   pAmple_in->pCategories);
	pszProps    = build_prop_string(ap->sPropertySet,
									&pAmple_in->sProperties);
	pszFeatures = build_feature_string(mp->pszMorphFd,
									 pszFromCat, pszToCat,
									 pszProps ? pszProps : "");
	if (pszProps != NULL)
		freeMemory(pszProps);
	pNewMorph = buildPATRWord(pszLex, pszGloss,
							  pszPATRCategory, pszFeatures,
							  mp->pPATRFeature,
							  &pAmple_in->sPATR);
	freeMemory(pszFeatures);
	pNewMorph->pNext = pWord;
	pWord            = pNewMorph;
	@}
...
@}
@end smallexample
@subheading Source File
@file{patalloc.c}

@c ----------------------------------------------------------------------------
@page
@node buildPATRWordForKimmo, collectPATRParseGarbage, buildPATRWord, Functions
@section buildPATRWordForKimmo
@subheading Syntax
@example
#include "patr.h"

PATRWord * buildPATRWordForKimmo(char *           pszLex_in,
								 char *           pszGloss_in,
								 char *           pszCat_in,
								 unsigned short * puiFeatIndexes_in,
								 char **          ppszFeatures_in,
								 PATRData *       pPATR_in);
@end example
@subheading Description
@code{buildPATRWordForKimmo} converts the supplied
information into the form needed to apply a PC-PATR analysis.

The arguments to @code{buildPATRWordForKimmo} are as follows:
@table @code
@item pszLex_in
points to the lexical form.

@item pszGloss_in
points to a gloss string.

@item pszCat_in
points to the grammatical category.

@item puiFeatIndexes_in
points to an array of feature (template) name indexes for features
associated with this item.

@item ppszFeatures_in
points to the array of feature (template) names indexed by the members
of @code{puiFeatIndexes_in}.

@item pPATR_in
points to the data structure that contains the PC-PATR language data
such as the grammar.
@end table
@subheading Return Value
a pointer to a dynamically allocated @code{PATRWord} data structure
encoding the supplied information
@subheading Example
@ifset txt
See the example for @code{parseWithPATR} below.
@end ifset
@ifclear txt
@xref{parseWithPATR, , Example}.
@end ifclear
@subheading Source File
@file{patrkimm.c}

@c ----------------------------------------------------------------------------
@page
@node collectPATRParseGarbage, convertKimmoPATRToWordAnalyses, buildPATRWordForKimmo, Functions
@section collectPATRParseGarbage
@subheading Syntax
@example
#include "patr.h"

void collectPATRParseGarbage(PATRData * pPATR_io);
@end example
@subheading Description
@code{collectPATRParseGarbage} cleans up the memory used by
@code{parseWithPATR}.  If the parse results are wanted for an extended
period of time, then @code{storePATREdgeList} must be called after
@code{parseWithPATR} and before @code{collectPATRParseGarbage}

@code{collectPATRParseGarbage} has only one argument:
@table @code
@item pPATR_io
points to the data structure that contains the PC-PATR language data and
internal memory storage.
@end table
@subheading Return Value
none
@subheading Example
@ifset txt
See the example for @code{parseWithPATR} below.
@end ifset
@ifclear txt
@xref{parseWithPATR, , Example}.
@end ifclear
@subheading Source File
@file{patalloc.c}

@c ----------------------------------------------------------------------------
@page
@node convertKimmoPATRToWordAnalyses, freePATREdgeList, collectPATRParseGarbage, Functions
@section convertKimmoPATRToWordAnalyses
@subheading Syntax
@example
#include "patr.h"
#include "kimmo.h"

WordAnalysis * convertKimmoPATRToWordAnalyses(
					KimmoResult *        pKimmoResult_in,
					KimmoData *          pKimmo_in,
					StringList *         pCategoryPath_in,
					int                  cDecomp_in,
					PATRLabeledFeature * pFdDefinitions_in,
					WordAnalysis *       pAnalyses_io,
					unsigned *           puiAmbigCount_io,
					PATRData *           pPATR_io);
@end example
@subheading Description
@code{convertKimmoPATRToWordAnalyses}
converts the result of a PC-Kimmo analysis into a form suitable for
output via the @code{writeTemplate} function.  This is part of the PATR
function library rather than the Kimmo library because it requires
fiddling with feature structures internal to the PATR library.

The arguments to @code{convertKimmoPATRToWordAnalyses} are as follows:
@table @code
@item pKimmoResult_in
points to a list of analyses returned by @code{applyKimmoRecognizer}.

@item pKimmo_in
points to the Kimmo data used by @code{applyKimmoRecognizer}.

@item pCategoryPath_in
points to the feature path used to find the word category in the top
level feature structure associated with each Kimmo analysis.

@item cDecomp_in
is the character used to separate the morphemes in a word decomposition
string.

@item pFdDefinitions_in
points to the set of mappings from a feature structure to a set of
feature names.

@item pAnalyses_io
points to the set of analyses that have already been converted.

@item puiAmbigCount_io
points to a counter that stores the number of distinct analyses in the
output.
@end table
@subheading Return Value
a pointer to a list of word analysis data structures
@subheading Example
@smallexample
#include <stdio.h>
#include "patr.h"
#include "kimmo.h"
...
PATRLabeledFeature *    pFdDefinitions_g   = NULL;
...
static void analyzeFile(FILE * pInputFP_in,
						FILE * pOutputFP_in,
						char * pszOutputFile_in,
						TextControl * pTextControl_in,
						KimmoData *   pKimmo_in)
@{
WordTemplate *          pWord;
WordAnalysis *          pAnal;
KimmoResult *           pResult;
unsigned                uiAmbiguityCount;
unsigned char *         pszWord;
size_t                  i;

while ((pWord = readTemplateFromText(pInputFP_in,
									 pTextControl_in)) != NULL)
	@{
	pWord->iOutputFlags = WANT_DECOMPOSITION | WANT_ORIGINAL;
	if (pWord->paWord != NULL)
		@{
		uiAmbiguityCount = 0;
		for ( i = 0 ; pWord->paWord[i] ; ++i )
			@{
			pszWord = (unsigned char *)pWord->paWord[i];
			pResult = applyKimmoRecognizer(pszWord, pKimmo_in);
			if (pResult != NULL)
				@{
				pWord->pAnalyses = convertKimmoPATRToWordAnalyses(
										 pResult,
										 pKimmo_in,
										 pCatPath_g,
										 pTextControl_in->cDecomp,
										 pFdDefinitions_g,
										 pWord->pAnalyses,
										 &uiAmbiguityCount);
				freeKimmoResult( pResult );
				/*
				 *  adjust output for available fields
				 */
				pWord->iOutputFlags &= ~WANT_FEATURES;
				pWord->iOutputFlags &= ~WANT_CATEGORY;
				for (   pAnal = pWord->pAnalyses ;
						pAnal ;
						pAnal = pAnal->pNext )
					@{
					if (    (pAnal->pszFeatures != NULL) &&
							(*pAnal->pszFeatures != NUL) )
						pWord->iOutputFlags |= WANT_FEATURES;
					if (    (pAnal->pszCategory != NULL) &&
							(*pAnal->pszCategory != NUL) )
						pWord->iOutputFlags |= WANT_CATEGORY;
					@}
				@}
			@}
		@}
	writeTemplate(pOutputFP_in, pszOutputFile_in, pWord,
				  pTextControl_in );
	freeWordTemplate( pWord );
	@}
@}
@end smallexample
@subheading Source File
@file{cvtkp2wa.c}

@c ----------------------------------------------------------------------------
@page
@node freePATREdgeList, freePATRFeature, convertKimmoPATRToWordAnalyses, Functions
@section freePATREdgeList
@subheading Syntax
@example
#include "patr.h"

void freePATREdgeList(PATREdgeList * pPATRResult_io,
					  PATRData *     pPATR_io);
@end example
@subheading Description
@code{freePATREdgeList} frees the memory allocated for a parse chart.

The arguments to @code{freePATREdgeList} are as follows:
@table @code
@item pPATRResult_io
points to a parse chart previously stored by @code{storePATREdgeList}.

@item pPATR_io
points to the data structure that contains the PC-PATR language data and
internal memory storage.
@end table
@subheading Return Value
none
@subheading Example
@ifset txt
See the example for @code{parseWithPATR} below.
@end ifset
@ifclear txt
@xref{parseWithPATR, , Example}.
@end ifclear
@subheading Source File
@file{patalloc.c}

@c ----------------------------------------------------------------------------
@page
@node freePATRFeature, freePATRGrammar, freePATREdgeList, Functions
@section freePATRFeature
@subheading Syntax
@example
#include "patr.h"

void freePATRFeature(PATRFeature * pFeature_io,
					 PATRData * pPATR_io);
@end example
@subheading Description
@code{freePATRFeature} frees the memory allocated for a PC-PATR feature
structure.

The arguments to @code{freePATRFeature} are as follows:
@table @code
@item pFeature_io
points to a feature structure that is no longer needed.

@item pPATR_io
points to the data structure that contains the PC-PATR language data and
internal memory storage.
@end table
@subheading Return Value
none
@subheading Example
@smallexample
#include "patr.h"
...
static void free_word_categs(pwc, pThis)
PATRWordCategory * pwc;
PATRData * pThis;
@{
if (pwc)
	@{
	freeMemory(pwc->pszCategory);
	freePATRFeature(pwc->pFeature, pThis);
	free_word_categs(pwc->pNext, pThis);
	freeMemory(pwc);
	@}
@}
@end smallexample
@subheading Source File
@file{patalloc.c}

@c ----------------------------------------------------------------------------
@page
@node freePATRGrammar, freePATRInternalMemory, freePATRFeature, Functions
@section freePATRGrammar
@subheading Syntax
@example
#include "patr.h"

void freePATRGrammar(PATRData * pPATR_io);
@end example
@subheading Description
@code{freePATRGrammar} frees the memory allocated for a PC-PATR grammar.

@code{freePATRGrammar} has only one argument:
@table @code
@item pPATR_io
points to the data structure that contains the PC-PATR language data
such as the grammar rules.
@end table
@subheading Return Value
none
@subheading Example
@ifset txt
See the example for @code{parseWithPATRLexicon} below.
@end ifset
@ifclear txt
@xref{parseWithPATRLexicon, , Example}.
@end ifclear
@subheading Source File
@file{grammar.c}

@c ----------------------------------------------------------------------------
@page
@node freePATRInternalMemory, freePATRLexicon, freePATRGrammar, Functions
@section freePATRInternalMemory
@subheading Syntax
@example
#include "patr.h"

void freePATRInternalMemory(PATRData * pPATR_io);
@end example
@subheading Description
@code{freePATRInternalMemory} frees some memory used internally by
various PC-PATR library functions.  It should be called only if the
grammar and lexicon have already been freed.

@code{freePATRInternalMemory} has only one argument:
@table @code
@item pPATR_io
points to the data structure that contains the PC-PATR language data and
internal memory storage.
@end table
@subheading Return Value
none
@subheading Example
@ifset txt
See the example for @code{parseWithPATRLexicon} below.
@end ifset
@ifclear txt
@xref{parseWithPATRLexicon, , Example}.
@end ifclear
@subheading Source File
@file{patrfunc.c}

@c ----------------------------------------------------------------------------
@page
@node freePATRLexicon, loadPATRGrammar, freePATRInternalMemory, Functions
@section freePATRLexicon
@subheading Syntax
@example
#include "patr.h"

void freePATRLexicon(PATRData * pPATR_io);
@end example
@subheading Description
@code{freePATRLexicon} frees the memory allocated for storing the PC-PATR
lexicon.

@code{freePATRLexicon} has only one argument:
@table @code
@item pPATR_io
points to the data structure that contains the PC-PATR language data
such as the lexicon.
@end table
@subheading Return Value
none
@subheading Example
@ifset txt
See the example for @code{parseWithPATRLexicon} below.
@end ifset
@ifclear txt
@xref{parseWithPATRLexicon, , Example}.
@end ifclear
@subheading Source File
@file{patrlexi.c}

@c ----------------------------------------------------------------------------
@page
@node loadPATRGrammar, loadPATRLexicon, freePATRLexicon, Functions
@section loadPATRGrammar
@subheading Syntax
@example
#include "patr.h"

int loadPATRGrammar(const char * pszGrammarFile_in,
					PATRData *   pPATR_io);
@end example
@subheading Description
@code{loadPATRGrammar} loads the PC-PATR grammar from a file into
memory.  The entire grammar must fit into a single file.

The arguments to @code{loadPATRGrammar} are as follows:
@table @code
@item pszGrammarFile_in
points to the name of the PC-PATR grammar file.

@item pPATR_io
points to the data structure that contains the PC-PATR language data
such as the grammar.
@end table
@subheading Return Value
zero if an error occurs while loading the grammar, otherwise a non-zero value
@subheading Example
@ifset txt
See the example for @code{parseWithPATRLexicon} below.
@end ifset
@ifclear txt
@xref{parseWithPATRLexicon, , Example}.
@end ifclear
@subheading Source File
@file{grammar.c}

@c ----------------------------------------------------------------------------
@page
@node loadPATRLexicon, loadPATRLexiconFromAmple, loadPATRGrammar, Functions
@section loadPATRLexicon
@subheading Syntax
@example
#include "patr.h"

int loadPATRLexicon(const char * pszLexiconFile_in,
					PATRData *   pPATR_io);
@end example
@subheading Description
@code{loadPATRLexicon} loads a PC-PATR lexicon file into memory.  The
lexicon may be spread out across several files, with a separate call to
@code{loadPATRLexicon} for each file.

The arguments to @code{loadPATRLexicon} are as follows:
@table @code
@item pszLexiconFile_in
points to the name of a PC-PATR lexicon file.

@item pPATR_io
points to the data structure that contains the PC-PATR language data
such as the lexicon.
@end table
@subheading Return Value
zero if an error occurs while loading the lexicon, otherwise a non-zero value
@subheading Example
@ifset txt
See the example for @code{parseWithPATRLexicon} below.
@end ifset
@ifclear txt
@xref{parseWithPATRLexicon, , Example}.
@end ifclear
@subheading Source File
@file{patrlexi.c}

@c ----------------------------------------------------------------------------
@page
@node loadPATRLexiconFromAmple, markPATRParseGarbage, loadPATRLexicon, Functions
@section loadPATRLexiconFromAmple
@subheading Syntax
@example
#include "patr.h"
#include "opaclib.h"

int loadPATRLexiconFromAmple(const char *  pszAnalysisFile_in,
							 TextControl * pTextControl_in,
							 PATRData *    pPATR_io);
@end example
@subheading Description
@code{loadPATRLexiconFromAmple} loads an AMPLE style analysis file into
the PC-PATR lexicon in memory.  Several such files may be loaded to
fill in the lexicon.

The arguments to @code{loadPATRLexiconFromAmple} are as follows:
@table @code
@item pszAnalysisFile_in
points to the name of an AMPLE style analysis file.

@item pTextControl_in
points to a data structure that contains the ambiguity and decomposition
marker characters.

@item pPATR_io
points to the data structure that contains the PC-PATR language data
such as the lexicon.
@end table
@subheading Return Value
zero if an error occurs, or a non-zero value if lexicon entries are
successfully loaded from the analysis file
@subheading Example
@smallexample
#include "patr.h"
#include "opaclib.h"

PATRData        sPATRData_g;
TextControl     sTextControl_g;
...
void processUsingAmple(char * pszGrammar_in, char * pszAnalysis_in,
					   char * pszInput_in, char * pszOutput_in)
@{
FILE *  pInputFP;
FILE *  pOutputFP;
char *  pszLine;
int     iSentenceCount;
int     iParseCount;

if (loadPATRGrammar(pszGrammar_in, &sPATRData_g) == 0)
	return;
if (loadPATRLexiconFromAmple(pszAnalysis_in,
							 &sTextControl_g, &sPATRData_g) != 0)
	@{
	pInputFP = fopen(pszInput_in, "r");
	if (pInputFP != NULL)
		@{
		pOutputFP = fopen(pszOutput_in, "w");
		if (pOutputFP != NULL)
			@{
			iSentenceCount = 0;
			while ((pszLine = readLineFromFile(pInputFP,
											   NULL, '\0')) != NULL)
				@{
				++iSentenceCount;
				iParseCount = parseWithPATRLexicon(pszLine,
												   pOutputFP,
												   NULL, FALSE,
												   &sPATRData_g);
				showAmbiguousProgress(iParseCount, iSentenceCount);
				@}
			fclose(pOutputFP);
			@}
		fclose(pInputFP);
		@}
	freePATRLexicon(&sPATRData_g);
	@}
freePATRGrammar(&sPATRData_g);
freePATRInternalMemory(&sPATRData_g);
@}
@end smallexample
@subheading Source File
@file{patrampl.c}

@c ----------------------------------------------------------------------------
@page
@node markPATRParseGarbage, parseAmpleSentenceWithPATR, loadPATRLexiconFromAmple, Functions
@section markPATRParseGarbage
@subheading Syntax
@example
#include "patr.h"

void markPATRParseGarbage(PATRData * pPATR_io);
@end example
@subheading Description
@code{markPATRParseGarbage} sets a garbage collection marker.  Since C
does not support automatic garbage collection, and the unification
algorithm can lose track of allocated feature structures, special work
must be done to keep memory from leaking away.  This function must be
called before calling @code{parseWithPATR}, and
@code{collectPATRParseGarbage} must be called afterwards.

@code{markPATRParseGarbage} has only one argument:
@table @code
@item pPATR_io
points to the data structure that contains the PC-PATR language data and
internal memory storage.
@end table
@subheading Return Value
none
@subheading Example
@ifset txt
See the example for @code{parseWithPATR} below.
@end ifset
@ifclear txt
@xref{parseWithPATR, , Example}.
@end ifclear
@subheading Source File
@file{patalloc.c}

@c ----------------------------------------------------------------------------
@page
@node parseAmpleSentenceWithPATR, parsePATRFeatureString, markPATRParseGarbage, Functions
@section parseAmpleSentenceWithPATR
@subheading Syntax
@example
#include "patr.h"

int parseAmpleSentenceWithPATR(WordTemplate ** pWords_in,
							   FILE *          pOutputFP_in,
							   char *          pszOutputFile_in,
							   int             bWarnUnusedFd_in,
							   int             bVerbose_in,
							   int             bWriteAmpleParses_in,
							   TextControl *   pTextControl_in,
							   PATRData *      pPATR_in);
@end example
@subheading Description
@code{parseAmpleSentenceWithPATR} tries to parse a sentence loaded from
an AMPLE analysis file, possibly disambiguating the morphological
analyses as a side-effect.  It requires that a PC-PATR grammar be
loaded, but does not use the PC-PATR lexicon.

The arguments to @code{parseAmpleSentenceWithPATR} are as follows:
@table @code
@item pWords_in
points to an @code{NULL} terminated array of pointers to word analyses.

@item pOutputFP_in
is an output @code{FILE} pointer.

@item pszOutputFile_in
points to the name of the output file.

@item bWarnUnusedFd_in
causes warning messages concerning undefined feature (template) names
if @code{TRUE}.

@item bVerbose_in
allows output to the standard error stream (@code{stderr}) if
@code{TRUE}.

@item bWriteAmpleParses_in
causes the PC-PATR sentence parse trees and feature structures to be
written to the output file if @code{TRUE}.

@item pTextControl_in
points to the data structure that contains the ambiguity and decomposition
marker characters.

@item pPATR_in
points to the data structure that contains the PC-PATR language data
such as the grammar.
@end table
@subheading Return Value
the number of successful parses of the sentence
@subheading Example
@smallexample
#include "patr.h"
#include "opaclib.h"
...
PATRData        sPATRData_g;
TextControl     sTextControl_g;
...
void disambiguate(char * pszAnalysis_in, char * pszOutput_in)
@{
FILE *          pInputFP;
FILE *          pOutputFP;
WordTemplate ** pSentence;
unsigned        uiAmbiguityCount;
unsigned        uiSentenceCount;
unsigned        uiParseCount;

if (sPATRData_g.pGrammar == NULL)
	return;
pInputFP = fopen( pszAnalysis_in, "r");
if (pInputFP == NULL)
	return;
pOutputFP = fopen( pszOutput_in, "w" );
if (pOutputFP == NULL)
	@{
	fclose(pInputFP);
	return;
	@}
for ( uiSentenceCount = 0, uiParseCount = 0 ;; ++uiSentenceCount )
	@{
	pSentence = readSentenceOfTemplates(pInputFP,
										pszAnalysis_in,
										".!?",
										&sTextControl_g,
										sPATRData_g.pLogFP);
	if (pSentence == NULL)
		break;
	uiAmbiguityCount = parseAmpleSentenceWithPATR(
										pSentence,
										pOutputFP, pszOutput_in,
										FALSE, FALSE, TRUE,
										&sTextControl_g,
										&sPATRData_g);
	if (uiAmbiguityCount != 0)
		++uiParseCount;
	@}
fprintf(stderr,
		"File parsing statistics: %u sentences read, %u parsed\n",
		uiSentenceCount, uiParseCount);
fclose(pInputFP);
fclose(pOutputFP);
@}
@end smallexample
@subheading Source File
@file{patrampl.c}

@c ----------------------------------------------------------------------------
@page
@node parsePATRFeatureString, parseWithAmpleForPATRLexicon, parseAmpleSentenceWithPATR, Functions
@section parsePATRFeatureString
@subheading Syntax
@example
#include "patr.h"

PATRFeature * parsePATRFeatureString(char *     pszField_in,
									 PATRData * pPATR_in);
@end example
@subheading Description
@code{parsePATRFeatureString} creates a PC-PATR feature structure from
its representation as a set of feature path expressions.

The arguments to @code{parsePATRFeatureString} are as follows:
@table @code
@item pszField_in
points to the string containing a PC-PATR feature structure represented
as a set of feature path expressions.

@item pPATR_in
points to the data structure that contains the PC-PATR language data
such as the feature template definitions.
@end table
@subheading Return Value
pointer to a PC-PATR feature structure
@subheading Example
@smallexample
#include "patr.h"
#include "opaclib.h"
...
PATRData        sPATRData_g;
...
PATRLabeledFeature * extractPATRLabeledFeature(char * pszField_in)
@{
char *                  p;
PATRFeature *           pFeature;
PATRLabeledFeature *    pNewFdDef;

p = strpbrk(pszField_in, whiteSpace);
if (p == NULL)
	return( NULL );

*p++ = NUL;
pFeature = parsePATRFeatureString(p, &sPATRData_g);
if (pFeature == NULL)
	return( NULL );

pNewFdDef = (PATRLabeledFeature *)allocMemory(
										sizeof(PATRLabeledFeature));
pNewFdDef->pszLabel = duplicateString(pszField_in);
pNewFdDef->pFeature = pFeature;
pNewFdDef->pNext    = NULL;
return( pNewFdDef );
@}
@end smallexample
@subheading Source File
@file{patrfunc.c}

@c ----------------------------------------------------------------------------
@page
@node parseWithAmpleForPATRLexicon, parseWithKimmoForPATRLexicon, parsePATRFeatureString, Functions
@section parseWithAmpleForPATRLexicon
@subheading Syntax
@example
#include "patr.h"
#include "ample.h"

PATRLexItem * parseWithAmpleForPATRLexicon(char *      pszWord_in,
										   AmpleData * pAmple_in,
										   PATRData *  pPATR_in);
@end example
@subheading Description
@code{parseWithAmpleForPATRLexicon} parses the word using the AMPLE
information already loaded into memory.  This provides an alternative
to creating a word lexicon file if an AMPLE analysis (with morpheme
lexicon files) already exists.  It is commonly used as part of a
morphological parsing function passed to @code{parseWithPATRLexicon}.

The arguments to @code{parseWithAmpleForPATRLexicon} are as follows:
@table @code
@item pszWord_in
points to the word.

@item pAmple_in
points to the data structure that contains all the information needed for
a morphological parse of the word.

@item pPATR_in
points to the data structure that contains the PC-PATR language data
such as the lexicon.
@end table
@subheading Return Value
a pointer to the node in the internal lexicon containing the newly
parsed word, or @code{NULL} if it does not parse.
@subheading Example
@smallexample
#include "patr.h"
#include "kimmo.h"
#include "ample.h"
...
PATRData        sPATRData_g;
KimmoData       sKimmoData_g;
AmpleData       sAmpleData_g;
...
static PATRLexItem * tryMorphParse(pszWord_in)
char *  pszWord_in;
@{
if (sKimmoData_g.sPATR.pGrammar != NULL)
	@{
	sKimmoData_g.pLogFP = sPATRData_g.pLogFP;
	return parseWithKimmoForPATRLexicon( pszWord_in,
										 &sKimmoData_g,
										 &sPATRData_g );
	@}
else if (sAmpleData_g.pDictionary != NULL)
	@{
	sAmpleData_g.pLogFP = sPATRData_g.pLogFP;
	return parseWithAmpleForPATRLexicon( pszWord_in,
										 &sAmpleData_g,
										 &sPATRData_g );
	@}
else
	return NULL;
@}

void parseFile(char * pszInput_in, char * pszOutput_in,
			   char * pszLexicon_in)
@{
FILE *          pInputFP;
FILE *          pOutputFP;
unsigned        uiLine;

if (sPATRData_g.pGrammar == NULL)
	return;
if (    (sPATRData_g.pLexicon        == NULL) &&
		(sKimmoData_g.sPATR.pGrammar == NULL) &&
		(sAmpleData_g.pDictionary    == NULL) )
	return;
pInputFP = fopen( pszInput_in, "r");
if (pInputFP == NULL)
	return;
pOutputFP = fopen( pszOutput_in, "w" );
if (pOutputFP == FULL)
	@{
	fclose(pInputFP);
	return;
	@}
for ( uiLine = 1, uiSentences = 0, uiParsed = 0 ;; ++uiSentences )
	@{
	pszLine = readLineFromFile(pInputFP, &uiLine,
							   sPATRData_g.cComment);
	if (pszLine == NULL)
		break;
	pszLine += strspn(pszLine, " \t\r\n");
	if (*pszLine == '\0')
		continue;
	trimTrailingWhitespace(pszLine);
	fprintf(pOutputFP, "%s\n", pszLine);
	uiAmbiguityCount = parseWithPATRLexicon(pszLine,
											pOutputFP,
											tryMorphParse,
											TRUE,
											&sPATRData_g);
	if (uiAmbiguityCount != 0)
		++uiParsed;
	@}
fprintf(stderr,
		"File parsing statistics: %u sentences read, %u parsed\n",
		uiSentences, uiParsed);
fclose(pInputFP);
fclose(pOutputFP);
/*
 *  save the lexicon entries generated by the morphological parsers
 */
if (pszLexicon_in != NULL)
	@{
	pOutputFP = fopen(pszLexicon_in, "w");
	if (pOutputFP != NULL)
		@{
		writePATRLexicon(pOutputFP, &sPATRData_g);
		fclose(pOutputFP);
		@}
	@}
@}
@end smallexample
@subheading Source File
@file{patrampl.c}

@c ----------------------------------------------------------------------------
@page
@node parseWithKimmoForPATRLexicon, parseWithPATR, parseWithAmpleForPATRLexicon, Functions
@section parseWithKimmoForPATRLexicon
@subheading Syntax
@example
#include "patr.h"
#include "kimmo.h"

PATRLexItem * parseWithKimmoForPATRLexicon(char *      pszWord_in,
										   KimmoData * pKimmo_in,
										   PATRData *  pPATR_in));
@end example
@subheading Description
@code{parseWithKimmoForPATRLexicon} parses the word using the PC-Kimmo
information already loaded into memory.  This provides an alternative
to creating a word lexicon file if an PC-Kimmo analysis (with morpheme
lexicon files) already exists.  It is commonly used as part of a
morphological parsing function passed to @code{parseWithPATRLexicon}.

The arguments to @code{parseWithKimmoForPATRLexicon} are as follows:
@table @code
@item pszWord_in
points to the word.

@item pKimmo_in
points to the data structure that contains all the information needed for
a morphological parse of the word.

@item pPATR_in
points to the data structure that contains the PC-PATR language data
such as the lexicon.
@end table
@subheading Return Value
a pointer to the node in the internal lexicon containing the newly
parsed word, or @code{NULL} if it does not parse.
@subheading Example
@ifset txt
See the example for @code{parseWithAmpleForPATRLexicon} above.
@end ifset
@ifclear txt
@xref{parseWithAmpleForPATRLexicon, , Example}.
@end ifclear
@subheading Source File
@file{parsepwk.c}

@c ----------------------------------------------------------------------------
@page
@node parseWithPATR, parseWithPATRLexicon, parseWithKimmoForPATRLexicon, Functions
@section parseWithPATR
@subheading Syntax
@example
#include "patr.h"

PATREdgeList * parseWithPATR(PATRWord * pSentence_in,
							 int *      piStage_out,
							 PATRData * pPATR_io);
@end example
@subheading Description
@code{parseWithPATR}
is the primary parsing routine in the PC-PATR function library.
It is a chart parser with these properties:
@enumerate
@item
bottom-up with top-down filtering
@item
left-to-right order@value{emdash}after each word is added to the chart, all
possible edges that can be derived up to that
point have been computed as a side-effect
@item
unification of feature structures to constrain the context-free parse.
@end enumerate

The arguments to @code{parseWithPATR} are as follows:
@table @code
@item pSentence_in
points to an ordered list of @code{PATRWord} data structures
representing a sentence.

@item piStage_out
points to an integer that provides information about how well the parse
actually succeeded.  If it is not @code{NULL}, the integer it points to
is set to one of these values:
@enumerate 0
@item Successful.
@item Turned off unification.
@item Turned off top-down filtering.
@item Can only produce "bushes", not an entire parse tree.
@item Failed to produce anything.
@item Out of memory.
@item Out of time.
@end enumerate

@item pPATR_io
points to the data structure that contains the PC-PATR language data
such as the grammar.
@end table
@subheading Return Value
a pointer to the parse chart constructed, or @code{NULL} if the parse fails
@subheading Example
@smallexample
#include "patr.h"

struct lex_item @{
	char *              pszWord;
	char *              pszGloss;
	char *              pszCat;
	unsigned int *      puiFeatures;
	@};
...
char **         ppszFeatureNames_g;
PATRData        sPATRData_g;
TRIE *          pLexicon_g;
...
PATREdgeList * parse(char * pszSentence_in)
@{
PATREdgeList *          pResult   = NULL;
PATRWord *              pSentence = NULL;
PATRWord *              pNewWord;
PATRWord *              pPrevWord = NULL;
int                     bSaveUnification;
int                     bSaveTopDownFilter;
char *                  pszWord;
struct lex_item *       pLexItem;

if (pszSentence_in == NULL)
	return NULL;
/*
 *  save pointers to temporary parse structures
 */
markPATRParseGarbage(&sPATRData_g);
/*
 *  convert the sentence string to what parseWithPATR() wants
 */
for (   pszWord = strtok(pszSentence_in, " \t\n") ;
		pszWord ;
		pszWord = strtok(NULL, " \t\n") )
	@{
	pLexItem = findDataInTRIE(pLexicon_g, pszWord);
	if (pLexItem == NULL)
		@{
		reportError(ERROR_MSG,
					"Cannot find "\%s\" in the lexicon\n",
					pszWord);
		collectPATRParseGarbage(&sPATRData_g);
		return NULL;
		@}
	pNewWord = buildPATRWordForKimmo(pszWord,
									 pLexItem->pszGloss,
									 pLexItem->pszCat,
									 pLexItem->puiFeatures,
									 ppszFeatureNames_g,
									 &sPATRData_g);
	if (pPrevWord == NULL)                      /* If first (no prev) */
		pSentence = pNewWord;                   /* Set head to this */
	else
		pPrevWord->pNext = pNewWord;            /* Else link from prev */
	pPrevWord = pNewWord;                       /* Set prev to this */
	@}

if (pSentence != NULL)
	@{
	/*
	 *  parse the word and save a permanent copy of the result
	 */
	int iStage;
	pResult = parseWithPATR(pSentence, &iStage, &sPATRData_g);
	if (pResult != NULL)
		@{
		pResult = storePATREdgeList(pResult, &sPATRData_g);
		@}
	@}
/*
 *  Free any temporary parse structures
 */
collectPATRParseGarbage(&sPATRData_g);

return( pResult );
@}

void processFile(char * pszFilename_in)
@{
char *          pszLine;
FILE *          pInputFP;
PATREdgeList *  pParse;

pInputFP = fopen(pszFilename_in, "r");
if (pInputFP == NULL)
	return;
while ((pszLine = readLineFromFile(pInputFP, NULL, '\0')) != NULL)
	@{
	pParse = parse(pszLine);
	if (pParse != NULL)
		@{
		...
		freePATREdgeList(pParse, &sPATRData_g);
		@}
	@}
fclose(pInputFP);
@}
@end smallexample
@subheading Source File
@file{lcparse.c}

@c ----------------------------------------------------------------------------
@page
@node parseWithPATRLexicon, showPATRLexicon, parseWithPATR, Functions
@section parseWithPATRLexicon
@subheading Syntax
@example
#include "patr.h"

int parseWithPATRLexicon(
			char *           pszSentence_in,
			FILE *           pOutputFP_in,
			PATRLexItem * (* pfMorphParser_in)(char * pszWord_in),
			int              bWarnUnusedFd_in,
			PATRData *       pPATR_in);
@end example
@subheading Description
@code{parseWithPATRLexicon}

The arguments to @code{parseWithPATRLexicon} are as follows:
@table @code
@item pszSentence_in
points to a string containing a sentence to parse.  The words must be
separated by whitespace characters.

@item pOutputFP_in
is an output @code{FILE} pointer.

@item pfMorphParser_in
points to a function that has one argument, a character string
representing a single word, and returns a pointer to a lexicon entry
derived by a morphological parse of the word.  If
@code{pfMorphParser_in} is @code{NULL}, then no morphological parsing
is done as a backup to the internal PC-PATR lexicon.

@item bWarnUnusedFd_in
allows warning messages concerning undefined feature (template) names
if @code{TRUE}.

@item pPATR_in
points to the data structure that contains the PC-PATR language data
such as the grammar and lexicon.
@end table
@subheading Return Value
the number of valid parses found for the sentence
@subheading Example
See also
@ifset txt
the example for @code{parseWithAmpleForPATRLexicon} above.
@end ifset
@ifclear txt
@ref{parseWithAmpleForPATRLexicon, , Example}.
@end ifclear
@smallexample
#include "patr.h"
#include "opaclib.h"

PATRData        sPATRData_g;
...
void process(char * pszGrammar_in, char * pszLexicon_in,
			 char * pszInput_in, char * pszOutput_in)
@{
FILE *  pInputFP;
FILE *  pOutputFP;
char *  pszLine;
int     iSentenceCount;
int     iParseCount;

if (loadPATRGrammar(pszGrammar_in, &sPATRData_g) == 0)
	return;
if (loadPATRLexicon(pszLexicon_in, &sPATRData_g) != 0)
	@{
	pInputFP = fopen(pszInput_in, "r");
	if (pInputFP != NULL)
		@{
		pOutputFP = fopen(pszOutput_in, "w");
		if (pOutputFP != NULL)
			@{
			iSentenceCount = 0;
			while ((pszLine = readLineFromFile(pInputFP,
											   NULL, '\0')) != NULL)
				@{
				++iSentenceCount;
				iParseCount = parseWithPATRLexicon(pszLine,
												   pOutputFP,
												   NULL,
												   FALSE,
												   &sPATRData_g);
				showAmbiguousProgress(iParseCount, iSentenceCount);
				@}
			fclose(pOutputFP);
			@}
		fclose(pInputFP);
		@}
	freePATRLexicon(&sPATRData_g);
	@}
freePATRGrammar(&sPATRData_g);
freePATRInternalMemory(&sPATRData_g);
@}
@end smallexample
@subheading Source File
@file{patrlexi.c}

@c ----------------------------------------------------------------------------
@page
@node showPATRLexicon, storePATREdgeList, parseWithPATRLexicon, Functions
@section showPATRLexicon
@subheading Syntax
@example
#include "patr.h"

void showPATRLexicon(PATRData * pPATR_in);
@end example
@subheading Description
@code{showPATRLexicon} writes the internal PC-PATR lexicon to the
standard output stream (@code{stdout}).  This is useful only for
debugging purposes, if then.

@code{showPATRLexicon} has only one argument:
@table @code
@item pPATR_in
points to the data structure that contains the PC-PATR language data
such as the lexicon.
@end table
@subheading Return Value
none
@subheading Example
@smallexample
#include "patr.h"

PATRData        sPATRData_g;
...
void test_lexicon(char * pszLexicon_in)
@{
if (loadPATRLexicon(pszLexicon_in, &sPATRData_g) != 0)
	@{
	showPATRLexicon(&sPATRData_g);
	@}
@}
@end smallexample
@subheading Source File
@file{patrlexi.c}

@c ----------------------------------------------------------------------------
@page
@node storePATREdgeList, storePATRFeature, showPATRLexicon, Functions
@section storePATREdgeList
@subheading Syntax
@example
#include "patr.h"

PATREdgeList * storePATREdgeList(PATREdgeList * pPATRResult_in,
								 PATRData *     pPATR_io);
@end example
@subheading Description
@code{storePATREdgeList} makes a permanent (unaffected by garbage
collection) copy of a parse chart.  It should be called after
@code{parseWithPATR} and before @code{collectPATRParseGarbage}.
Note that @code{freePATREdgeList} is used to free the memory allocated by
@code{storePATREdgeList}.

The arguments to @code{storePATREdgeList} are as follows:
@table @code
@item pPATRResult_in
points to a parse chart returned by @code{parseWithPATR}.

@item pPATR_io
points to the data structure that contains the PC-PATR language data and
internal memory storage.
@end table
@subheading Return Value
a pointer to a newly allocated copy of the parse chart (PATREdgeList
structure)
@subheading Example
@ifset txt
See the example for @code{parseWithPATR} above.
@end ifset
@ifclear txt
@xref{parseWithPATR, , Example}.
@end ifclear
@subheading Source File
@file{patalloc.c}

@c ----------------------------------------------------------------------------
@page
@node storePATRFeature, stringifyPATRParses, storePATREdgeList, Functions
@section storePATRFeature
@subheading Syntax
@example
#include "patr.h"

PATRFeature * storePATRFeature(PATRFeature * pFeature_in,
							   PATRData * pPATR_in);
@end example
@subheading Description
@code{storePATRFeature} makes a permanent (unaffected by garbage
collection) copy of a feature structure.  Note that
@code{freePATRFeature} is used to free the memory allocated by
@code{storePATRFeature}.

The arguments to @code{storePATRFeature} are as follows:
@table @code
@item pFeature_in
points to a feature structure that may be needed beyond the next garbage
collection call.

@item pPATR_io
points to the data structure that contains the PC-PATR language data and
internal memory storage.
@end table
@subheading Return Value
a pointer to a newly allocated copy of the feature structure
@subheading Example
@smallexample
/*FIX ME -- THIS NEEDS TO BE WRITTEN!*/
@end smallexample
@subheading Source File
@file{patalloc.c}

@c ----------------------------------------------------------------------------
@page
@node stringifyPATRParses, writePATRLexicon, storePATRFeature, Functions
@section stringifyPATRParses
@subheading Syntax
@example
#include "patr.h"

int stringifyPATRParses(PATREdgeList * pParses_in,
						PATRData *     pPATR_in,
						const char *   pszSentence_in,
						char **        ppszBuffer_out);
@end example
@subheading Description
@code{stringifyPATRParses} creates a character string representation of
a parse chart.  The output string contains both the parse trees and the
set of features indicated by the settings in the data structure pointed
to by @code{pPATR_in}.

The arguments to @code{stringifyPATRParses} are as follows:
@table @code
@item pParses_in
points to a parse chart produced by @code{parseWithPATR}.

@item pPATR_in
points to a data structure that contains the PC-PATR language data and
control variables.

@item pszSentence_in
points to a C string containing the original sentence.  It may be
@code{NULL}.

@item ppszBuffer_out
points to a pointer which will contain either @code{NULL} or the address
of dynamically allocated memory containing the character string
representation of the parse chart.
@end table
@subheading Return Value
@code{-1} if an error occurs, or @code{0} if successful
@subheading Example
@smallexample
#include "patr.h"

struct lex_item @{
	char *              pszWord;
	char *              pszGloss;
	char *              pszCat;
	unsigned int *      puiFeatures;
	@};
...
char **         ppszFeatureNames_g;
PATRData        sPATRData_g;
TRIE *          pLexicon_g;
...
char * parse(char * pszSentence_in)
@{
PATREdgeList *    pResult   = NULL;
PATRWord *        pSentence = NULL;
PATRWord *        pNewWord;
PATRWord *        pPrevWord = NULL;
int               bSaveUnification;
int               bSaveTopDownFilter;
char *            pszWord;
struct lex_item * pLexItem;
char *            pszResult = NULL;

if (pszSentence_in == NULL)
	return NULL;
/*
 *  save pointers to temporary parse structures
 */
markPATRParseGarbage(&sPATRData_g);
/*
 *  convert the sentence string to what parseWithPATR() wants
 */
for (   pszWord = strtok(pszSentence_in, " \t\n") ;
		pszWord ;
		pszWord = strtok(NULL, " \t\n") )
	@{
	pLexItem = findDataInTRIE(pLexicon_g, pszWord);
	if (pLexItem == NULL)
		@{
		reportError(ERROR_MSG,
					"Cannot find "\%s\" in the lexicon\n",
					pszWord);
		collectPATRParseGarbage(&sPATRData_g);
		return NULL;
		@}
	pNewWord = buildPATRWordForKimmo(pszWord,
									 pLexItem->pszGloss,
									 pLexItem->pszCat,
									 pLexItem->puiFeatures,
									 ppszFeatureNames_g,
									 &sPATRData_g);
	if (pPrevWord == NULL)                      /* If first (no prev) */
		pSentence = pNewWord;                   /* Set head to this */
	else
		pPrevWord->pNext = pNewWord;            /* Else link from prev */
	pPrevWord = pNewWord;                       /* Set prev to this */
	@}

if (pSentence != NULL)
	@{
	/*
	 *  parse the word and save a permanent copy of the result
	 */
	int iStage;
	pResult = parseWithPATR(pSentence, &iStage, &sPATRData_g);
	if (pResult != NULL)
		@{
		stringifyPATRParses(pResult, &sPATRData_g, NULL, pszResult);
		@}
	@}
/*
 *  Free any temporary parse structures
 */
collectPATRParseGarbage(&sPATRData_g);

return pszResult;
@}

void processFile(char * pszFilename_in)
@{
char *  pszLine;
FILE *  pInputFP;
char *  pszParse;

pInputFP = fopen(pszFilename_in, "r");
if (pInputFP == NULL)
	return;
while ((pszLine = readLineFromFile(pInputFP, NULL, '\0')) != NULL)
	@{
	pszParse = parse(pszLine);
	if (pszParse != NULL)
		@{
		...
		freeMemory(pszParse);
		@}
	@}
fclose(pInputFP);
@}
@end smallexample
@subheading Source File
@file{patrstrg.c}

@c ----------------------------------------------------------------------------
@page
@node writePATRLexicon, writePATRParses, stringifyPATRParses, Functions
@section writePATRLexicon
@subheading Syntax
@example
#include "patr.h"

void writePATRLexicon(FILE *     pOutputFP_in,
					  PATRData * pPATR_in);
@end example
@subheading Description
@code{writePATRLexicon} writes the internal PC-PATR lexicon to a file
in a form suitable for reloading with @code{loadPATRLexicon}.  This is
most useful when a morphological parser is used to populate the
lexicon.
@ifset txt
See the descriptions of @code{parseWithAmpleForPATRLexicon}
@code{parseWithKimmoForPATRLexicon}, and @code{parseWithPATRLexicon}
above.
@end ifset
@ifclear txt
@xref{parseWithAmpleForPATRLexicon},
@ref{parseWithKimmoForPATRLexicon}, and @ref{parseWithPATRLexicon}.
@end ifclear

The arguments to @code{writePATRLexicon} are as follows:
@table @code
@item pOutputFP_in
is an output @code{FILE} pointer.

@item pPATR_in
points to the data structure that contains the PC-PATR language data
such as the lexicon.
@end table
@subheading Return Value
none
@subheading Example
@ifset txt
See the example for @code{parseWithAmpleForPATRLexicon} above.
@end ifset
@ifclear txt
@xref{parseWithAmpleForPATRLexicon, , Example}.
@end ifclear
@subheading Source File
@file{patrlexi.c}

@c ----------------------------------------------------------------------------
@page
@node writePATRParses, writePATRStyledOutput, writePATRLexicon, Functions
@section writePATRParses
@subheading Syntax
@example
#include "patr.h"

void writePATRParses(PATREdgeList * pParses_in,
					 FILE *         pOutputFP_in,
					 PATRData *     pPATR_in);
@end example
@subheading Description
@code{writePATRParses} writes the parse trees and associated features
from the parse chart pointed to by @code{pParses_in}.  How many parse
trees are written, and how they are displayed, is controlled by
@code{pPATR_in->iMaxAmbiguities} and @code{pPATR_in->eTreeDisplay}.
The bits in @code{pPATR_in->iFeatureDisplay} control which features are
written, and how they are displayed in the output file.

The arguments to @code{writePATRParses} are as follows:
@table @code
@item pParses_in
points to a parse chart produced by @code{parseWithPATR}.

@item pOutputFP_in
is an output @code{FILE} pointer.

@item pPATR_in
points to a data structure that contains the PC-PATR language data and
control variables.
@end table
@subheading Return Value
none
@subheading Example
@smallexample
#include "patr.h"

struct lex_item @{
	char *              pszWord;
	char *              pszGloss;
	char *              pszCat;
	unsigned int *      puiFeatures;
	@};
...
char **         ppszFeatureNames_g;
PATRData        sPATRData_g;
TRIE *          pLexicon_g;
...
void parse(char * pszSentence_in, FILE * pOutputFP_in)
@{
PATREdgeList *          pResult   = NULL;
PATRWord *              pSentence = NULL;
PATRWord *              pNewWord;
PATRWord *              pPrevWord = NULL;
int                     bSaveUnification;
int                     bSaveTopDownFilter;
char *                  pszWord;
struct lex_item *       pLexItem;
unsigned                uiParseCount = 0;

if ((pszSentence_in == NULL) || (pOutputFP_in == NULL))
	return;
fprintf(pOutputFP_in, "%s\n", pszSentence_in);
/*
 *  save pointers to temporary parse structures
 */
markPATRParseGarbage(&sPATRData_g);
/*
 *  convert the sentence string to what parseWithPATR() wants
 */
for (   pszWord = strtok(pszSentence_in, " \t\n") ;
		pszWord ;
		pszWord = strtok(NULL, " \t\n") )
	@{
	pLexItem = findDataInTRIE(pLexicon_g, pszWord);
	if (pLexItem == NULL)
		@{
		reportError(ERROR_MSG,
					"Cannot find "\%s\" in the lexicon\n",
					pszWord);
		collectPATRParseGarbage(&sPATRData_g);
		return;
		@}
	pNewWord = buildPATRWordForKimmo(pszWord,
									 pLexItem->pszGloss,
									 pLexItem->pszCat,
									 pLexItem->puiFeatures,
									 ppszFeatureNames_g,
									 &sPATRData_g);
	if (pPrevWord == NULL)                      /* If first (no prev) */
		pSentence = pNewWord;                   /* Set head to this */
	else
		pPrevWord->pNext = pNewWord;            /* Else link from prev */
	pPrevWord = pNewWord;                       /* Set prev to this */
	@}

if (pSentence != NULL)
	@{
	/*
	 *  parse the word and save a permanent copy of the result
	 */
	int iStage;
	const char * psz = NULL;
	PATREdgeList * pel;

	pResult = parseWithPATR(pSentence, &iStage, &sPATRData_g);
	if (iStage != 0)
		fprintf(pOutputFP_in,
				"**** Cannot parse this sentence ****\n");
	switch (iStage)
		@{
		case 0:
			for ( pel = pResult ; pel ; pel = pel->pNext )
				++uiParseCount;
			break;
		case 1:
			psz = "**** Turning off unification ****\n";
			break;
		case 2:
			psz = "**** Turning off top-down filtering ****\n";
			break;
		case 3:
			psz = "**** Building the largest parse \"bush\" ****\n";
			break;
		case 4:
			psz = "**** No output available ****\n";
			break;
		case 5:
			psz = "**** Out of Memory (after %lu edges) ****\n";
			break;
		case 6:
			psz = "**** Out of Time (after %lu edges) ****\n";
			break;
		@}
	if (psz)
		fprintf(pOutputFP_in, psz, pPATR_in->uiEdgesAdded);
	if (pResult)
		@{
		writePATRParses(pResult, pOutputFP_in, pPATR_in);
		putc('\n', pOutputFP_in);
		@}
	@}
else
	@{
	fprintf(pOutputFP_in, "**** Nothing to parse ****\n");
	@}
/*
 *  Free any temporary parse structures
 */
collectPATRParseGarbage(&sPATRData_g);
@}

void processFile(char * pszInput_in, char * pszOutput_in)
@{
char *  pszLine;
FILE *  pInputFP;
FILE *  pOutputFP;

pInputFP = fopen(pszInput_in, "r");
if (pInputFP == NULL)
	return;
pOutputFP = fopen(pszInput_in, "r");
if (pOutputFP == NULL)
	@{
	fclose(pInputFP);
	return;
	@}
while ((pszLine = readLineFromFile(pInputFP, NULL, '\0')) != NULL)
	@{
	parse(pszLine, pOutputFP);
	@}
fclose(pInputFP);
fclose(pOutputFP);
@}
@end smallexample
@subheading Source File
@file{userpatr.c}

@c ----------------------------------------------------------------------------
@page
@node writePATRStyledOutput, , writePATRParses, Functions
@section writePATRStyledOutput
@subheading Syntax
@example
#include "patr.h"

void writePATRStyledOutput(PATREdgeList *    pParses_in,
						   char *            pszWord_in,
						   char *            pszLex_in,
						   char *            pszGloss_in,
						   FILE *            pOutputFP_in,
						   PATRFeatureTags * pFeatTags_in,
						   char *            pszParseStartTag_in,
						   char *            pszParseEndTag_in,
						   PATRData *        pPATR_in,
						   unsigned *        puiAmbigCount_io);
@end example
@subheading Description
@code{writePATRStyledOutput} writes the parse trees and associated
features from the parse chart pointed to by @code{pParses_in} in a
highly stylized fashion.  (It was written for KTAGGER and may not be
useful for any other purpose.)

The arguments to @code{writePATRStyledOutput} are as follows:
@table @code
@item pParses_in
points to a parse chart produced by @code{parseWithPATR}.
Each parse tree is written as the value of
the @code{<TREE>} feature referenced by @code{pFeatTags_in}, and its
top level feature structure is written as the value of the
@code{<FEAT>} feature referenced by @code{pFeatTags_in}.

@item pszWord_in
points to the word (or sentence) that was parsed by
@code{parseWithPATR}.  It is written as
the value of the @code{<WORD>} feature referenced by @code{pFeatTags_in}.

@item pszLex_in
points to a concatenated string of morphemes (words) found in the word
(sentence).  It is written as the value of the @code{<LEX>} feature
referenced by @code{pFeatTags_in}.

@item pszGloss_in
points to a concatenated string of glosses for the morphemes (words)
found in the word (sentence).  It is written as the value of the
@code{<GLOSS>} feature referenced by @code{pFeatTags_in}.

@item pOutputFP_in
is an output @code{FILE} pointer.

@item pFeatTags_in
points to a list of data structures containing feature paths with
associated start and end tags.  Feature paths that do not match one of
the five special values (@code{<TREE>}, @code{<FEAT>}, @code{<WORD>},
@code{<LEX>}, or @code{<GLOSS>}) are matched against the top level
feature structure associated with the current parse.

@item pszParseStartTag_in
points to a string used to mark the beginning of a parse in the output
file.

@item pszParseEndTag_in
points to a string to mark the end of a parse in the output file.

@item pPATR_in
points to a data structure that contains the PC-PATR language data and
control variables.

@item puiAmbigCount_io
points to an unsigned integer that counts the number of parses pointed
to by @code{pParses_in}.  The number is added to by
@code{writePATRStyledOutput}.
@end table
@subheading Return Value
none
@subheading Example
@smallexample
#include <stdio.h>
#include <string.h>
#include "patr.h"
#include "kimmo.h"
#include "opaclib.h"
...
KimmoData               sKimmoData_g;
PATRFeatureTags *       pFeatureTags_g;
...
void process(char * pszInput_in, char * pszOutput_in)
@{
char *          pszLine;
char *          pszWord;
KimmoResult *   pKimmoResults;
KimmoResult *   pResult;
char *          pszMorphGlosses = NULL;
char *          pszMorphLexes = NULL;
unsigned        uiAmbiguityCount;
unsigned        uiDotsCount = 0;
FILE *          pInputFP;
FILE *          pOutputFP;

pInputFP = fopen(pszInput_in, "r");
if (pInputFP == NULL)
	return;
pOutputFP = fopen(pszOutput_in, "w");
if (pOutputFP == NULL)
	@{
	fclose(pInputFP);
	return;
	@}
while ((pszLine = readLineFromFile(pInputFP, NULL, 0)) != NULL)
	@{
	pszWord = strspn(pszLine, " \t\r\n\f");
	if (*pszWord == '\0')
		continue;
	trimTrailingWhitespace(pszWord);
	fprintf(pOutputFP, "<word>\n");

	pKimmoResults = applyKimmoRecognizer((unsigned char *)pszWord,
										 &sKimmoData_g);

	for (   pResult = pKimmoResults, uiAmbiguityCount = 0 ;
			pResult ;
			pResult = pResult->pNext )
		@{
		pszMorphLexes   = (char *)concatKimmoMorphLexemes(
												pResult->pAnalysis,
												"",
												&sKimmoData_g);
		pszMorphGlosses = (char *)concatKimmoMorphGlosses(
												pResult->pAnalysis,
												"",
												&sKimmoData_g);
		writePATRStyledOutput(pResult->pParseChart,
							  pszWord,
							  pszMorphLexes,
							  pszMorphGlosses,
							  pOutputFP,
							  pFeatureTags_g,
							  "<parse>", "</parse>",
							  &sKimmoData_g.sPATR,
							  &uiAmbiguityCount);
		fprintf(pOutputFP, "\n");
		freeMemory(pszMorphLexes);
		freeMemory(pszMorphGlosses);
		@}
	if (pKimmoResults == NULL)
		fprintf(pOutputFP, "<parse>*** %s ***</parse>\n", pszWord);
	else
		freeKimmoResult( pKimmoResults );
	fprintf(pOutputFP, "</word>\n");
	@}
fclose(pInputFP);
fclose(pOutputFP);
@}
@end smallexample
@subheading Source File
@file{wrtstyle.c}

@c ----------------------------------------------------------------------------

@contents
@bye
