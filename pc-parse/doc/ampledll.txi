\input pcparse % common TeX setup  @c -*-texinfo-*-
\input texinfo
@c %**start of header
@setfilename ampledll.info
@settitle AMPLE322 DLL Reference Manual
@c %**end of header

@set TITLE AMPLE322 DLL Reference Manual
@set SUBTITLE Windows functions for morphological parsing
@set VERSION based on AMPLE functions version 3.3.16
@set DATE March 2001
@set AUTHOR by Stephen McConnel (additions for versions 3.2.5-3.3.16 by Andy Black)
@set COPYRIGHT Copyright @copyright{} 2001 SIL International

@include front.txi

@c ----------------------------------------------------------------------------
@node    Top,       Introduction,  (dir),    (dir)
@comment node-name, next,          previous, up
@menu
* Introduction::

* Functions::

* Error messages::
@end menu
@c ----------------------------------------------------------------------------
@node    Introduction, Functions, Top,      Top
@comment node-name,    next,      previous, up
@chapter Introduction to the AMPLE DLL

Since it was released in 1988, the AMPLE program has been used for
morphological analysis in many different languages.  It has always
functioned as a batch processing program, which is useful for production
work such as analyzing an entire book, but is less useful during the
early stages of developing a morphological description.  The AMPLE DLL
has therefore been developed with the goal of making it possible to embed

AMPLE style morphological parsing into Windows programs written in a
variety of programming languages.

The AMPLE322 DLL is built with the AMPLE function library.  Its main
advantages over the AMPLE function library are that it allows bug fix
updates to be used without relinking the program, and it allows the
library to be used from programming languages that do not directly
interface with C code.

@ifclear txt
@xref{Top, , Introduction, amplelib.info, AMPLE Function Library Reference Manual}.
@end ifclear
For maximum usefulness, it is a Win32 DLL, not a Win16 (Microsoft
Windows 3.x) DLL.  It is compiled for an 80386 or better CPU, and is
compatible with Microsoft Windows NT, Windows 95, and Windows 98.

Beginning with version 3.3.16, there is also an XAMPLE DLL.
This has all the capabilities and functions of the AMPLE322
DLL with the addition of allowing the use of a PC-PATR word
grammar.  The XAMPLE DLL has one additional function: @code{AmpleLoadGrammarFile}.

This manual, and the DLL it documents, are still being revised.

@c ----------------------------------------------------------------------------
@node Functions, Error messages, Introduction, Top
@chapter AMPLE322 DLL functions

All but one AMPLE322 DLL function (@code{AmpleCreateSetup}) return a
character string.  This string contains either a value dependent on the
function or an error message.

(Please note that @code{AmpleLoadGrammarFile} is only
available for the XAMPLE DLL.)

@menu
* AmpleAddSelectiveAnalysisMorphs::
* AmpleApplyInputChangesToWord::
* AmpleCheckMorphReferences::
* AmpleCreateSetup::
* AmpleDeleteSetup::
* AmpleGetAllAllomorphs::
* AmpleGetParameter::
* AmpleGetTraceString::
* AmpleInitializeMorphChecking::
* AmpleInitializeTraceString::
* AmpleLoadControlFiles::
* AmpleLoadDictionary::
* AmpleLoadGrammarFile::
* AmpleParseFile::
* AmpleParseText::
* AmpleRemoveSelectiveAnalysisMorphs::
* AmpleReportVersion::
* AmpleReset::
* AmpleSetParameter::
* AmpleUpdateEntry::
* AmpleVerifyLoading::
* AmpleWriteDictionary::
@end menu

@c ----------------------------------------------------------------------------
@page
@node AmpleAddSelectiveAnalysisMorphs, AmpleApplyInputChangesToWord, , Functions
@unnumberedsec AmpleAddSelectiveAnalysisMorphs
@subheading Syntax
@example
DllExport const char * AmpleAddSelectiveAnalysisMorphs(
						AmpleSetup *  pSetup_io,
						const char * pszMorphs_in)
@end example
@subheading Description
@code{AmpleAddSelectiveAnalysisMorphs} adds one or more morphnames to
the existing list of morphnames for selective analysis.  It may be
called once or more than once to build up the list of morphnames.

@code{AmpleAddSelectiveAnalysisMorphs} is an alternative to
@code{AmpleSetParameter(}@code{ampleSetup,} @code{"SelectiveAnalysisFile",}
@code{filename)}.  It erases any filename stored for the
@code{SelectiveAnalysisFile} parameter, but does not erase any
morphnames already in the list for selective analysis.
@subheading Return Value
a string indicating success or failure
@subheading Example
@smallexample
#include <windows.h>
typedef struct ample_setup AmpleSetup;
typedef AmpleSetup * (* AMPLEFUNC0)(void);
typedef const char * (* AMPLEFUNC1)(AmpleSetup *);
typedef const char * (* AMPLEFUNC2)(AmpleSetup *,
									const char *);
...
HANDLE          hAmpleLib;
AMPLEFUNC0      pfAmpleCreateSetup;
AMPLEFUNC1      pfAmpleDeleteSetup;
AMPLEFUNC2      pfAmpleAddSelectiveAnalysisMorphs;
AmpleSetup *    pAmple = NULL;
const char *    pszResult;
...
char            szNewEntry[] = "\
\\m mateo\n\
\\t root\n\
\\c N0\n\
\\a mateo @{Matthew_1@}\n\
\\a mateu @{Matthew_2@}\n\
\\a matei @{Matthew_3@}\n\
";
hAmpleLib = LoadLibrary("AMPLE322.DLL");
if ((unsigned long)hAmpleLib < 32)
	@{
	MessageBox(0, "Error loading AMPLE322.DLL", "App Name",
			   MB_OK | MB_ICONEXCLAMATION);
	hAmpleLib = 0;
	@}
...
if (hAmpleLib != 0)
	@{
	pfAmpleCreateSetup = (AMPLEFUNC0)GetProcAddress(hAmpleLib_g,
								"AmpleCreateSetup");
	if (pfAmpleCreateSetup == NULL)
		@{
		MessageBox(0,
				   "Cannot find AmpleCreateSetup in AMPLE322.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		@}
	pfAmpleDeleteSetup = (AMPLEFUNC1)GetProcAddress(hAmpleLib_g,
								"AmpleDeleteSetup");
	if (pfAmpleDeleteSetup == NULL)
		@{
		MessageBox(0,
				   "Cannot find AmpleDeleteSetup in AMPLE322.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		@}
	pfAmpleAddSelectiveAnalysisMorphs =
				(AMPLEFUNC2)GetProcAddress(hAmpleLib,
								"AmpleAddSelectiveAnalysisMorphs");
	if (pfAmpleAddSelectiveAnalysisMorphs == NULL)
		@{
		MessageBox(0,
	"Cannot find AmpleAddSelectiveAnalysisMorphs in AMPLE322.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		@}
	if (    (pfAmpleCreateSetup == NULL) ||
			(pfAmpleDeleteSetup == NULL) ||
			(pfAmpleAddSelectiveAnalysisMorphs == NULL) )
		return -1;              /* signal an error */
	@}
...
pAmple = (*pfAmpleCreateSetup)();
if (pAmple == NULL)
	return -1;                  /* signal an error */
...
pszResult = (*pfAmpleAddSelectiveAnalysisMorphs)(pAmple,
												 szNewEntry);
...
(*pfAmpleDeleteSetup)(pAmple);
pAmple = NULL;
...
if (hAmpleLib != 0)
	@{
	FreeLibrary(hAmpleLib);
	hAmpleLib                         = 0;
	pfAmpleCreateSetup                = NULL;
	pfAmpleDeleteSetup                = NULL;
	pfAmpleAddSelectiveAnalysisMorphs = NULL;
	...
	@}
...
@end smallexample
@subheading Source File
@file{ampledll.c}

@c ----------------------------------------------------------------------------
@page
@node AmpleApplyInputChangesToWord, AmpleCheckMorphReferences, AmpleAddSelectiveAnalysisMorphs, Functions
@unnumberedsec AmpleApplyInputChangesToWord
@subheading Syntax
@example
DllExport const char * AmpleApplyInputChangesToWord(
					   AmpleSetup * pSetup_io,
					   const char * pszWord_in)
@end example
@subheading Description
@code{AmpleApplyInputChangesToWord} applies any input text changes to the
word in @code{pszWord_in}.

It should only be invoked after @code{AmpleLoadControlFiles} has been
successfully invoked.  It will typically be called before invoking
@code{AmpleParseText}.
@subheading Return Value
a string containing either the word after input text changes have
applied or an error message
@subheading Example
@smallexample
#include <windows.h>
typedef struct ample_setup AmpleSetup;
typedef AmpleSetup * (* AMPLEFUNC0)(void);
typedef const char * (* AMPLEFUNC1)(AmpleSetup *);
typedef const char * (* AMPLEFUNC2)(AmpleSetup *,
									const char *);
...
HANDLE          hAmpleLib;
AMPLEFUNC0      pfAmpleCreateSetup;
AMPLEFUNC1      pfAmpleDeleteSetup;
AMPLEFUNC2      pfAmpleApplyInputChangesToWord;
AMPLEFUNC2      pfAmpleParseText;
const char *    pszResult;
AmpleSetup *    pAmple;
...
hAmpleLib = LoadLibrary("AMPLE322.DLL");
if ((unsigned long)hAmpleLib < 32)
	{
	MessageBox(0, "Error loading AMPLE322.DLL", "App Name",
			   MB_OK | MB_ICONEXCLAMATION);
	hAmpleLib = 0;
	}
...
if (hAmpleLib != 0)
	{
	pfAmpleCreateSetup = (AMPLEFUNC0)GetProcAddress(hAmpleLib_g,
								"AmpleCreateSetup");
	if (pfAmpleCreateSetup == NULL)
		{
		MessageBox(0,
				   "Cannot find AmpleCreateSetup in AMPLE322.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		}
	pfAmpleDeleteSetup = (AMPLEFUNC1)GetProcAddress(hAmpleLib_g,
								"AmpleDeleteSetup");
	if (pfAmpleDeleteSetup == NULL)
		{
		MessageBox(0,
				   "Cannot find AmpleDeleteSetup in AMPLE322.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		}
	pfAmpleParseText = (AMPLEFUNC2)GetProcAddress(hAmpleLib,
												  "AmpleParseText");
	if (pfAmpleParseText == NULL)
		{
		MessageBox(0, "Cannot find AmpleParseText in AMPLE322.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		}
	pfAmpleApplyInputChangesToWord = (AMPLEFUNC2)GetProcAddress(hAmpleLib,
												  "AmpleApplyInputChangesToWord");
	if (pfAmpleApplyInputChangesToWord == NULL)
		{
		MessageBox(0, "Cannot find AmpleApplyInputChangesToWord in AMPLE322.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		}
	if (    (pfAmpleCreateSetup             == NULL) ||
			(pfAmpleDeleteSetup             == NULL) ||
			(pfAmpleApplyInputChangesToWord == NULL) ||
			(pfAmpleParseText               == NULL) )
		return -1;              /* signal an error */
	}
...
pAmple = (*pfAmpleCreateSetup)();
if (pAmple == NULL)
	return -1;                  /* signal an error */
...
pszResult = (*pfAmpleParseText)(pAmple,
		(*pfAmpleApplyInputChangesToWord)(pAmple,
		"Chayta rikar loomaman wicharkur hamakuykuran yachachinanpaq."));
...
(*pfAmpleDeleteSetup)(pAmple);
pAmple = NULL;
...
if (hAmpleLib != 0)
	{
	FreeLibrary(hAmpleLib);
	hAmpleLib                      = 0;
	pfAmpleCreateSetup             = NULL;
	pfAmpleDeleteSetup             = NULL;
	pfAmpleApplyInputChangesToWord = NULL;
	pfAmpleParseText               = NULL;
	...
	}
...
@end smallexample
@subheading Source File
@file{ampledll.c}

@c ----------------------------------------------------------------------------
@page
@node AmpleCheckMorphReferences, AmpleCreateSetup, AmpleApplyInputChangesToWord, Functions
@unnumberedsec AmpleCheckMorphReferences
@subheading Syntax
@example
DllExport const char * AmpleCheckMorphReferences(
						AmpleSetup *  pSetup_io)
@end example
@subheading Description
@code{AmpleCheckMorphReferences} checks that all referenced morphnames
in dictionary entries and control information are defined in the
dictionaries.
It reports any unreferenced morphnames to the log file.
@code{AmpleCheckMorphReferences} should be invoked after
@code{AmpleInitializeMorphChecking}, @code{AmpleLoadControlFiles}, and
all calls to @code{AmpleLoadDictionary}.
If no log file has been defined, it does nothing.
If @code{AmpleSetParameter(}@code{ampleSetup,} @code{"CheckMorphReferences",}
@code{"TRUE")} has not been performed, it will perform it.
@subheading Return Value
a string indicating success or failure
@subheading Example
@smallexample
#include <windows.h>
typedef struct ample_setup AmpleSetup;
typedef AmpleSetup * (* AMPLEFUNC0)(void);
typedef const char * (* AMPLEFUNC1)(AmpleSetup *);
...
HANDLE          hAmpleLib;
AMPLEFUNC0      pfAmpleCreateSetup;
AMPLEFUNC1      pfAmpleDeleteSetup;
AMPLEFUNC3      pfAmpleSetParameter;
AMPLEFUNC5      pfAmpleLoadControlFiles;
AMPLEFUNC2      pfAmpleLoadDictionary;
AMPLEFUNC1      pfAmpleInitializeMorphChecking;
AMPLEFUNC1      pfAmpleCheckMorphReferences;
const char *    pszResult;
AmpleSetup *    pAmple;
...
hAmpleLib = LoadLibrary("AMPLE322.DLL");
if ((unsigned long)hAmpleLib < 32)
	@{
	MessageBox(0, "Error loading AMPLE322.DLL", "App Name",
			   MB_OK | MB_ICONEXCLAMATION);
	hAmpleLib = 0;
	@}
...
if (hAmpleLib != 0)
	@{
	pfAmpleCreateSetup = (AMPLEFUNC0)GetProcAddress(hAmpleLib_g,
								"AmpleCreateSetup");
	if (pfAmpleCreateSetup == NULL)
		@{
		MessageBox(0,
				   "Cannot find AmpleCreateSetup in AMPLE322.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		@}
	pfAmpleDeleteSetup = (AMPLEFUNC1)GetProcAddress(hAmpleLib_g,
								"AmpleDeleteSetup");
	if (pfAmpleDeleteSetup == NULL)
		@{
		MessageBox(0,
				   "Cannot find AmpleDeleteSetup in AMPLE322.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		@}
	pfAmpleSetParameter = (AMPLEFUNC3)GetProcAddress(hAmpleLib,
												"AmpleSetParameter");
	if (pfAmpleSetParameter == NULL)
		@{
		MessageBox(0, "Cannot find AmpleSetParameter in AMPLE322.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		@}
	pfAmpleLoadControlFiles = (AMPLEFUNC5)GetProcAddress(hAmpleLib,
											"AmpleLoadControlFiles");
	if (pfAmpleLoadControlFiles == NULL)
		@{
		MessageBox(0,
				   "Cannot find AmpleLoadControlFiles in AMPLE322.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		@}
	pfAmpleLoadDictionary = (AMPLEFUNC2)GetProcAddress(
									hAmpleLib,
									"AmpleLoadDictionary");
	if (pfAmpleLoadDictionary == NULL)
		@{
		MessageBox(0,
				   "Cannot find AmpleLoadDictionary in AMPLE322.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		@}
	pfAmpleInitializeMorphChecking = (AMPLEFUNC2)GetProcAddress(hAmpleLib,
											   "AmpleInitializeMorphChecking");
	if (pfAmpleInitializeMorphChecking == NULL)
		@{
		MessageBox(0, "Cannot find AmpleInitializeMorphChecking in AMPLE322.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		@}
	pfAmpleCheckMorphReferences = (AMPLEFUNC2)GetProcAddress(hAmpleLib,
												  "AmpleCheckMorphReferences");
	if (pfAmpleCheckMorphReferences == NULL)
		@{
		MessageBox(0, "Cannot find AmpleCheckMorphReferences in AMPLE322.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		@}
	if (    (pfAmpleCreateSetup             == NULL) ||
			(pfAmpleDeleteSetup             == NULL) ||
			(pfAmpleSetParameter            == NULL) ||
			(pfAmpleLoadControlFiles        == NULL) ||
			(pfAmpleLoadDictionary          == NULL) ||
			(pfAmpleInitializeMorphChecking == NULL) ||
			(pfAmpleCheckMorphReferences    == NULL) )
		return -1;              /* signal an error */
	@}
...
pAmple = (*pfAmpleCreateSetup)();
if (pAmple == NULL)
	return -1;                  /* signal an error */
...
pszResult = (*pfAmpleSetParameter)(pAmple,
								   "LogFile",
								   "D:/HG/HGMT05.LOG");
...
pszResult = (*pfAmpleInitializeMorphChecking)(pAmple);
...
pszResult = (*pfAmpleLoadControlFiles)(pAmple,
									   "D:/HG/HGAD01.CTL",
									   "D:/HG/HGANCD.TAB",
									   NULL,
									   "D:/HG/HGINTX.CTL");
...
pszResult = (*pfAmpleLoadDictionary)(pAmple,
									 "D:/HG/HGMORPH.DIC");
...
pszResult = (*pfAmpleCheckMorphReferences)(pAmple);
...
(*pfAmpleDeleteSetup)(pAmple);
pAmple = NULL;
...
if (hAmpleLib != 0)
	@{
	FreeLibrary(hAmpleLib);
	hAmpleLib                      = 0;
	pfAmpleCreateSetup             = NULL;
	pfAmpleDeleteSetup             = NULL;
	pfAmpleSetParameter            = NULL;
	pfAmpleLoadControlFiles        = NULL;
	pfAmpleLoadDictionary          = NULL;
	pfAmpleInitializeMorphChecking = NULL;
	pfAmpleCheckMorphReferences    = NULL;
	...
	@}
...
@end smallexample
@subheading Source File
@file{ampledll.c}

@c ----------------------------------------------------------------------------
@page
@node AmpleCreateSetup, AmpleDeleteSetup, AmpleCheckMorphReferences, Functions
@unnumberedsec AmpleCreateSetup
@example
DllExport AmpleSetup * AmpleCreateSetup()
@end example

@subheading Description
@code{AmpleCreateSetup} creates a new @code{AmpleSetup} data structure,
initializing it to be empty.  This is required before any of the other
functions is called.  It can be called multiple times to allow multiple
independent AMPLE setups to be loaded into memory simultaneously.

@subheading Return Value
a pointer to the newly created and allocated @code{AmpleSetup} data
structure.  This pointer serves as a ``magic cookie'' to all of the other
functions.
@subheading Example
@smallexample
#include <windows.h>
typedef struct ample_setup AmpleSetup;
typedef AmpleSetup * (* AMPLEFUNC0)(void);
typedef const char * (* AMPLEFUNC1)(AmpleSetup *);
typedef const char * (* AMPLEFUNC2)(AmpleSetup *,
									const char *);
typedef const char * (* AMPLEFUNC3)(AmpleSetup *,
									const char *,
									const char *);
typedef const char * (* AMPLEFUNC5)(AmpleSetup *,
									const char *,
									const char *,
									const char *,
									const char *);
...
HANDLE          hAmpleLib;
AMPLEFUNC0      pfAmpleCreateSetup;
AMPLEFUNC1      pfAmpleDeleteSetup;
AMPLEFUNC3      pfAmpleSetParameter;
AMPLEFUNC5      pfAmpleLoadControlFiles;
AMPLEFUNC2      pfAmpleLoadDictionary;
2AMPLEFUNC3      pfAmpleParseFile;
const char *    pszResult;
AmpleSetup *    pAmple;
...
hAmpleLib = LoadLibrary("AMPLE322.DLL");
if ((unsigned long)hAmpleLib < 32)
	@{
	MessageBox(0, "Error loading AMPLE322.DLL", "App Name",
			   MB_OK | MB_ICONEXCLAMATION);
	hAmpleLib = 0;
	@}
...
if (hAmpleLib != 0)
	@{
	pfAmpleCreateSetup = (AMPLEFUNC0)GetProcAddress(hAmpleLib_g,
								"AmpleCreateSetup");
	if (pfAmpleCreateSetup == NULL)
		@{
		MessageBox(0,
				   "Cannot find AmpleCreateSetup in AMPLE322.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		@}
	pfAmpleDeleteSetup = (AMPLEFUNC1)GetProcAddress(hAmpleLib_g,
								"AmpleDeleteSetup");
	if (pfAmpleDeleteSetup == NULL)
		@{
		MessageBox(0,
				   "Cannot find AmpleDeleteSetup in AMPLE322.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		@}
	pfAmpleSetParameter = (AMPLEFUNC3)GetProcAddress(hAmpleLib,
												"AmpleSetParameter");
	if (pfAmpleSetParameter == NULL)
		@{
		MessageBox(0, "Cannot find AmpleSetParameter in AMPLE322.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		@}
	pfAmpleLoadControlFiles = (AMPLEFUNC5)GetProcAddress(hAmpleLib,
											"AmpleLoadControlFiles");
	if (pfAmpleLoadControlFiles == NULL)
		@{
		MessageBox(0,
				   "Cannot find AmpleLoadControlFiles in AMPLE322.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		@}
	pfAmpleLoadDictionary = (AMPLEFUNC2)GetProcAddress(
									hAmpleLib,
									"AmpleLoadDictionary");
	if (pfAmpleLoadDictionary == NULL)
		@{
		MessageBox(0,
				   "Cannot find AmpleLoadDictionary in AMPLE322.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		@}
	pfAmpleParseFile = (AMPLEFUNC3)GetProcAddress(hAmpleLib,
												  "AmpleParseFile");
	if (pfAmpleParseFile == NULL)
		@{
		MessageBox(0, "Cannot find AmpleParseFile in AMPLE322.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		@}
	if (    (pfAmpleCreateSetup      == NULL) ||
			(pfAmpleDeleteSetup      == NULL) ||
			(pfAmpleSetParameter     == NULL) ||
			(pfAmpleLoadControlFiles == NULL) ||
			(pfAmpleLoadDictionary   == NULL) ||
			(pfAmpleParseFile        == NULL) )
		return -1;              /* signal an error */
	@}
...
pAmple = (*pfAmpleCreateSetup)();
if (pAmple == NULL)
	return -1;                  /* signal an error */
pszResult = (*pfAmpleSetParameter)(pAmple,
								   "LogFile",
								   "D:/HG/HGMT05.LOG");
...
pszResult = (*pfAmpleLoadControlFiles)(pAmple,
									   "D:/HG/HGAD01.CTL",
									   "D:/HG/HGANCD.TAB",
									   NULL,
									   "D:/HG/HGINTX.CTL");
...
pszResult = (*pfAmpleLoadDictionary)(pAmple,
									 "D:/HG/HGMORPH.DIC");
...
pszResult = (*pfAmpleParseFile)(pAmple,
								"D:/HG/HGMT05.TXT",
								"D:/HG/HGMT05.SGM");
...
(*pfAmpleDeleteSetup)(pAmple);
pAmple = NULL;
...
if (hAmpleLib != 0)
	@{
	FreeLibrary(hAmpleLib);
	hAmpleLib               = 0;
	pfAmpleCreateSetup      = NULL;
	pfAmpleDeleteSetup      = NULL;
	pfAmpleSetParameter     = NULL;
	pfAmpleLoadControlFiles = NULL;
	pfAmpleLoadDictionary   = NULL;
	pfAmpleParseFile        = NULL;
	...
	@}
...
@end smallexample
@subheading Source File
@file{ampledll.c}

@c ----------------------------------------------------------------------------
@page
@node AmpleDeleteSetup, AmpleGetAllAllomorphs, AmpleCreateSetup, Functions
@unnumberedsec AmpleDeleteSetup
@example
DllExport const char * AmpleDeleteSetup(
						AmpleSetup * pSetup_io)
@end example

@subheading Description
@code{AmpleDeleteSetup} erases the given @code{AmpleSetup} data
structure, and frees any associated memory.
@subheading Return Value
a string indicating success or failure
@subheading Example
@ifset txt
See the example for @code{AmpleCreateSetup} above.
@end ifset
@ifclear txt
@xref{AmpleCreateSetup, , Example}.
@end ifclear
@subheading Source File
@file{ampledll.c}

@c ----------------------------------------------------------------------------
@page
@node AmpleGetAllAllomorphs, AmpleGetParameter, AmpleDeleteSetup, Functions
@unnumberedsec AmpleGetAllAllomorphs
@example
DllExport const char * AmpleGetAllAllomorphs(
					   AmpleSetup * pSetup_io,
					   const char * pszRestOfWord_in,
					   const char * pszState_in)
@end example

@subheading Description
@code{AmpleGetAllAllomorphs} gets all the allomorphs which match the
string in @code{pszRestOfWord_in}.  It does this for a given affix state.
The caller is responsible to keep track of the state.  The states are given in the following table.
@table @code
@item BOW
The current state is the beginning of the word.
@item PFX
The current state is a prefix.
@item ROOT
The current state is a root.
@item SFX
The current state is a suffix.
@item EOW
The current state is the end of the word.
@end table

One should invoke @code{AmpleApplyInputChangesToWord} when the state is
@code{BOW}.
@subheading Return Value
a string containing the parse result
@subheading Example
@smallexample
#include <windows.h>
typedef struct ample_setup AmpleSetup;
typedef AmpleSetup * (* AMPLEFUNC0)(void);
typedef const char * (* AMPLEFUNC1)(AmpleSetup *);
typedef const char * (* AMPLEFUNC2)(AmpleSetup *,
									const char *);
typedef const char * (* AMPLEFUNC3)(AmpleSetup *,
									const char *,
									const char *);
...
HANDLE          hAmpleLib;
AMPLEFUNC0      pfAmpleCreateSetup;
AMPLEFUNC1      pfAmpleDeleteSetup;
AMPLEFUNC2      pfAmpleApplyInputChangesToWord;
AMPLEFUNC2      pfAmpleParseText;
AMPLEFUNC3      pfAmpleGetAllAllomorphs;
const char *    pszResult;
AmpleSetup *    pAmple;
char *          pszState;
...
hAmpleLib = LoadLibrary("AMPLE322.DLL");
if ((unsigned long)hAmpleLib < 32)
	{
	MessageBox(0, "Error loading AMPLE322.DLL", "App Name",
			   MB_OK | MB_ICONEXCLAMATION);
	hAmpleLib = 0;
	}
...
if (hAmpleLib != 0)
	{
	pfAmpleCreateSetup = (AMPLEFUNC0)GetProcAddress(hAmpleLib_g,
								"AmpleCreateSetup");
	if (pfAmpleCreateSetup == NULL)
		{
		MessageBox(0,
				   "Cannot find AmpleCreateSetup in AMPLE322.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		}
	pfAmpleDeleteSetup = (AMPLEFUNC1)GetProcAddress(hAmpleLib_g,
								"AmpleDeleteSetup");
	if (pfAmpleDeleteSetup == NULL)
		{
		MessageBox(0,
				   "Cannot find AmpleDeleteSetup in AMPLE322.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		}
	pfAmpleParseText = (AMPLEFUNC2)GetProcAddress(hAmpleLib,
												  "AmpleParseText");
	if (pfAmpleParseText == NULL)
		{
		MessageBox(0, "Cannot find AmpleParseText in AMPLE322.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		}
	pfAmpleApplyInputChangesToWord = (AMPLEFUNC2)GetProcAddress(hAmpleLib,
												  "AmpleApplyInputChangesToWord");
	if (pfAmpleApplyInputChangesToWord == NULL)
		{
		MessageBox(0, "Cannot find AmpleApplyInputChangesToWord in AMPLE322.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		}
	pfAmpleGetAllAllomorphs = (AMPLEFUNC2)GetProcAddress(hAmpleLib,
												  "AmpleGetAllAllomorphs");
	if (pfAmpleGetAllAllomorphs == NULL)
		{
		MessageBox(0, "Cannot find AmpleGetAllAllomorphs in AMPLE322.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		}
	if (    (pfAmpleCreateSetup             == NULL) ||
			(pfAmpleDeleteSetup             == NULL) ||
			(pfAmpleApplyInputChangesToWord == NULL) ||
			(pfAmpleGetAllAllomorphs        == NULL) ||
			(pfAmpleParseText               == NULL) )
		return -1;              /* signal an error */
	}
...
pAmple = (*pfAmpleCreateSetup)();
if (pAmple == NULL)
	return -1;                  /* signal an error */
...
if (streq(pszState, "BOW"))
   pszResult = (*pfAmpleApplyInputChangesToWord)(pAmple, pszWord);
pszResult = (*pfAmpleGetAllAllomorphs)(pAmple, pszResult, pszState);
...
(*pfAmpleDeleteSetup)(pAmple);
pAmple = NULL;
...
if (hAmpleLib != 0)
	{
	FreeLibrary(hAmpleLib);
	hAmpleLib                      = 0;
	pfAmpleCreateSetup             = NULL;
	pfAmpleDeleteSetup             = NULL;
	pfAmpleApplyInputChangesToWord = NULL;
	pfAmpleGetAllAllomorphs        = NULL;
	pfAmpleParseText               = NULL;
	...
	}
...
@end smallexample
@subheading Source File
@file{ampledll.c}

@c ----------------------------------------------------------------------------
@page
@node AmpleGetParameter, AmpleGetTraceString, AmpleGetAllAllomorphs, Functions
@unnumberedsec AmpleGetParameter
@subheading Syntax
@example
DllExport const char * AmpleGetParameter(
						AmpleSetup *  pSetup_io,
						const char * pszName_in)
@end example

@subheading Description
@code{AmpleGetParameter} retrieves the value of an AMPLE322 DLL
parameter (global variable).  The following parameter names are
recognized.

@table @code

@item AppendLogFile
determines whether a new log file is created, or an old log file is
added to.

@item BeginComment
corresponds to the AMPLE program's @samp{-c} command line option.

@item CheckMorphReferences
corresponds to the AMPLE program's @samp{-r} command line option.

@item DebugAllomorphConds
corresponds to the AMPLE program's @samp{-a} command line option.

@item DebugLevel
corresponds to the AMPLE program's @samp{-/} command line option.

@item ErrorMessages
(not yet implemented)

@item LogFile
corresponds to redirecting the standard output from the AMPLE program.
(This retrieves the file name.)

@item MaxMorphnameLength
corresponds to the AMPLE program's @samp{-n} command line option.

@item MaxTrieDepth
corresponds to the AMPLE program's @samp{-d} command line option.

@item OutputDecomposition
corresponds to the AMPLE program's @samp{-w d} and @samp{-x d} command
line options.

@item OutputOriginalWord
corresponds to the AMPLE program's @samp{-w w} and @samp{-x w} command
line options.

@item OutputProperties
corresponds to the AMPLE program's @samp{-w p} and @samp{-x p} command
line options.

@item OutputStyle
determines the style of output produced by @code{AmpleParseFile}.  The
possible values are @code{Ana} (for the normal standard output analysis
file), @code{AResult} (for SGML output similar to that produced by
@code{AmpleParseText}), and @code{Ptext} (for SGML output according to
the @file{ptext.dtd} document type definition).  (@code{Ptext} is not
yet implemented.)
The default style is @code{Ana}.

@item RootGlosses
corresponds to the AMPLE program's @samp{-g} command line option.

@item SelectiveAnalysisFile
corresponds to the AMPLE program's @samp{-s} command line option.
(This retrieves the file name.)

@item ShowPercentages
corresponds to the AMPLE program's @samp{-p} command line option.

@item StoreErrorString
(not yet implemented)

@item TraceAnalysis
corresponds to the AMPLE program's @samp{-t} command line option.

@item VerifyLoading
corresponds to the AMPLE program's @samp{-v} command line option.

@end table
@noindent
Note that the parameter names are not case sensitive, even though they
are shown here in a mixture of uppercase and lowercase.

@subheading Return Value
a string indicating the parameter value, or an error message
@subheading Example
@smallexample
#include <windows.h>
typedef struct ample_setup AmpleSetup;
typedef AmpleSetup * (* AMPLEFUNC0)(void);
typedef const char * (* AMPLEFUNC1)(AmpleSetup *);
typedef const char * (* AMPLEFUNC2)(AmpleSetup *,
									const char *);
...
HANDLE          hAmpleLib;
AMPLEFUNC0      pfAmpleCreateSetup;
AMPLEFUNC1      pfAmpleDeleteSetup;
AMPLEFUNC2      pfAmpleGetParameter;
const char *    pszResult;
AmpleSetup *    pAmple;
...
hAmpleLib = LoadLibrary("AMPLE322.DLL");
if ((unsigned long)hAmpleLib < 32)
	@{
	MessageBox(0, "Error loading AMPLE322.DLL", "App Name",
			   MB_OK | MB_ICONEXCLAMATION);
	hAmpleLib = 0;
	@}
...
if (hAmpleLib != 0)
	@{
	pfAmpleCreateSetup = (AMPLEFUNC0)GetProcAddress(hAmpleLib_g,
								"AmpleCreateSetup");
	if (pfAmpleCreateSetup == NULL)
		@{
		MessageBox(0,
				   "Cannot find AmpleCreateSetup in AMPLE322.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		@}
	pfAmpleDeleteSetup = (AMPLEFUNC1)GetProcAddress(hAmpleLib_g,
								"AmpleDeleteSetup");
	if (pfAmpleDeleteSetup == NULL)
		@{
		MessageBox(0,
				   "Cannot find AmpleDeleteSetup in AMPLE322.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		@}
	pfAmpleGetParameter = (AMPLEFUNC2)GetProcAddress(hAmpleLib,
								"AmpleGetParameter");
	if (pfAmpleGetParameter == NULL)
		@{
		MessageBox(0, "Cannot find AmpleGetParameter in AMPLE322.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		@}
	if (    (pfAmpleCreateSetup  == NULL) ||
			(pfAmpleDeleteSetup  == NULL) ||
			(pfAmpleGetParameter == NULL) )
		return -1;              /* signal an error */
	@}
...
pAmple = (*pfAmpleCreateSetup)();
if (pAmple == NULL)
	return -1;                  /* signal an error */
...
pAmple = (*pfAmpleCreateSetup)();
if (pAmple == NULL)
	return -1;                  /* signal an error */
...
pszResult = (*pfAmpleGetParameter)(pAmple,
								   "MaxTrieDepth");
...
(*pfAmpleDeleteSetup)(pAmple);
pAmple = NULL;
...
(*pfAmpleDeleteSetup)(pAmple);
pAmple = NULL;
...
if (hAmpleLib != 0)
	@{
	FreeLibrary(hAmpleLib);
	hAmpleLib           = 0;
	pfAmpleCreateSetup  = 0;
	pfAmpleDeleteSetup  = 0;
	pfAmpleGetParameter = NULL;
	...
	@}
...
@end smallexample
@subheading Source File
@file{ampledll.c}

@c ----------------------------------------------------------------------------
@page
@node AmpleGetTraceString, AmpleInitializeMorphChecking, AmpleGetParameter, Functions
@unnumberedsec AmpleGetTraceString
@subheading Syntax
@example
DllExport const char * AmpleGetTraceString(
						AmpleSetup *  pSetup_io)
@end example
@subheading Description
@code{AmpleGetTraceString} retrieves the string containing the trace
results from the most recent parse, or an error message if trace results
are going to a file.
@subheading Return Value
a string containing the trace results, or a string indicating failure
@subheading Example
@ifset txt
See the example for @code{AmpleInitializeTraceString} below.
@end ifset
@ifclear txt
@xref{AmpleInitializeTraceString, , Example}.
@end ifclear
@subheading Source File
@file{ampledll.c}

@c ----------------------------------------------------------------------------
@page
@node AmpleInitializeMorphChecking, AmpleInitializeTraceString, AmpleGetTraceString, Functions
@unnumberedsec AmpleInitializeMorphChecking
@subheading Syntax
@example
DllExport const char * AmpleInitializeMorphChecking(
						AmpleSetup *  pSetup_io)
@end example
@subheading Description
@code{AmpleInitializeMorphChecking} initializes the process of checking
that all referenced morphnames in dictionary entries and control
information are defined in the dictionaries.
@code{AmpleInitializeMorphChecking} should be invoked before
@code{AmpleLoadControlFiles} and all calls to
@code{AmpleLoadDictionary}.
Then @code{AmpleCheckMorphReferences} should be invoked.
If no log file has been defined, it does nothing.
If @code{AmpleSetParameter(}@code{ampleSetup,} @code{"CheckMorphReferences",}
@code{"TRUE")} has not been performed, it will perform it.
@subheading Return Value
a string indicating success or failure
@subheading Example
@ifset txt
See the example for @code{AmpleCheckMorphReferences} above.
@end ifset
@ifclear txt
@xref{AmpleCheckMorphReferences, , Example}.
@end ifclear
@subheading Source File
@file{ampledll.c}

@c ----------------------------------------------------------------------------
@page
@node AmpleInitializeTraceString, AmpleLoadControlFiles, AmpleInitializeMorphChecking, Functions
@unnumberedsec AmpleInitializeTraceString
@subheading Syntax
@example
DllExport const char * AmpleInitializeTraceString(
						AmpleSetup *  pSetup_io)
@end example
@subheading Description
@code{AmpleInitializeTraceString} sets tracing to use a string rather
than a file for storing the information.  This is an irreversible
operation.
@subheading Return Value
a string indicating success or failure
@subheading Example
@smallexample
#include <windows.h>
typedef struct ample_setup AmpleSetup;
typedef AmpleSetup * (* AMPLEFUNC0)(void);
typedef const char * (* AMPLEFUNC1)(AmpleSetup *);
...
HANDLE          hAmpleLib;
AMPLEFUNC0      pfAmpleCreateSetup;
AMPLEFUNC1      pfAmpleDeleteSetup;
AMPLEFUNC1      pfAmpleInitializeTraceString;
AMPLEFUNC1      pfAmpleGetTraceString;
const char *    pszResult;
AmpleSetup *    pAmple;
...
hAmpleLib = LoadLibrary("AMPLE322.DLL");
if ((unsigned long)hAmpleLib < 32)
	@{
	MessageBox(0, "Error loading AMPLE322.DLL", "App Name",
			   MB_OK | MB_ICONEXCLAMATION);
	hAmpleLib = 0;
	@}
...
if (hAmpleLib != 0)
	@{
	pfAmpleCreateSetup = (AMPLEFUNC0)GetProcAddress(hAmpleLib_g,
								"AmpleCreateSetup");
	if (pfAmpleCreateSetup == NULL)
		@{
		MessageBox(0,
				   "Cannot find AmpleCreateSetup in AMPLE322.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		@}
	pfAmpleDeleteSetup = (AMPLEFUNC1)GetProcAddress(hAmpleLib_g,
								"AmpleDeleteSetup");
	pfAmpleInitializeTraceString = (AMPLEFUNC1)GetProcAddress(hAmpleLib,
											"AmpleInitializeTraceString");
	if (pfAmpleInitializeTraceString == NULL)
		@{
		MessageBox(0,
				   "Cannot find AmpleInitializeTraceString in AMPLE322.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		@}
	pfAmpleGetTraceString = (AMPLEFUNC0)GetProcAddress(hAmpleLib,
											"AmpleGetTraceString");
	if (pfAmpleGetTraceString == NULL)
		@{
		MessageBox(0,
				   "Cannot find AmpleGetTraceString in AMPLE322.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		@}
	if (    (pfAmpleCreateSetup           == NULL) ||
			(pfAmpleDeleteSetup           == NULL) ||
			(pfAmpleInitializeTraceString == NULL) ||
			(pfAmpleGetTraceString        == NULL) )
		return -1;              /* signal an error */
	@}
...
pAmple = (*pfAmpleCreateSetup)();
if (pAmple == NULL)
	return -1;                  /* signal an error */
...
pszResult = (*pfAmpleInitializeTraceString)(pAmple);
...
pszResult = (*pfAmpleGetTraceString)(pAmple);
...
(*pfAmpleDeleteSetup)(pAmple);
pAmple = NULL;
...
if (hAmpleLib != 0)
	@{
	FreeLibrary(hAmpleLib);
	hAmpleLib                    = 0;
	pfAmpleCreateSetup           = NULL;
	pfAmpleDeleteSetup           = NULL;
	pfAmpleInitializeTraceString = NULL;
	pfAmpleGetTraceString        = NULL;
	...
	@}
...
@end smallexample
@subheading Source File
@file{ampledll.c}

@c ----------------------------------------------------------------------------
@page
@node AmpleLoadControlFiles, AmpleLoadGrammarFile, AmpleInitializeTraceString, Functions
@unnumberedsec AmpleLoadControlFiles
@subheading Syntax
@example
DllExport const char * AmpleLoadControlFiles(
						AmpleSetup *  pSetup_io,
						const char * pszAnalysisDataFile_in,
						const char * pszDictCodeTable_in,
						const char * pszDictOrthoChangeTable_in,
						const char * pszTextInputControlFile_in)
@end example
@subheading Description
@code{AmpleLoadControlFiles} loads the indicated control files into
memory.
@subheading Return Value
a string indicating success or failure
@subheading Example
@ifset txt
See the example for @code{AmpleCreateSetup} above.
@end ifset
@ifclear txt
@xref{AmpleCreateSetup, , Example}.
@end ifclear
@subheading Source File
@file{ampledll.c}

@c ----------------------------------------------------------------------------
@page
@node AmpleLoadDictionary, AmpleLoadGrammarFile, AmpleLoadControlFiles, Functions
@unnumberedsec AmpleLoadDictionary
@subheading Syntax
@example
DllExport const char * AmpleLoadDictionary(
						AmpleSetup *  pSetup_io,
						const char * pszFilePath_in)
@end example
@subheading Description
@code{AmpleLoadDictionary} loads the indicated (unified) AMPLE
dictionary file into memory.
@subheading Return Value
a string indicating success or failure
@subheading Example
@ifset txt
See the example for @code{AmpleCreateSetup} above.
@end ifset
@ifclear txt
@xref{AmpleCreateSetup, , Example}.
@end ifclear
@subheading Source File
@file{ampledll.c}

@c ----------------------------------------------------------------------------
@page
@node AmpleLoadGrammarFile, AmpleParseFile, AmpleLoadDictionary, Functions
@unnumberedsec AmpleLoadGrammarFile
@subheading Syntax
@example
DllExport const char * AmpleLoadGrammarFile(
					   AmpleSetup * pSetup_io,
					   const char * pszGrammarFile_in)
@end example
@subheading Description
@code{AmpleLoadGrammarFile} loads the indicated XAMPLE
PATR grammar file into memory.

NOTE: THIS FUNCTION IS ONLY AVAILABLE FOR THE XAMPLE DLL.
@subheading Return Value
a string indicating success or failure
@subheading Example
@smallexample
#include <windows.h>
typedef struct ample_setup AmpleSetup;
typedef AmpleSetup * (* AMPLEFUNC0)(void);
typedef const char * (* AMPLEFUNC1)(AmpleSetup *);
typedef const char * (* AMPLEFUNC2)(AmpleSetup *,
									const char *);
typedef const char * (* AMPLEFUNC3)(AmpleSetup *,
									const char *,
									const char *);
typedef const char * (* AMPLEFUNC5)(AmpleSetup *,
									const char *,
									const char *,
									const char *,
									const char *);
...
HANDLE          hAmpleLib;
AMPLEFUNC0      pfAmpleCreateSetup;
AMPLEFUNC1      pfAmpleDeleteSetup;
AMPLEFUNC3      pfAmpleSetParameter;
AMPLEFUNC5      pfAmpleLoadControlFiles;
AMPLEFUNC2      pfAmpleLoadDictionary;
AMPLEFUNC2      pfAmpleLoadGrammarFile;
2AMPLEFUNC3      pfAmpleParseFile;
const char *    pszResult;
AmpleSetup *    pAmple;
...
hAmpleLib = LoadLibrary("XAMPLE.DLL");
if ((unsigned long)hAmpleLib < 32)
	@{
	MessageBox(0, "Error loading XAMPLE.DLL", "App Name",
			   MB_OK | MB_ICONEXCLAMATION);
	hAmpleLib = 0;
	@}
...
if (hAmpleLib != 0)
	@{
	pfAmpleCreateSetup = (AMPLEFUNC0)GetProcAddress(hAmpleLib_g,
								"AmpleCreateSetup");
	if (pfAmpleCreateSetup == NULL)
		@{
		MessageBox(0,
				   "Cannot find AmpleCreateSetup in XAMPLE.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		@}
	pfAmpleDeleteSetup = (AMPLEFUNC1)GetProcAddress(hAmpleLib_g,
								"AmpleDeleteSetup");
	if (pfAmpleDeleteSetup == NULL)
		@{
		MessageBox(0,
				   "Cannot find AmpleDeleteSetup in XAMPLE.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		@}
	pfAmpleSetParameter = (AMPLEFUNC3)GetProcAddress(hAmpleLib,
												"AmpleSetParameter");
	if (pfAmpleSetParameter == NULL)
		@{
		MessageBox(0, "Cannot find AmpleSetParameter in XAMPLE.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		@}
	pfAmpleLoadControlFiles = (AMPLEFUNC5)GetProcAddress(hAmpleLib,
											"AmpleLoadControlFiles");
	if (pfAmpleLoadControlFiles == NULL)
		@{
		MessageBox(0,
				   "Cannot find AmpleLoadControlFiles in XAMPLE.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		@}
	pfAmpleLoadDictionary = (AMPLEFUNC2)GetProcAddress(
									hAmpleLib,
									"AmpleLoadDictionary");
	if (pfAmpleLoadDictionary == NULL)
		@{
		MessageBox(0,
				   "Cannot find AmpleLoadDictionary in XAMPLE.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		@}
	pfAmpleLoadGrammarFile = (AMPLEFUNC2)GetProcAddress(
									hAmpleLib,
									"AmpleLoadGrammarFile");
	if (pfAmpleLoadGrammarFile == NULL)
		@{
		MessageBox(0,
				   "Cannot find AmpleLoadGrammarFile in XAMPLE.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		@}
	pfAmpleParseFile = (AMPLEFUNC3)GetProcAddress(hAmpleLib,
												  "AmpleParseFile");
	if (pfAmpleParseFile == NULL)
		@{
		MessageBox(0, "Cannot find AmpleParseFile in XAMPLE.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		@}
	if (    (pfAmpleCreateSetup      == NULL) ||
			(pfAmpleDeleteSetup      == NULL) ||
			(pfAmpleSetParameter     == NULL) ||
			(pfAmpleLoadControlFiles == NULL) ||
			(pfAmpleLoadDictionary   == NULL) ||
			(pfAmpleLoadGrammarFile  == NULL) ||
			(pfAmpleParseFile        == NULL) )
		return -1;              /* signal an error */
	@}
...
pAmple = (*pfAmpleCreateSetup)();
if (pAmple == NULL)
	return -1;                  /* signal an error */
pszResult = (*pfAmpleSetParameter)(pAmple,
								   "LogFile",
								   "D:/HG/HGMT05.LOG");
...
pszResult = (*pfAmpleLoadControlFiles)(pAmple,
									   "D:/HG/HGAD01.CTL",
									   "D:/HG/HGANCD.TAB",
									   NULL,
									   "D:/HG/HGINTX.CTL");
...
pszResult = (*pfAmpleLoadGrammarFile)(pAmple,
									 "D:/HG/HGPATR.GRM");
...
pszResult = (*pfAmpleLoadDictionary)(pAmple,
									 "D:/HG/HGMORPH.DIC");
...
pszResult = (*pfAmpleParseFile)(pAmple,
								"D:/HG/HGMT05.TXT",
								"D:/HG/HGMT05.SGM");
...
(*pfAmpleDeleteSetup)(pAmple);
pAmple = NULL;
...
if (hAmpleLib != 0)
	@{
	FreeLibrary(hAmpleLib);
	hAmpleLib               = 0;
	pfAmpleCreateSetup      = NULL;
	pfAmpleDeleteSetup      = NULL;
	pfAmpleSetParameter     = NULL;
	pfAmpleLoadControlFiles = NULL;
	pfAmpleLoadDictionary   = NULL;
	pfAmpleLoadGrammarFile  = NULL;
	pfAmpleParseFile        = NULL;
	...
	@}
...
@end smallexample

@subheading Source File
@file{ampledll.c}

@c ----------------------------------------------------------------------------
@page
@node AmpleParseFile, AmpleParseText, AmpleLoadGrammarFile, Functions
@unnumberedsec AmpleParseFile
@subheading Syntax
@example
DllExport const char * AmpleParseFile(
						AmpleSetup *  pSetup_io,
						const char * pszInFilePath_in,
						const char * pszOutFilePath_in)
@end example
@subheading Description
@code{AmpleParseFile} parses an input text file, producing an output
analysis file.
@subheading Return Value
a string indicating success or failure
@subheading Example
@ifset txt
See the example for @code{AmpleCreateSetup} above.
@end ifset
@ifclear txt
@xref{AmpleCreateSetup, , Example}.
@end ifclear
@subheading Source File
@file{ampledll.c}

@c ----------------------------------------------------------------------------
@page
@node AmpleParseText, AmpleRemoveSelectiveAnalysisMorphs, AmpleParseFile, Functions
@unnumberedsec AmpleParseText
@subheading Syntax
@example
DllExport const char * AmpleParseText(
						AmpleSetup *  pSetup_io,
						const char * pszInputText_in)
@end example
@subheading Description
@code{AmpleParseText} parses the words in the input string.  If the
string contains only one word, then that word is parsed, obviating the
need for a separate @code{AmpleParseWord} function.

The parse output follows the simple SGML style format given by the
following @dfn{document type definition}.  (The parse output is not
quite SGML because it does not begin with a DOCTYPE declaration and it
does not quote attribute values even when needed.)
@example

<!ELEMENT AResult - - ((error | parse)*) >

<!ELEMENT error - - (#PCDATA) >
<!ATTLIST error code (analysisFailure | rootFailure) #REQUIRED >

<!ELEMENT parse - - (analysis*) >
<!ATTLIST parse id CDATA #REQUIRED >

<!ELEMENT analysis - - (morph*) >
<!ATTLIST analysis cat CDATA #REQUIRED >

<!ELEMENT morph - O EMPTY >
<!ATTLIST morph id   CDATA #REQUIRED
				allo CDATA #REQUIRED >

@end example
For the XAMPLE DLL, the parse output includes the parses
from PC-PATR.  The change to the above is in the @code{<analysis>}
element:

@example
<!ELEMENT analysis - - (morph*, analysis?) >
<!ATTLIST analysis cat CDATA #REQUIRED >
@end example

We currently have a problem in that the @code{<analysis>} member
element is actually defined differently.  It is a PC-PATR
@code{<analysis>} element.  See the @code{set tree} section
of the PC-PATR documentation.

@subheading Return Value
a string containing either the parse output or an error message
@subheading Example
@smallexample
#include <windows.h>
typedef struct ample_setup AmpleSetup;
typedef AmpleSetup * (* AMPLEFUNC0)(void);
typedef const char * (* AMPLEFUNC1)(AmpleSetup *);
typedef const char * (* AMPLEFUNC2)(AmpleSetup *,
									const char *);
...
HANDLE          hAmpleLib;
AMPLEFUNC0      pfAmpleCreateSetup;
AMPLEFUNC1      pfAmpleDeleteSetup;
AMPLEFUNC2      pfAmpleParseText;
const char *    pszResult;
AmpleSetup *    pAmple;
...
hAmpleLib = LoadLibrary("AMPLE322.DLL");
if ((unsigned long)hAmpleLib < 32)
	@{
	MessageBox(0, "Error loading AMPLE322.DLL", "App Name",
			   MB_OK | MB_ICONEXCLAMATION);
	hAmpleLib = 0;
	@}
...
if (hAmpleLib != 0)
	@{
	pfAmpleCreateSetup = (AMPLEFUNC0)GetProcAddress(hAmpleLib_g,
								"AmpleCreateSetup");
	if (pfAmpleCreateSetup == NULL)
		@{
		MessageBox(0,
				   "Cannot find AmpleCreateSetup in AMPLE322.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		@}
	pfAmpleDeleteSetup = (AMPLEFUNC1)GetProcAddress(hAmpleLib_g,
								"AmpleDeleteSetup");
	if (pfAmpleDeleteSetup == NULL)
		@{
		MessageBox(0,
				   "Cannot find AmpleDeleteSetup in AMPLE322.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		@}
	pfAmpleParseText = (AMPLEFUNC2)GetProcAddress(hAmpleLib,
												  "AmpleParseText");
	if (pfAmpleParseText == NULL)
		@{
		MessageBox(0, "Cannot find AmpleParseText in AMPLE322.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		@}
	if (    (pfAmpleCreateSetup == NULL) ||
			(pfAmpleDeleteSetup == NULL) ||
			(pfAmpleParseText   == NULL) )
		return -1;              /* signal an error */
	@}
...
pAmple = (*pfAmpleCreateSetup)();
if (pAmple == NULL)
	return -1;                  /* signal an error */
...
pszResult = (*pfAmpleParseText)(pAmple,
		"Chayta rikar loomaman wicharkur hamakuykuran yachachinanpaq.");
...
(*pfAmpleDeleteSetup)(pAmple);
pAmple = NULL;
...
if (hAmpleLib != 0)
	@{
	FreeLibrary(hAmpleLib);
	hAmpleLib          = 0;
	pfAmpleCreateSetup = NULL;
	pfAmpleDeleteSetup = NULL;
	pfAmpleParseText   = NULL;
	...
	@}
...
@end smallexample
@subheading Source File
@file{ampledll.c}

@c ----------------------------------------------------------------------------
@page
@node AmpleRemoveSelectiveAnalysisMorphs, AmpleReportVersion, AmpleParseText, Functions
@unnumberedsec AmpleRemoveSelectiveAnalysisMorphs
@subheading Syntax
@example
DllExport const char * AmpleRemoveSelectiveAnalysisMorphs(
						AmpleSetup *  pSetup_io)
@end example
@subheading Description
@code{AmpleRemoveSelectiveAnalysisMorphs} erases any existing list of
morphnames for selective analysis.  It also erases any filename stored
for the @code{SelectiveAnalysisFile} parameter.
@subheading Return Value
a string indicating success or failure
@subheading Example
@smallexample
#include <windows.h>
typedef struct ample_setup AmpleSetup;
typedef AmpleSetup * (* AMPLEFUNC0)(void);
typedef const char * (* AMPLEFUNC1)(AmpleSetup *);
...
HANDLE          hAmpleLib;
AMPLEFUNC0      pfAmpleCreateSetup;
AMPLEFUNC1      pfAmpleDeleteSetup;
AMPLEFUNC1      pfAmpleRemoveSelectiveAnalysisMorphs;
const char *    pszResult;
AmpleSetup *    pAmple;
...
hAmpleLib = LoadLibrary("AMPLE322.DLL");
if ((unsigned long)hAmpleLib < 32)
	@{
	MessageBox(0, "Error loading AMPLE322.DLL", "App Name",
			   MB_OK | MB_ICONEXCLAMATION);
	hAmpleLib = 0;
	@}
...
if (hAmpleLib != 0)
	@{
	pfAmpleCreateSetup = (AMPLEFUNC0)GetProcAddress(hAmpleLib_g,
								"AmpleCreateSetup");
	if (pfAmpleCreateSetup == NULL)
		@{
		MessageBox(0,
				   "Cannot find AmpleCreateSetup in AMPLE322.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		@}
	pfAmpleDeleteSetup = (AMPLEFUNC1)GetProcAddress(hAmpleLib_g,
								"AmpleDeleteSetup");
	if (pfAmpleDeleteSetup == NULL)
		@{
		MessageBox(0,
				   "Cannot find AmpleDeleteSetup in AMPLE322.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		@}
	pfAmpleRemoveSelectiveAnalysisMorphs =
				(AMPLEFUNC1)GetProcAddress(hAmpleLib,
							  "AmpleRemoveSelectiveAnalysisMorphs");
	if (pfAmpleRemoveSelectiveAnalysisMorphs == NULL)
		@{
		MessageBox(0,
	"Cannot find AmpleRemoveSelectiveAnalysisMorphs in AMPLE322.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		@}
	if (    (pfAmpleCreateSetup                   == NULL) ||
			(pfAmpleDeleteSetup                   == NULL) ||
			(pfAmpleRemoveSelectiveAnalysisMorphs == NULL) )
		return -1;              /* signal an error */
	@}
...
pAmple = (*pfAmpleCreateSetup)();
if (pAmple == NULL)
	return -1;                  /* signal an error */
...
pszResult = (*pfAmpleRemoveSelectiveAnalysisMorphs)(pAmple);
...
(*pfAmpleDeleteSetup)(pAmple);
pAmple = NULL;
...
if (hAmpleLib != 0)
	@{
	FreeLibrary(hAmpleLib);
	hAmpleLib                            = 0;
	pfAmpleCreateSetup                   = NULL;
	pfAmpleDeleteSetup                   = NULL;
	pfAmpleRemoveSelectiveAnalysisMorphs = NULL;
	...
	@}
...
@end smallexample
@subheading Source File
@file{ampledll.c}

@c ----------------------------------------------------------------------------
@page
@node AmpleReportVersion, AmpleReset, AmpleRemoveSelectiveAnalysisMorphs, Functions
@unnumberedsec AmpleReportVersion
@subheading Syntax
@example
DllExport const char * AmpleReportVersion(
						AmpleSetup *  pSetup_io)
@end example
@subheading Description
@code{AmpleReportVersion} prints the version information (of amplelib)
to the log file.  If no log file has been defined, it does nothing.
@subheading Return Value
a string indicating success or failure
@subheading Example
@smallexample
#include <windows.h>
typedef struct ample_setup AmpleSetup;
typedef AmpleSetup * (* AMPLEFUNC0)(void);
typedef const char * (* AMPLEFUNC1)(AmpleSetup *);
...
HANDLE          hAmpleLib;
AMPLEFUNC0      pfAmpleCreateSetup;
AMPLEFUNC1      pfAmpleDeleteSetup;
AMPLEFUNC3      pfAmpleSetParameter;
AMPLEFUNC1      pfAmpleReportVersion;
const char *    pszResult;
AmpleSetup *    pAmple;
...
hAmpleLib = LoadLibrary("AMPLE322.DLL");
if ((unsigned long)hAmpleLib < 32)
	@{
	MessageBox(0, "Error loading AMPLE322.DLL", "App Name",
			   MB_OK | MB_ICONEXCLAMATION);
	hAmpleLib = 0;
	@}
...
if (hAmpleLib != 0)
	@{
	pfAmpleCreateSetup = (AMPLEFUNC0)GetProcAddress(hAmpleLib_g,
								"AmpleCreateSetup");
	if (pfAmpleCreateSetup == NULL)
		@{
		MessageBox(0,
				   "Cannot find AmpleCreateSetup in AMPLE322.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		@}
	pfAmpleDeleteSetup = (AMPLEFUNC1)GetProcAddress(hAmpleLib_g,
								"AmpleDeleteSetup");
	if (pfAmpleDeleteSetup == NULL)
		@{
		MessageBox(0,
				   "Cannot find AmpleDeleteSetup in AMPLE322.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		@}
	pfAmpleSetParameter = (AMPLEFUNC3)GetProcAddress(hAmpleLib,
												"AmpleSetParameter");
	if (pfAmpleSetParameter == NULL)
		@{
		MessageBox(0, "Cannot find AmpleSetParameter in AMPLE322.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		@}
	pfAmpleReportVersion = (AMPLEFUNC1)GetProcAddress(hAmpleLib,
											  "AmpleReportVersion");
	if (pfAmpleReportVersion == NULL)
		@{
		MessageBox(0, "Cannot find AmpleReportVersion in AMPLE322.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		@}
	if (    (pfAmpleCreateSetup   == NULL) ||
			(pfAmpleDeleteSetup   == NULL) ||
			(pfAmpleSetParameter  == NULL) ||
			(pfAmpleReportVersion == NULL) )
		return -1;              /* signal an error */
	@}
...
pAmple = (*pfAmpleCreateSetup)();
if (pAmple == NULL)
	return -1;                  /* signal an error */
...
pszResult = (*pfAmpleSetParameter)(pAmple,
								   "LogFile",
								   "D:/HG/HGMT05.LOG");
...
pszResult = (*pfAmpleReportVersion)(pAmple);
...
(*pfAmpleDeleteSetup)(pAmple);
pAmple = NULL;
...
if (hAmpleLib != 0)
	@{
	FreeLibrary(hAmpleLib);
	hAmpleLib            = 0;
	pfAmpleCreateSetup   = NULL;
	pfAmpleDeleteSetup   = NULL;
	pfAmpleSetParameter  = NULL;
	pfAmpleReportVersion = NULL;
	...
	@}
...
@end smallexample
@subheading Source File
@file{ampledll.c}

@c ----------------------------------------------------------------------------
@page
@node AmpleReset, AmpleSetParameter, AmpleReportVersion, Functions
@unnumberedsec AmpleReset
@subheading Syntax
@example
DllExport const char * AmpleReset(
						AmpleSetup *  pSetup_io)
@end example
@subheading Description
@code{AmpleReset} removes all control and dictionary information from
memory, and restores all internal settings to their default values.
@subheading Return Value
a string indicating success or failure
@subheading Example
@smallexample
#include <windows.h>
typedef struct ample_setup AmpleSetup;
typedef AmpleSetup * (* AMPLEFUNC0)(void);
typedef const char * (* AMPLEFUNC1)(AmpleSetup *);
...
HANDLE          hAmpleLib;
AMPLEFUNC0      pfAmpleCreateSetup;
AMPLEFUNC1      pfAmpleDeleteSetup;
AMPLEFUNC1      pfAmpleReset;
const char *    pszResult;
AmpleSetup *    pAmple;
...
hAmpleLib = LoadLibrary("AMPLE322.DLL");
if ((unsigned long)hAmpleLib < 32)
	@{
	MessageBox(0, "Error loading AMPLE322.DLL", "App Name",
			   MB_OK | MB_ICONEXCLAMATION);
	hAmpleLib = 0;
	@}
...
if (hAmpleLib != 0)
	@{
	pfAmpleCreateSetup = (AMPLEFUNC0)GetProcAddress(hAmpleLib_g,
								"AmpleCreateSetup");
	if (pfAmpleCreateSetup == NULL)
		@{
		MessageBox(0,
				   "Cannot find AmpleCreateSetup in AMPLE322.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		@}
	pfAmpleDeleteSetup = (AMPLEFUNC1)GetProcAddress(hAmpleLib_g,
								"AmpleDeleteSetup");
	if (pfAmpleDeleteSetup == NULL)
		@{
		MessageBox(0,
				   "Cannot find AmpleDeleteSetup in AMPLE322.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		@}
	pfAmpleReset = (AMPLEFUNC1)GetProcAddress(hAmpleLib,
											  "AmpleReset");
	if (pfAmpleReset == NULL)
		@{
		MessageBox(0, "Cannot find AmpleReset in AMPLE322.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		@}
	if (    (pfAmpleCreateSetup == NULL) ||
			(pfAmpleDeleteSetup == NULL) ||
			(pfAmpleReset       == NULL) )
		return -1;              /* signal an error */
	@}
...
pAmple = (*pfAmpleCreateSetup)();
if (pAmple == NULL)
	return -1;                  /* signal an error */
...
pszResult = (*pfAmpleReset)(pAmple);
...
(*pfAmpleDeleteSetup)(pAmple);
pAmple = NULL;
...
if (hAmpleLib != 0)
	@{
	FreeLibrary(hAmpleLib);
	hAmpleLib          = 0;
	pfAmpleCreateSetup = NULL;
	pfAmpleDeleteSetup = NULL;
	pfAmpleReset       = NULL;
	...
	@}
...
@end smallexample
@subheading Source File
@file{ampledll.c}

@c ----------------------------------------------------------------------------
@page
@node AmpleSetParameter, AmpleUpdateEntry, AmpleReset, Functions
@unnumberedsec AmpleSetParameter
@subheading Syntax
@example
DllExport const char * AmpleSetParameter(
						AmpleSetup *  pSetup_io,
						const char * pszName_in,
						const char * pszValue_in)
@end example
@subheading Description
@code{AmpleSetParameter} sets the value of an AMPLE322 DLL
parameter (global variable).  The following parameter names are
recognized.  If @code{pszValue_in} is @code{NULL}, the parameter is set
to its default value.

@table @code

@item AppendLogFile
determines whether a new log file is created, or an old log file is
added to.  Possible values are @code{"TRUE"} (or @code{"T"}) and
@code{"FALSE"} (or @code{"F"}).  The default value is @code{"FALSE"}.

@item BeginComment
corresponds to the AMPLE program's @samp{-c} command line option.
The first nonspace character in the value string is used for the new
comment character.  The default value is @code{"|"}.  If the value
string does not contain any nonspace characters, then nothing can mark
comments in the input files.

@item CheckMorphReferences
corresponds to the AMPLE program's @samp{-r} command line option.
Possible values are @code{"TRUE"} (or @code{"T"}) and @code{"FALSE"}
(or @code{"F"}).  The default value is @code{"FALSE"}.
@ifset txt
See the example for @code{AmpleCheckMorphReferences} above.
@end ifset
@ifclear txt
@xref{AmpleCheckMorphReferences, , }.
@end ifclear

@item DebugAllomorphConds
corresponds to the AMPLE program's @samp{-a} command line option.
Possible values are @code{"TRUE"} (or @code{"T"}) and @code{"FALSE"}
(or @code{"F"}).  The default value is @code{"FALSE"}.

@item DebugLevel
corresponds to the AMPLE program's @samp{-/} command line option.
Possible values are positive integers (encoded as ASCII digit strings).
The default value is @code{"0"}.

@item ErrorMessages
(not yet implemented)

@item LogFile
corresponds to redirecting the standard output from the AMPLE program.
The value string is the name of the output log file.  The default is
not to have a log file.

@item MaxMorphnameLength
corresponds to the AMPLE program's @samp{-n} command line option.
Possible values are positive integers greater than zero (encoded as
ASCII digit strings).  The default value is @code{"15"}.

@item MaxTrieDepth
corresponds to the AMPLE program's @samp{-d} command line option.
Possible values are positive integers greater than zero (encoded as
ASCII digit strings).  The default value is @code{"2"}.

@item OutputDecomposition
corresponds to the AMPLE program's @samp{-w d} (if set to true) and
@samp{-x d} (if set to false) command line options.
Possible values are @code{"TRUE"} (or @code{"T"}) and @code{"FALSE"}
(or @code{"F"}).  The default value is @code{"FALSE"}.

@item OutputOriginalWord
corresponds to the AMPLE program's @samp{-w w} (if set to true) and
@samp{-x w} (if set to false) command line options.
Possible values are @code{"TRUE"} (or @code{"T"}) and @code{"FALSE"}
(or @code{"F"}).  The default value is @code{"FALSE"}.

@item OutputProperties
corresponds to the AMPLE program's @samp{-w p} (if set to true) and
@samp{-x p} (if set to false) command line options.
Possible values are @code{"TRUE"} (or @code{"T"}) and @code{"FALSE"}
(or @code{"F"}).  The default value is @code{"FALSE"}.

@item OutputStyle
determines the style of output produced by @code{AmpleParseFile}.  The
possible values are @code{"Ana"} (for the normal standard output
analysis file), @code{"AResult"} (for SGML output similar to that
produced by @code{AmpleParseText}), and @code{"Ptext"} for SGML output
according to the @file{ptext.dtd} document type definition).
The default value is @code{"Ana"}.

@item RootGlosses
corresponds to the AMPLE program's @samp{-g} command line option.
Possible values are @code{"TRUE"} (or @code{"T"}) and @code{"FALSE"}
(or @code{"F"}).  The default value is @code{"FALSE"}.

@item SelectiveAnalysisFile
corresponds to the AMPLE program's @samp{-s} command line option.
The value string is the name of a file containing the morphnames (or
allomorphs) that are used for subsequent analyses.  The default is not
to use selective analysis, but to use every allomorph of every morpheme
loaded from the dictionary file(s).

@item ShowPercentages
corresponds to the AMPLE program's @samp{-p} command line option.
Possible values are @code{"TRUE"} (or @code{"T"}) and @code{"FALSE"}
(or @code{"F"}).  The default value is @code{"FALSE"}.

@item StoreErrorString
(not yet implemented)

@item TraceAnalysis
corresponds to the AMPLE program's @samp{-t} command line option.
Possible values are @code{"OFF"}, @code{"ON"} (for normal AMPLE
tracing), and @code{"SGML"} (for @code{<AmpleTrace>} tracing).  The
default value is @code{"OFF"}.  Note that the trace output is written
to the log file, and may be mixed with other log output.

@item VerifyLoading
corresponds to the AMPLE program's @samp{-v} command line option.
Possible values are @code{"TRUE"} (or @code{"T"}) and @code{"FALSE"}
(or @code{"F"}).  The default value is @code{"FALSE"}.
@ifset txt
See the example for @code{AmpleVerifyLoading} below.
@end ifset
@ifclear txt
@xref{AmpleVerifyLoading, , }.
@end ifclear

@end table
@noindent
Note that the parameter names are not case sensitive, even though they
are shown here in a mixture of uppercase and lowercase.

@subheading Return Value
a string indicating success or failure
@subheading Example
@ifset txt
See the example for @code{AmpleCreateSetup} above.
@end ifset
@ifclear txt
@xref{AmpleCreateSetup, , Example}.
@end ifclear
@subheading Source File
@file{ampledll.c}

@c ----------------------------------------------------------------------------
@page
@node AmpleUpdateEntry, AmpleVerifyLoading, AmpleSetParameter, Functions
@unnumberedsec AmpleUpdateEntry
@subheading Syntax
@example
DllExport const char * AmpleUpdateEntry(
						AmpleSetup *  pSetup_io,
						const char * pszNewEntry_in)
@end example
@subheading Description
@code{AmpleUpdateEntry} updates an entry in the dictionary.
The input string looks like an entry from the standard format
dictionary file.  The default values for the standard format markers
are the lowercase characters for the internal codes described in the
AMPLE reference manual.
@ifclear txt
@xref{Dictionary files, , Dictionary Files, ample.info, AMPLE Reference Manual}.
@end ifclear
@subheading Return Value
a string indicating success or failure
@subheading Example
@smallexample
#include <windows.h>
typedef struct ample_setup AmpleSetup;
typedef AmpleSetup * (* AMPLEFUNC0)(void);
typedef const char * (* AMPLEFUNC1)(AmpleSetup *);
typedef const char * (* AMPLEFUNC2)(AmpleSetup *,
									const char *);
...
HANDLE          hAmpleLib;
AMPLEFUNC0      pfAmpleCreateSetup;
AMPLEFUNC1      pfAmpleDeleteSetup;
AMPLEFUNC2      pfAmpleUpdateEntry;
const char *    pszResult;
AmpleSetup *    pAmple;
...
char            szNewEntry[] = "\
\\m mateo\n\
\\t root\n\
\\c N0\n\
\\a mateo @{Matthew_1@}\n\
\\a mateu @{Matthew_2@}\n\
\\a matei @{Matthew_3@}\n\
";
hAmpleLib = LoadLibrary("AMPLE322.DLL");
if ((unsigned long)hAmpleLib < 32)
	@{
	MessageBox(0, "Error loading AMPLE322.DLL", "App Name",
			   MB_OK | MB_ICONEXCLAMATION);
	hAmpleLib = 0;
	@}
...
if (hAmpleLib != 0)
	@{
	pfAmpleCreateSetup = (AMPLEFUNC0)GetProcAddress(hAmpleLib_g,
								"AmpleCreateSetup");
	if (pfAmpleCreateSetup == NULL)
		@{
		MessageBox(0,
				   "Cannot find AmpleCreateSetup in AMPLE322.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		@}
	pfAmpleDeleteSetup = (AMPLEFUNC1)GetProcAddress(hAmpleLib_g,
								"AmpleDeleteSetup");
	if (pfAmpleDeleteSetup == NULL)
		@{
		MessageBox(0,
				   "Cannot find AmpleDeleteSetup in AMPLE322.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		@}
	pfAmpleUpdateEntry = (AMPLEFUNC2)GetProcAddress(hAmpleLib,
												"AmpleUpdateEntry");
	if (pfAmpleUpdateEntry == NULL)
		@{
		MessageBox(0, "Cannot find AmpleUpdateEntry in AMPLE322.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		@}
	if (    (pfAmpleCreateSetup == NULL) ||
			(pfAmpleDeleteSetup == NULL) ||
			(pfAmpleUpdateEntry == NULL) )
		return -1;              /* signal an error */
	@}
...
pAmple = (*pfAmpleCreateSetup)();
if (pAmple == NULL)
	return -1;                  /* signal an error */
...
pszResult = (*pfAmpleUpdateEntry)(pAmple,
								  szNewEntry);
...
(*pfAmpleDeleteSetup)(pAmple);
pAmple = NULL;
...
if (hAmpleLib != 0)
	@{
	FreeLibrary(hAmpleLib);
	hAmpleLib          = 0;
	pfAmpleCreateSetup = NULL;
	pfAmpleDeleteSetup = NULL;
	pfAmpleUpdateEntry = NULL;
	...
	@}
...
@end smallexample
@subheading Source File
@file{ampledll.c}

@c ----------------------------------------------------------------------------
@page
@node AmpleVerifyLoading, AmpleWriteDictionary, AmpleUpdateEntry, Functions
@unnumberedsec AmpleVerifyLoading
@subheading Syntax
@example
DllExport const char * AmpleVerifyLoading(
						AmpleSetup *  pSetup_io)
@end example
@subheading Description
@code{AmpleVerifyLoading} prints some verifying output to the
log file (this corresponds to the AMPLE program's @samp{-v} command line
option).
If no log file has been defined, it does nothing.
@code{AmpleVerifyLoading} should be invoked after
@code{AmpleLoadControlFiles} and all calls to
@code{AmpleLoadDictionary}.
If @code{AmpleSetParameter(}@code{ampleSetup,} @code{"VerifyLoading",}
@code{"TRUE")} has not been performed, it will perform it.
@subheading Return Value
a string indicating success or failure
@subheading Example
@smallexample
#include <windows.h>
typedef struct ample_setup AmpleSetup;
typedef AmpleSetup * (* AMPLEFUNC0)(void);
typedef const char * (* AMPLEFUNC1)(AmpleSetup *);
...
HANDLE          hAmpleLib;
AMPLEFUNC0      pfAmpleCreateSetup;
AMPLEFUNC1      pfAmpleDeleteSetup;
AMPLEFUNC3      pfAmpleSetParameter;
AMPLEFUNC5      pfAmpleLoadControlFiles;
AMPLEFUNC2      pfAmpleLoadDictionary;
AMPLEFUNC1      pfAmpleVerifyLoading;
const char *    pszResult;
AmpleSetup *    pAmple;
...
hAmpleLib = LoadLibrary("AMPLE322.DLL");
if ((unsigned long)hAmpleLib < 32)
	@{
	MessageBox(0, "Error loading AMPLE322.DLL", "App Name",
			   MB_OK | MB_ICONEXCLAMATION);
	hAmpleLib = 0;
	@}
...
if (hAmpleLib != 0)
	@{
	pfAmpleCreateSetup = (AMPLEFUNC0)GetProcAddress(hAmpleLib_g,
								"AmpleCreateSetup");
	if (pfAmpleCreateSetup == NULL)
		@{
		MessageBox(0,
				   "Cannot find AmpleCreateSetup in AMPLE322.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		@}
	pfAmpleDeleteSetup = (AMPLEFUNC1)GetProcAddress(hAmpleLib_g,
								"AmpleDeleteSetup");
	if (pfAmpleDeleteSetup == NULL)
		@{
		MessageBox(0,
				   "Cannot find AmpleDeleteSetup in AMPLE322.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		@}
	pfAmpleSetParameter = (AMPLEFUNC3)GetProcAddress(hAmpleLib,
												"AmpleSetParameter");
	if (pfAmpleSetParameter == NULL)
		@{
		MessageBox(0, "Cannot find AmpleSetParameter in AMPLE322.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		@}
	pfAmpleLoadControlFiles = (AMPLEFUNC5)GetProcAddress(hAmpleLib,
											"AmpleLoadControlFiles");
	if (pfAmpleLoadControlFiles == NULL)
		@{
		MessageBox(0,
				   "Cannot find AmpleLoadControlFiles in AMPLE322.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		@}
	pfAmpleLoadDictionary = (AMPLEFUNC2)GetProcAddress(
									hAmpleLib,
									"AmpleLoadDictionary");
	if (pfAmpleLoadDictionary == NULL)
		@{
		MessageBox(0,
				   "Cannot find AmpleLoadDictionary in AMPLE322.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		@}
	pfAmpleVerifyLoading = (AMPLEFUNC1)GetProcAddress(hAmpleLib,
											  "AmpleVerifyLoading");
	if (pfAmpleVerifyLoading == NULL)
		@{
		MessageBox(0, "Cannot find AmpleVerifyLoading in AMPLE322.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		@}
	if (    (pfAmpleCreateSetup      == NULL) ||
			(pfAmpleDeleteSetup      == NULL) ||
			(pfAmpleSetParameter     == NULL) ||
			(pfAmpleLoadControlFiles == NULL) ||
			(pfAmpleLoadDictionary   == NULL) ||
			(pfAmpleVerifyLoading    == NULL) )
		return -1;              /* signal an error */
	@}
...
pAmple = (*pfAmpleCreateSetup)();
if (pAmple == NULL)
	return -1;                  /* signal an error */
...
pszResult = (*pfAmpleSetParameter)(pAmple,
								   "LogFile",
								   "D:/HG/HGMT05.LOG");
...
pszResult = (*pfAmpleLoadControlFiles)(pAmple,
									   "D:/HG/HGAD01.CTL",
									   "D:/HG/HGANCD.TAB",
									   NULL,
									   "D:/HG/HGINTX.CTL");
...
pszResult = (*pfAmpleLoadDictionary)(pAmple,
									 "D:/HG/HGMORPH.DIC");
...
pszResult = (*pfAmpleVerifyLoading)(pAmple);
...
(*pfAmpleDeleteSetup)(pAmple);
pAmple = NULL;
...
if (hAmpleLib != 0)
	@{
	FreeLibrary(hAmpleLib);
	hAmpleLib               = 0;
	pfAmpleCreateSetup      = NULL;
	pfAmpleDeleteSetup      = NULL;
	pfAmpleSetParameter     = NULL;
	pfAmpleLoadControlFiles = NULL;
	pfAmpleLoadDictionary   = NULL;
	pfAmpleVerifyLoading    = NULL;
	...
	@}
...
@end smallexample
@subheading Source File
@file{ampledll.c}

@c ----------------------------------------------------------------------------
@page
@node AmpleWriteDictionary, , AmpleVerifyLoading, Functions
@unnumberedsec AmpleWriteDictionary
@subheading Syntax
@example
DllExport const char * AmpleWriteDictionary(
						AmpleSetup *  pSetup_io,
						const char * pszOutputDictionary_in)
@end example
@subheading Description
@code{AmpleWriteDictionary} writes the dictionary to a standard format
file.  The standard format markers are based on the lowercase letters
of the internal codes described in the AMPLE reference manual.
@ifclear txt
@ifset html
See section <A HREF="ample.html">Dictionary files</A> in @cite{AMPLE Reference
Manual}.
@end ifset
@ifclear html
@xref{Dictionary files, , Dictionary Files, ample.info, AMPLE Reference Manual}.
@end ifclear
@end ifclear
@subheading Return Value
a string indicating success or failure
@subheading Example
@smallexample
#include <windows.h>
typedef struct ample_setup AmpleSetup;
typedef AmpleSetup * (* AMPLEFUNC0)(void);
typedef const char * (* AMPLEFUNC1)(AmpleSetup *);
typedef const char * (* AMPLEFUNC2)(AmpleSetup *,
									const char *);
...
HANDLE          hAmpleLib;
AMPLEFUNC0      pfAmpleCreateSetup;
AMPLEFUNC1      pfAmpleDeleteSetup;
AMPLEFUNC2      pfAmpleWriteDictionary;
const char *    pszResult;
AmpleSetup *    pAmple;
...
char            szOutputDictionary[] = "updated.dic";
hAmpleLib = LoadLibrary("AMPLE322.DLL");
if ((unsigned long)hAmpleLib < 32)
	@{
	MessageBox(0, "Error loading AMPLE322.DLL", "App Name",
			   MB_OK | MB_ICONEXCLAMATION);
	hAmpleLib = 0;
	@}
...
if (hAmpleLib != 0)
	@{
	pfAmpleCreateSetup = (AMPLEFUNC0)GetProcAddress(hAmpleLib_g,
								"AmpleCreateSetup");
	if (pfAmpleCreateSetup == NULL)
		@{
		MessageBox(0,
				   "Cannot find AmpleCreateSetup in AMPLE322.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		@}
	pfAmpleDeleteSetup = (AMPLEFUNC1)GetProcAddress(hAmpleLib_g,
								"AmpleDeleteSetup");
	if (pfAmpleDeleteSetup == NULL)
		@{
		MessageBox(0,
				   "Cannot find AmpleDeleteSetup in AMPLE322.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		@}
	pfAmpleWriteDictionary = (AMPLEFUNC2)GetProcAddress(hAmpleLib,
												"AmpleWriteDictionary");
	if (pfAmpleWriteDictionary == NULL)
		@{
		MessageBox(0, "Cannot find AmpleWriteDictionary in AMPLE322.DLL",
				   "App Name", MB_OK | MB_ICONEXCLAMATION);
		@}
	if (    (pfAmpleCreateSetup     == NULL) ||
			(pfAmpleDeleteSetup     == NULL) ||
			(pfAmpleWriteDictionary == NULL) )
		return -1;              /* signal an error */
	@}
...
pAmple = (*pfAmpleCreateSetup)();
if (pAmple == NULL)
	return -1;                  /* signal an error */
...
pszResult = (*pfAmpleWriteDictionary)(pAmple,
									  szOutputDictionary);
...
(*pfAmpleDeleteSetup)(pAmple);
pAmple = NULL;
...
if (hAmpleLib != 0)
	@{
	FreeLibrary(hAmpleLib);
	hAmpleLib              = 0;
	pfAmpleCreateSetup     = NULL;
	pfAmpleDeleteSetup     = NULL;
	pfAmpleWriteDictionary = NULL;
	...
	@}
...
@end smallexample
@subheading Source File
@file{ampledll.c}

@c ----------------------------------------------------------------------------
@node Error messages, , Functions, Top
@chapter Error Message Strings

The following error message strings may be returned by the AMPLE322 DLL
functions.  Most of these messages should be self explanatory.

@table @code

@item <error code=badAnalysisDataFile>Error reading the analysis data file</error>

@item <error code=badDictCodeTableFile>Error reading the dictionary code table file</error>

@item <error code=badDictEntry>Error updating the dictionary</error>

@item <error code=badDictOrthoChangesFile>Error reading the dictionary orthography changes table file</error>

@item <error code=badDictionaryFile>Error reading the dictionary file</error>

@item <error code=badTextInputControlFile>Error reading the text input control file</error>

@item <error code=fatalCrash>AMPLE322 DLL has crashed badly!</error>
This indicates an extremely serious problem that would cause the AMPLE
program to exit prematurely.  Running out of memory would be a possible
cause of this message.

@item <error code=invalidInputFilename>Cannot open file for input</error>

@item <error code=invalidOutputFilename>Cannot open file for output</error>

@item <error code=invalidParameterName>Parameter name not recognized</error>
This indicates an invalid argument to @code{AmpleGetParameter} or
@code{AmpleSetParameter}.

@item <error code=invalidParameterValue>Bad parameter value string</error>
This indicates an invalid argument to @code{AmpleSetParameter}.

@item <error code=missingArgument>Required argument is empty</error>

@item <error code=noTraceString>No trace string exists</error>
This indicates that @code{AmpleGetTraceString} has been called before
calling @code{AmpleInitializeTraceString}.

@item <error code=fatalCrash>AMPLE DLL has crashed badly!</error>
An internal error occurred which could not be diagnosed further.  There
may be more information in the log file, but don't count on it!

@item <error code=invalidSetupArgument>Invalid AmpleSetup parameter</error>
The @code{AmpleSetup} pointer passed to the function did not come from a
call to @code{AmpleCreateSetup}, or has been invalidated by a call to
@code{ampleDeleteSetup}.

@item <error code=none>Success</error>
This is not really an @emph{error} message, but rather an indication
that the function worked flawlessly.

@end table

@c ----------------------------------------------------------------------------
@contents
@bye
