\input pcparse % common TeX setup  @c -*-texinfo-*-
\input texinfo
@c %**start of header
@setfilename ktext.info
@settitle KText Reference Manual
@c %**end of header

@set ktext

@set TITLE KText Reference Manual
@set SUBTITLE analyzing/synthesizing texts with PC-Kimmo functions
@set VERSION version 2.0b17
@set DATE October 1997
@set AUTHOR by Evan Antworth and Stephen McConnel
@set COPYRIGHT Copyright @copyright{} 2000 SIL International

@include front.txi

@c ----------------------------------------------------------------------------
@node    Top,       Overview,  (dir),    (dir)
@comment node-name, next,      previous, up

@ifinfo
@ifclear txt
This is the reference manual for the KText program.
@end ifclear
@end ifinfo

@menu
* Overview::
* Examples::
* Running KTEXT::
* Functional structure::
* Input text file::
* KTEXT control file::
* Text input control file::
* Text output control file::
* Analysis files::
* KTEXT synthesis output::
* Bibliography::
@end menu

@c ----------------------------------------------------------------------------
@node Overview,  Examples, Top,      Top
@c    node-name, next,     previous, up
@chapter Overview of KTEXT

@menu
* What KTEXT does::
* KTEXT in context::
* Technical specifications::
* Program status::
@end menu

This section briefly describes what KTEXT does, places KTEXT in its
computational context, lists technical specifications of the program,
and gives information on use and support of the program.
@ifinfo
@c @paragraph{}
@end ifinfo

@c ----------------------------------------------------------------------------
@node What KTEXT does, KTEXT in context, Overview, Overview
@section What does KTEXT do?

KTEXT is a text processing program that uses the PC-KIMMO parser (see
below about PC-KIMMO).  KTEXT operates in two modes: analysis and
synthesis.  In analysis mode, KTEXT reads a text from a disk file,
parses each word, and writes the results to a new disk file.  This new
file is in the form of a structured text file where each word of the
original text is represented as a database record composed of several
fields.  Each word record contains a field for the original word, a
field for the underlying or lexical form of the word, and a field for
the gloss string.  For example, if the text in the input file contains
the word @samp{beginning} (to use an English example), KTEXT's output
file will have a record of this format:

@example
@group
\a be`gin +ING
\d be`gin-+ING
\cat V
\fd ing
\w beginning
@end group
@end example

@noindent
This record consists of five fields, each tagged with a backslash
code.@footnote{The particular choice of field markers and the order of
fields in a record is due to the fact that KTEXT uses the same
text-handling routines as an existing program called AMPLE (Weber et al.,
1988).  This has the advantage that KTEXT's output is compatible with
that program, but the disadvantage that the record structure is perhaps
not consistent with terminology already established for PC-KIMMO.  It
should also be noted that the quasi-database design of KTEXT's output is
used by many other programs developed by SIL International.}  The first
field, tagged with @t{\a} for @i{analysis}, contains the gloss string for
the word.  The second field, tagged with @t{\d} for (morpheme)
@i{decomposition}, contains the underlying or lexical form of the word.
The third field, tagged with @t{\cat} for @i{category}, contains the
grammatical category of the word.  The fourth field, tagged with @t{\fd}
for @i{feature descriptions}, contains a list of feature abbreviations
associated with the word, and the fourth field, tagged with @t{\w} for
@i{word}, contains the original word.  The word @samp{pictures} (which
can be analyzed as either a verb or a noun) demonstrates how KTEXT
handles multiple parses:

@example
@group
\a %2%`picture +3SG%`picture +PL%
\d %2%`picture-+s%`picture-+s%
\cat %2%V%N%
\fd %d%s%-3sg pl%
\w pictures
@end group
@end example

@noindent
Percent signs (or some other designated character) separate the
multiple results in the @t{\a}, @t{\d}, @t{\cat}, and @t{\fd} fields,
with a number indicating how many results were found.

A word record also saves any capitalization or punctuation associated
with the original word.  For example, if a sentence begins ``Obviously,
this hypothesis@dots{}'', KTEXT will output the first word like this:

@example
@group
\a `obvious +AVR1
\d `obvious-+ly
\cat AV
\w obviously
\c 1
\n ,
@end group
@end example

@noindent
The @t{\w} field contains the original word without capitalization or the
following comma.  The @t{\c} field contains the number 1 which indicates
that the first letter of the original word is upper case.  The @t{\n} field
contains the comma that follows the original word.  The purpose of
retaining the capitalization and punctuation of the original text is,
of course, to enable one to recover the original text from KTEXT's
output file.

In synthesis mode, KTEXT takes an analysis file compatible with that
produced by KTEXT in analysis mode and produces an orthographic text
file comparable to the original.

@c ----------------------------------------------------------------------------
@node KTEXT in context, Technical specifications, What KTEXT does, Overview
@section Placing KTEXT in its context

KTEXT can only be understood by describing two other programs: PC-KIMMO
and CARLA.  First, we will take a look at PC-KIMMO.

KTEXT is intended to be used with PC-KIMMO (though it is a stand-alone
program).  PC-KIMMO is a program for doing computational phonology and
morphology.  It is typically used to build morphological parsers for
natural language processing systems.  PC-KIMMO is described in the book
@cite{PC-KIMMO: a two-level processor for morphological analysis} by Evan
L. Antworth, published by the Summer Institute of Linguistics (1990).
The PC-KIMMO software is available for MS-DOS and Windows (IBM PCs and
compatibles), Macintosh, and UNIX.  The book (including software) is
available for $23.00 (plus postage) from:

@display
@group
	International Academic Bookstore
	7500 W. Camp Wisdom Road
	Dallas TX, 75236
	U.S.A.

	phone: 972/708-7404
	fax:@t{   }972/708-7433
@end group
@end display

@noindent
The KTEXT program which this document describes will be of very little
use to you without the PC-KIMMO program and book.  The remainder of
this document assumes that you are familiar with PC-KIMMO.

PC-KIMMO was deliberately designed to be reuseable.  The core of
PC-KIMMO is a library of functions such as @dfn{load rules}, @dfn{load
lexicon}, @dfn{generate}, and @dfn{recognize}.  The PC-KIMMO program
supplied on the release diskette is just a user shell built around
these basic functions.  This shell provides an environment for
developing and testing sets of rules and lexicons.  Since the shell is
a development environment, it has very little built-in data processing
capability.  But because PC-KIMMO is modular and portable, you can
write your own data processing program that uses PC-KIMMO's function
library.  KTEXT is an example of how to use PC-KIMMO to create a new
natural language processing program.  KTEXT is a text processing
program that uses PC-KIMMO to do morphological parsing.

KTEXT is also closely related to a system called CARLA, which stands
for Computer Assisted Related Language Adaptation.  CARLA is a type of
machine translation system designed to work between closely related
languages.  CARLA is based on the Analysis Transfer Synthesis (ATS)
paradigm of adaptation.  This paradigm involves three stages:

@enumerate
@item
@strong{Analysis.}  The text to be adapted is converted to an abstract
representation, composed of units (in our case, words and morphemes)
which are defined in source language dictionaries.  (No attempt is made
to represent the meaning of the text, only the units that comprise the
text.)

@item
@strong{Transfer.}  Given known, systematic differences between the
source and target languages, the result of Analysis is converted to an
abstract representation of what it should be for the target language,
using units defined in target language dictionaries.

@item
@strong{Synthesis.} Given information about the target language, the
abstract representation resulting from Transfer is converted to a
concrete, textual form.
@end enumerate

When used in analysis mode, KTEXT performs the Analysis task.  In the
original CARLA system, analysis is done by a program called AMPLE
(Weber et al.@: 1988), which is also a morphological parser designed to
process text.  KTEXT was created by replacing AMPLE's parsing engine
with the PC-KIMMO parser.  Thus KTEXT has the same text-handling
mechanisms as AMPLE and produces output similar or even identical to
AMPLE.  The advantages of this design are (1) we were able to develop
KTEXT very quickly and easily since it involved very little new code,
and (2) existing programs that use AMPLE's output format can also use
KTEXT's output.  The disadvantage of basing KTEXT on AMPLE is that the
format of the output file is perhaps not consistent with terminology
already established for PC-KIMMO.

When KTEXT is used in synthesis mode, it performs the Synthesis task.
In the original CARLA system, synthesis is done by a program called
STAMP (Weber et al.@: 1990).  However, STAMP also performs the Transfer
task; KTEXT does not have this capability.

@need 1000
@c ----------------------------------------------------------------------------
@node Technical specifications, Program status, KTEXT in context, Overview
@section Technical specifications

KTEXT runs under four operating systems:

@itemize @bullet
@item
MS-DOS (IBM PC compatibles with a 386 or higher processor)
@item
Microsoft Windows
@item
UNIX
@item
Apple Macintosh
@end itemize

@noindent
KTEXT does not require any graphics capability.  It handles eight-bit
characters (such as the IBM PC extended character set or the Windows ANSI
character set).  The Windows and Macintosh versions have the same user
interface as the MS-DOS and UNIX versions, namely a batch-processing,
command-line interface.  In other words, a GUI version does not exist.

The MS-DOS executable requires a 386 or newer CPU and a DPMI server.  This
has the advantage of allowing the program to use as much memory as
necessary without constraining it to the archaic 640K limit.  (DPMI is
provided automatically by Windows.  A free DPMI server is distributed with
the MS-DOS executable.)

The program is written in C and is very portable.  The Macintosh
version was compiled with the Metrowerks C compiler.
The sources available at URL
@ifset html
<A HREF="ftp://ftp.sil.org/software/test/">ftp://ftp.sil.org/software/test/</A>
@end ifset
@ifclear html
@t{ftp://ftp.sil.org/software/unix/ktext-*.zip}
@end ifclear
can be compiled for any of the four target platforms.

@c ----------------------------------------------------------------------------
@node Program status, , Technical specifications, Overview
@section Program status

KTEXT was developed by Stephen McConnel and Evan Antworth of SIL
International.  Several qualifications apply to its use and support:

@enumerate
@item
This software, source code and executable program, is copyrighted by SIL
International.  You may use this software at no cost.  You are granted
the right to distribute this software to others, provided that all files
are included in unmodified form and that you charge no fee (except cost
of media).  This software is intended for academic or other personal use
only, and may not be distributed or used for commercial profit without
express permission of SIL International.

@item
This software represents work in progress and bears no warranty, either
expressed or implied, of its fitness for any particular purpose.

@item
In releasing this software, SIL International is making no commitment to
maintain it.  It is, however, committed to forwarding user feedback to
the software's authors who may or may not choose to develop the software
further.
@end enumerate

Bug reports, wish lists, requests for support, and positive feedback
should be directed to Evan Antworth at this address:

@display
@group
	Stephen McConnel
	Language Software Development
	SIL International
	7500 W. Camp Wisdom Road
	Dallas, TX  75236
@iftex
	phone: 972/708-7361
	email:  Stephen_McConnel@@sil.org
@end iftex
@ifinfo
	phone: 972/708-7361
	email: Stephen_McConnel@@sil.org
@end ifinfo
@end group
@end display

@c ----------------------------------------------------------------------------
@node Examples, Running KTEXT, Overview, Top
@chapter Examples of using KTEXT

@menu
* KTEXT analysis::
* KTEXT synthesis::
@end menu

@c ----------------------------------------------------------------------------
@node KTEXT analysis, KTEXT synthesis, Examples, Examples
@section Using KTEXT to analyze a text

Typically, the steps involved in using KTEXT to analyze texts are:
@enumerate
@item
Collect a corpus of language data suitable for phonological and
morphological analysis (typically paradigms of words).

@item
Do phonological and morphological analysis on the data.

@item
Use the PC-KIMMO shell to develop a rules file, lexicon, and grammar
file that encode your phonological and morphological analyses and to
test them against your corpus of data.

@item
Select a text and keyboard it.

@item
Set up the additional control files required for KTEXT analysis.

@item
Use the rules, lexicon, and grammar you developed to process the text with
KTEXT in analysis mode.

@item
Edit KTEXT's output file to remove multiple parses.

@item
Use the edited file as input to some other program.
@end enumerate

@set alice-excerpt 1
To demonstrate how to use KTEXT to process a text in analysis, we will
use Englex, a morphological grammar of English for PC-KIMMO, and
analyze a paragraph of @cite{Alice's Adventures in Wonderland}, by
Lewis Caroll.  The first paragraph of the text is shown in
figure @value{alice-excerpt}.

@smallexample
@group
@b{Figure @value{alice-excerpt}. Excerpt from Alice}

\id Alice.txt - Lewis Carroll's Alice's Adventures in Wonderland

\ti Down the Rabbit-Hole
\p
Alice was beginning to get very tired of sitting by her sister
on the bank and of having nothing to do: once or twice she had
peeped into the book her sister was reading, but it had no pictures
or conversations in it, "and what is the use of a book," thought Alice,
"without pictures or conversations?"
\p
So she was considering, in her own mind (as well as she could, for
the hot day made her feel very sleepy and stupid), whether the pleasure
of making a daisy-chain would be worth the trouble of getting up and
picking the daisies, when suddenly a White Rabbit with pink eyes ran
close by her.
@end group
@end smallexample
@noindent
The text was keyboarded using a very simple system of document markup
that tags parts of the document with backslash codes.  The @code{\it}
tag identifies the text; the @code{\ti} tag indicates the title of the
story; and the @code{\p} tag indicates the beginning of a paragraph.
The next step is to process the text with KTEXT in analysis mode.  Run
the KTEXT application with these command line options:

@smallexample
ktext -x ana.ctl -i alice.txt -o alice.ana -l ana.log
@end smallexample
@noindent
where @file{ana.ctl} is the analysis control file, @file{alice.txt} is
the input text file, @file{alice.ana} is the output analysis file, and
@file{alice.log} is the analysis log file.  The following display will
appear on the screen:

@smallexample
KTEXT (analyze/synthesize words using PC-Kimmo functions)
Version 2.0b11 (November 1, 1996), Copyright 1996 SIL
Beta test version compiled Nov  7 1996 15:11:16
with PC-Kimmo functions version 2.1b7 (November 6, 1996)
  and PC-PATR functions version 0.99b0 (November 7, 1996)
For 386 CPU (or better) under MS-DOS [compiled with DJGPP 2.1/GNU C 2.7]

  affix.lex                          255 entries
  noun.lex                         10461 entries
  verb.lex                          4215 entries
  adjectiv.lex                      3345 entries
  adverb.lex                         400 entries
  minor.lex                          379 entries
  proper.lex                        1057 entries
  abbrev.lex                         127 entries
  technica.lex                       813 entries
  natural.lex                        435 entries
  foreign.lex                         88 entries

5...2.2..2  ..22.2.2..  2.222.2.22  ..22.2.222  22..22.22.
2..23.22..  2.2.22.225  2..2...22.  ......2...  4.22.2..4.  100
...2..2..2  2.222
@end smallexample
@set alice-ana 2
@noindent
Each dot represents one word successfully processed.  Multiple analyses
of a word are indicated by numbers; thus the first word down received
five analyses.  When the program is done, it will return you to the
operating system prompt.  A fragment of the resulting output file is
shown in figure @value{alice-ana}.

@smallexample
@group
@b{Figure @value{alice-ana}  Output of KTEXT}

\a	%5%`down%`down%`down%`down%`down%
\d	%5%`down%`down%`down%`down%`down%
\cat	%5%AV%V%AJ%N%PP%
\fd	%5%%vbase%%sg%%
\w	down
\c	1

\a	the
\d	the
\cat	DT
\w	the

\a	`rabbit - `hole
\d	`rabbit---`hole
\cat	N
\fd	sg
\w	rabbit-hole
\c	516
\n	\n
@end group
@end smallexample

@set alice-it 3
One obvious way to continue is to reassemble the text in interlinear
format.  That is, we could write a program that would take the data
structures shown in figure @value{alice-ana} and create a new file
where the text is stored in interlinear format.  The resulting
interlinear text is shown in figure @value{alice-it}.  An interlinear
text editor like IT@footnote{IT (pronounced ``eye-tee'') is an
interlinear text editor that maintains the vertical alignment of the
interlinear lines of text and uses a lexicon to semi-automatically
gloss the text.  See Simons and Versaw (1991) and
Simons and Thomson (1988).} could then be used to add more lines of
annotations to the text.

@smallexample
@group
@b{Figure @value{alice-it}  An English example of interlinear text format}

Down	the	Rabbit	-	Hole
`down	the	`rabbit	-	`hole
PP	DT	N	-	N
@end group
@end smallexample
@noindent
Interlinear translation is a time-honored format for presenting
analyzed vernacular texts.  An interlinear text consists of a baseline
text and one or more lines of annotations that are vertically aligned
with the baseline.  In the text shown in figure @value{alice-it}, the first line is
the baseline text.  The second line provides the lexical form of each
original word, including morpheme breaks.  The third line gives the
category or part-of-speech of each word.

@set itf-output 4
Another way to proceed would be to take the output of KTEXT as shown in
figure @value{alice-ana} and format it directly for printing.  In other
words, there would be no disk file of interlinear text corresponding to
figure @value{alice-it};
rather, the interlinear text is created on the fly as it is prepared
for printing.  Fortunately, the software required to print interlinear
text is now available.  As a complement to the IT program, a system for
formatting interlinear text for typesetting has recently been developed
(see Kew and McConnel, 1991).  Called ITF, for Interlinear Text
Formatter,@footnote{ITF was developed by the Academic Computing
Department of the Summer Institute of Linguistics. It runs under
MS-DOS, UNIX, and the Apple Macintosh.}  it is a set of
@TeX{}@footnote{@TeX{} is a typesetting language developed by Donald
Knuth (see Knuth, 1986).} macros that can format an arbitrary number of
aligning annotations with up to two freeform (nonaligning) annotations.
While ITF is primarily intended to format the data files produced by IT
(similar to the interlinear text shown in figure @value{alice-it}), an
auxiliary
program provided with ITF accepts the output of the KTEXT program.  The
final printed result of the formatting process is shown in
figure @value{itf-output}.@footnote{The plain text version of this
documentation does not include figure @value{itf-output}, since it is
an image of typeset output.}  It should be noted that this is just one
of many formats that ITF can produce.  Because ITF is built on a
full-featured typesetting system, virtually all aspects of the
formatting detail can be customized, including half a dozen different
schemes for laying out the freeform annotations relative to the
interlinear text.

@page
@b{Figure @value{itf-output}. Output of ITF}

@iftex
@ifset html
<img align=middle src="eng.gif" alt=" [ ITF output (eng.gif) ] " border=0>
@end ifset
@ifclear html
@vfill
{
@catcode`@\=0
\catcode`\{=1
\catcode`\}=2
\catcode`\$=3
\catcode`\&=4
\catcode12=5
\catcode`\#=6
\catcode`\^=7
\catcode`\_=8
\catcode32=10
\catcode`\<=12
\catcode`\>=12
\catcode`\@=12
\catcode`\%=14
\include eng.tex
}
@vfill
@end ifclear
@page
@end iftex
@ifinfo
@ifset txt
[ This figure is not available in plain text documentation. ]
@end ifset
@ifclear txt
[ This figure is not available in INFO documentation. ]
@end ifclear
@end ifinfo

@c ----------------------------------------------------------------------------
@node KTEXT synthesis, , KTEXT analysis, Examples
@section Using KTEXT to synthesize a text

Normally, in an adaptation project, the text is adapted from a source
language to a target language via a Transfer component.  For the purpose
of this example, we will use English as both the source and target
language, thus obviating the need for a Transfer component.  If the
synthesis operation produces a text which is identical to the original
text, then we have proved the efficacy of the system.

Typically, the steps involved in using KTEXT in synthesis mode are:
@enumerate
@item
Collect a corpus of language data suitable for phonological and
morphological analysis (typically paradigms of words).

@item
Do phonological and morphological analysis on the data.

@item
Use the PC-KIMMO shell to develop a rules file and a lexicon file that
encode your phonological and morphological analyses and to test them
against your corpus of data.

@item
Set up the control files required by KTEXT for synthesis mode.  Using
the rules and lexicon you developed, use KTEXT in synthesis mode to
process an analyzed text.
@end enumerate

To synthesize the original text from the analysis file, run the KTEXT
application with these command line options:

@smallexample
ktext -s -x syn.ctl -i alice.ana -o alice.syn -l syn.log
@end smallexample
where @file{syn.ctl} is the synthesis control file, @file{alice.ana} is
the input analysis file, @file{alice.syn} is the synthesized output
text file, and @file{syn.log} is the synthesis log file.  The following
display will appear on the screen:

@smallexample
KTEXT (analyze/synthesize words using PC-Kimmo functions)
Version 2.0b11 (November 1, 1996), Copyright 1996 SIL
Beta test version compiled Nov  7 1996 15:11:16
with PC-Kimmo functions version 2.1b7 (November 6, 1996)
  and PC-PATR functions version 0.99b0 (November 7, 1996)
For 386 CPU (or better) under MS-DOS [compiled with DJGPP 2.1/GNU C 2.7]

  affix.lex                          255 entries
  noun.lex                         10461 entries
  verb.lex                          4215 entries
  adjectiv.lex                      3345 entries
  adverb.lex                         400 entries
  minor.lex                          379 entries
  proper.lex                        1057 entries
  abbrev.lex                         127 entries
  technica.lex                       813 entries
  natural.lex                        435 entries
  foreign.lex                         88 entries
.......... .......... .......... .......... ..........
.......... .......... .......... .......... ..........  100
.......... .....
@end smallexample
@noindent
Notice that every word received a single synthesis.  Open the output
file @file{alice.syn} and you will see that it is identical to the
input text file shown in figure @value{alice-excerpt}.

@c ----------------------------------------------------------------------------
@node Running KTEXT, Functional structure, Examples, Top
@chapter Running KTEXT

This section describes KTEXT's user interface and the input files it
uses.

KTEXT is a batch-processing program.  This means that the program takes
as input a text from a disk file and returns as output the processed
text in a new disk file.  KTEXT is run from the command line by giving
it the information it needs (file names and other options).  It does
not have an interactive interface.  The user controls KTEXT's operation
by means of special files that contain all the information KTEXT needs
to process the input text.  These files are called control files.

The operation of the program is controlled by using command line
options.  To see a list of the command line options, run the KTEXT
application with @code{-h} as a command line option.  You will see a
display similar to this:

@smallexample
@group
KTEXT (analyze/synthesize words using PC-Kimmo functions)
Version 2.0b11 (November 1, 1996), Copyright 1996 SIL
Beta test version compiled Nov  7 1996 15:11:16
with PC-Kimmo functions version 2.1b7 (November 6, 1996)
  and PC-PATR functions version 0.99b0 (November 7, 1996)
For 386 CPU (or better) under MS-DOS [compiled with DJGPP 2.1/GNU C 2.7]

Usage:  ktext [options]
	-c char      make char the comment character for the control files
				 (default is ;)
	-s           synthesis mode (default is analysis)
	-v           for synthesis, verify each result with a word parse
	-x ctlfile   specify the KTEXT control file (default is ktext.ctl)
	-i infile    specify the input file (required: no default)
	-o outfile   specify the output file (default is based on infile)
	-l logfile   specify the KTEXT log file (default is none)
@end group
@end smallexample

The command line options (@samp{-c}, @samp{-s}, and so on) are all
lower case letters.  Here is a detailed description of each command
line option.

@table @kbd
@item -c
The @samp{-c} option takes an argument that sets the comment character
used in the KTEXT control files (analysis, synthesis, TEXTIN, and
TXTOUT control files).  It has no effect on any other files used by
KTEXT.  If the @samp{-c} option is not used, the semicolon (@t{;}) is
used as the default comment character.

@item -s
The @samp{-s} option causes KTEXT to run in synthesis mode. Without this
option, KTEXT by default will run in analysis mode.

@item -v
The @samp{-v} option applies only to synthesis mode; it causes KTEXT to
verify the synthesis by using the word grammar (if one is specified in
the analysis control file).  The default is not to use the word grammar
(even if one is specified).

@item -x
The @samp{-x} option takes an argument that specifies the name
of either the analysis or synthesis control file.  These control files
contains the name of the TEXTIN or TXTOUT control files and the names
of the rules, lexicon, and word grammar files.  They can also specify
consistent changes to be made to the output.  The @samp{-x} option
accepts a default file name extension of @file{.ctl}; for example if
you use @code{-x english} KTEXT will try to load the file
@file{english.ctl}.  If the @samp{-x} option is not used, KTEXT will
try to load a control file with the default file name @file{ktext.ctl}.

@item -i
The @samp{-i} option takes an argument that specifies the name of the
input file containing the text that KTEXT will process.  If the
@samp{-i} option is not used, KTEXT displays an error message and
quits.

@item -o
The @samp{-o} option takes an argument that specifies the name of the
output file that KTEXT creates.  If the @samp{-o} option is not used,
the output filename is constructed from the input filename.

@item -l
The @samp{-l} option takes an argument that specifies the name of a log
file.  The log file contains messages about any analysis failures or
other anomalous behavior during processing of the input text.
@end table

@noindent
In all instances where file names are supplied to KTEXT, an optional
directory path can be included; for example, @code{-i c:\texts\alice.txt}.

@c ----------------------------------------------------------------------------
@node Functional structure, Input text file, Running KTEXT, Top
@chapter KTEXT's functional structure

@menu
* Analysis mode::
* Synthesis mode::
@end menu

@c ----------------------------------------------------------------------------
@node Analysis mode, Synthesis mode, Functional structure, Functional structure
@section Analysis mode

@set ktext-overview 5
KTEXT uses three main functional modules in analysis mode: the
@dfn{text input} module, the @dfn{analysis} module, and the
@dfn{structured output} module.  The diagram in
figure @value{ktext-overview} shows the flow
of data through these modules.  The input text is fed into the text
input module which outputs the text as a stream of normalized words
with capitalization and punctuation stripped out and saved.  The text
input module is controlled by a file that specifies orthographic
changes.  Each word is then passed to the analysis module where it is
parsed.  The analysis module is controlled by the PC-KIMMO rules,
lexicon, and grammar files.  The parsed words are then passed to the
structured output module and written to the output file as database
records.

@tex
\beginpicture
\setcoordinatesystem units <1in,1in>
\setplotarea x from -1 to 4, y from 0 to 5.4
\unitlength=1in
\thinlines
\put {Figure @value{ktext-overview}. An overview of KTEXT analysis} at 2.0 5.1
\put {\smaller original input text file} [b] at 2.0 4.8
\put {\vector(0,-1){0.25}} [Bl] at 2.0 4.75
\put {\vector(0,-1){0.25}} [Bl] at 2.0 4.5
\putrectangle corners at 1.0 1.0 and 3.25 4.5
\putrectangle corners at 1.45 3.75 and 2.55 4.25
\put {\smaller\lines {TEXT\cr INPUT}} at 2.0 4.0
\put {\vector(0,-1){0.25}} [Bl] at 2.0 3.75
\put {\smaller words} at 2.0 3.375
\put {\vector(0,-1){0.25}} [Bl] at 2.0 3.25
\putrectangle corners at 1.45 2.5 and 2.55 3.0
\put {\smaller ANALYSIS} at 2.0 2.75
\put {\vector(0,-1){0.25}} [Bl] at 2.0 2.50
\put {\smaller parsed words} at 2.0 2.125
\put {\vector(0,-1){0.25}} [Bl] at 2.0 2.00
\putrectangle corners at 1.45 1.25 and 2.55 1.75
\put {\smaller\lines {STRUCTURED\cr OUTPUT}} at 2.0 1.5
\put {\vector(0,-1){0.25}} [Bl] at 2.0 1.25
\put {\vector(0,-1){0.25}} [Bl] at 2.0 1.00
\put {\smaller\lines {text input\cr control file}} [l] at 0.0 4.0
\put {\vector(1,0){0.35}} [Bl] at 0.65 4.0
\put {\vector(1,0){0.45}} [Bl] at 1.00 4.0
\put {\smaller rules file} [l] at 0.0 2.95
\put {\vector(1,0){0.43}} [Bl] at 0.57 2.95
\put {\vector(1,0){0.45}} [Bl] at 1.00 2.95
\put {\smaller lexicon files} [l] at 0.0 2.75
\put {\vector(1,0){0.25}} [Bl] at 0.75 2.75
\put {\vector(1,0){0.45}} [Bl] at 1.00 2.75
\put {\smaller grammar file} [l] at 0.0 2.55
\put {\vector(1,0){0.18}} [Bl] at 0.82 2.55
\put {\vector(1,0){0.45}} [Bl] at 1.00 2.55
\put {\vector(1,0){0.20}} [Bl] at 2.55 4.00
\put {\vector(0,-1){0.35}} [Bl] at 2.75 4.00
\put {\smaller\lines {punctuation\cr formatting\cr capitalization}} at 2.75 3.36
\put {\vector(0,-1){1.6}} [Bl] at 2.75 3.10
\put {\vector(-1,0){0.20}} [Bl] at 2.75 1.50
\put {\smaller structured text file with parsed words} [b] at 2.0 0.55
\endpicture
@end tex
@ifinfo
@example
@group
@b{Figure @value{ktext-overview}. An overview of KTEXT analysis}

				original input text file
							 |
							 |
				 +--------------------------------+
				 |           |                    |
				 |    +------------+              |
text input       |    |    TEXT    |              |
control file --->|--->|    INPUT   |-----+        |
				 |    +------------+     |        |
				 |           |      punctuation   |
				 |         words     formatting   |
				 |           |     capitalization |
				 |           |           |        |
rules file ----->|--->+------------+     |        |
lexicon files -->|--->|  ANALYSIS  |     |        |
grammar file --->|--->+------------+     |        |
				 |           |           |        |
				 |     parsed words      |        |
				 |           |           |        |
				 |    +------------+     |        |
				 |    | STRUCTURED |<----+        |
				 |    |   OUTPUT   |              |
				 |    +------------+              |
				 |           |                    |
				 +--------------------------------+
							 |
							 |
			 structured text file with parsed words
@end group
@end example
@end ifinfo

In analysis mode, KTEXT uses six different input files and produces one
output file (plus an optional log file).  These six input file are:

@enumerate
@item
the text data file,
@item
the KTEXT control file,
@item
the text input control file (optional),
@item
the PC-KIMMO rules file,
@item
the PC-KIMMO lexicon file, and
@item
the PC-KIMMO grammar file (optional).
@end enumerate

@noindent
The PC-KIMMO rules, lexicon, and grammar files are described in the
PC-KIMMO documentation and will not be discussed further in this
document; see Antworth (1990) and Antworth (1995).  The other input
files and the analysis output data file are described in the following
chapters.

@c ----------------------------------------------------------------------------
@node Synthesis mode, , Analysis mode, Functional structure
@section Synthesis mode

@set ktext-synth 6
KTEXT also uses three main functional modules in synthesis mode: the
@dfn{structured input} module, the @dfn{synthesis} module, and the
@dfn{text output} module.  The diagram in
figure @value{ktext-synth} shows the flow of
data through these modules.  A structured input text containing parsed
words is fed into the structured input module, which outputs the text
as a stream of parsed words with capitalization and punctuation
stripped out and saved.  Each parsed word is then passed to the
synthesis module where it is rebuilt from its pieces.  The synthesis
module is controlled by the PC-KIMMO rules and lexicon files.
(Synthesis normally does not use the grammar file.)  The synthesized
words are then passed to the text output module and written to the
output file as a synthesized text with the punctuation and
capitalization merged back in.  The text output module is controlled by
a file that specifies orthographic changes.

@tex
\beginpicture
\setcoordinatesystem units <1in,1in>
\setplotarea x from -1 to 4, y from 0 to 5.4
\unitlength=1in
\thinlines
\put {Figure @value{ktext-synth}. An overview of KTEXT synthesis} at 2.0 5.1
\put {\smaller structured text file with parsed words} [b] at 2.0 4.8
\put {\vector(0,-1){0.25}} [Bl] at 2.0 4.75
\put {\vector(0,-1){0.25}} [Bl] at 2.0 4.5
\putrectangle corners at 1.0 1.0 and 3.25 4.5
\putrectangle corners at 1.45 3.75 and 2.55 4.25
\put {\smaller\lines {STRUCTURED\cr INPUT}} at 2.0 4.0
\put {\vector(0,-1){0.20}} [Bl] at 2.0 3.75
\put {\smaller\lines {parsed\cr words}} at 2.0 3.375
\put {\vector(0,-1){0.20}} [Bl] at 2.0 3.20
\putrectangle corners at 1.45 2.5 and 2.55 3.0
\put {\smaller SYNTHESIS} at 2.0 2.75
\put {\vector(0,-1){0.25}} [Bl] at 2.0 2.50
\put {\smaller synthesized words} at 2.0 2.125
\put {\vector(0,-1){0.25}} [Bl] at 2.0 2.00
\putrectangle corners at 1.45 1.25 and 2.55 1.75
\put {\smaller\lines {TEXT\cr OUTPUT}} at 2.0 1.5
\put {\vector(0,-1){0.25}} [Bl] at 2.0 1.25
\put {\vector(0,-1){0.25}} [Bl] at 2.0 1.00
\put {\smaller\lines {text output\cr control file}} [l] at 0.0 1.5
\put {\vector(1,0){0.25}} [Bl] at 0.75 1.5
\put {\vector(1,0){0.45}} [Bl] at 1.00 1.5
\put {\smaller rules file} [l] at 0.0 2.83
\put {\vector(1,0){0.43}} [Bl] at 0.57 2.83
\put {\vector(1,0){0.45}} [Bl] at 1.00 2.83
\put {\smaller lexicon files} [l] at 0.0 2.67
\put {\vector(1,0){0.25}} [Bl] at 0.75 2.67
\put {\vector(1,0){0.45}} [Bl] at 1.00 2.67
\put {\vector(1,0){0.20}} [Bl] at 2.55 4.00
\put {\vector(0,-1){0.35}} [Bl] at 2.75 4.00
\put {\smaller\lines {punctuation\cr formatting\cr capitalization}} at 2.75 3.36
\put {\vector(0,-1){1.6}} [Bl] at 2.75 3.10
\put {\vector(-1,0){0.20}} [Bl] at 2.75 1.50
\put {\smaller synthesized output text file} [b] at 2.0 0.55
\endpicture
@end tex
@ifinfo
@example
@group
@b{Figure @value{ktext-synth}. An overview of KTEXT synthesis}

			 structured text file with parsed words
							 |
							 |
				 +--------------------------------+
				 |           |                    |
				 |    +------------+              |
				 |    | STRUCTURED |              |
				 |    |    INPUT   |-----+        |
				 |    +------------+     |        |
				 |           |      punctuation   |
				 |        parsed     formatting   |
				 |         words   capitalization |
				 |           |           |        |
rules file ----->|--->+------------+     |        |
lexicon files -->|--->| SYNTHESIS  |     |        |
				 |    +------------+     |        |
				 |           |           |        |
				 |   synthesized words   |        |
				 |           |           |        |
				 |    +------------+     |        |
text output      |    |    TEXT    |<----+        |
control file --->|--->|   OUTPUT   |              |
				 |    +------------+              |
				 |           |                    |
				 +--------------------------------+
							 |
							 |
				synthesized output text file
@end group
@end example
@end ifinfo

In synthesis mode, KTEXT also uses six different input files and
produces one output file (plus an optional log file).  These six input
file are:

@enumerate
@item
the analysis data file,
@item
the KTEXT control file,
@item
the text output control file (optional),
@item
the PC-KIMMO rules file,
@item
the PC-KIMMO lexicon file, and
@item
the PC-KIMMO grammar file (optional).
@end enumerate

@noindent
The PC-KIMMO rules, lexicon, and grammar files are described in the
PC-KIMMO documentation and will not be discussed further in this
document; see Antworth (1990) and Antworth (1995).  The other input
files and the synthesis output text file are described in the following
chapters.

@c ----------------------------------------------------------------------------
@node Input text file, KTEXT control file, Functional structure, Top
@chapter The input text file

The input text file contains the text that KTEXT will process.  It must
be a plain text file, not a file formatted by a word processor.  If you
use a word processor such as Microsoft Word to create your text, you
must save it as plain text with no formatting.  KTEXT preserves all the
``white space'' used in the text file.  That is, it saves in its output
file the location of all line breaks, blank lines, tabs, spaces, and
other nonalphabetic characters.  This enables you to recover from the
output file the precise format and page layout of the original text.

While KTEXT will accept text with no formatting information other than
white space characters, it will also handle text that contains special
format markers.  These format markers can indicate parts of the text such
as sentences, paragraphs, sections, section headings, and titles.  The
use of special format markers is called descriptive markup.  KTEXT
(because it is based on AMPLE) works best with a system of descriptive
markup called ``standard format'' that is used by SIL International.  SIL
standard format marks the beginning of each text unit with a format
marker.  There is no explicit indication of the end of a unit.  A format
marker is composed of a special character (a backslash by default)
followed by a code of one or more letter.  For example, @code{\ti} for
title, @code{\ch} for chapter, @code{\p} for paragraph, @code{\s} for
sentence, and so on.  KTEXT does not ``know'' any particular format
markers.  You can use whatever markers you like, as long as you declare
them in the text input control file.  For more on format markers, see
section 7.3.2 below.

One of the best know systems of descriptive markup is SGML (Standard
Generalized Markup Language).  One very significant difference between
SGML and SIL standard format is that SGML uses markers in pairs, one at
the beginning of a text unit and a matching one at the end.  This
should not pose a problem for KTEXT, since KTEXT just preserves all
format markers wherever they occur.  Another difference is that SGML
flags format markers with angle brackets, for instance <paragraph>.
KTEXT can recognize SGML markers by changing the format marker flag
character from backslash to left angled bracket (see section 7.3.2
below).  Recognizing the end of the SGML format marker is a bit of a
problem.  While SGML uses a matching right angled bracket to indicate
the end of the marker, SIL standard format simply uses a space to
delineate the format marker from the following text.  This means that
for KTEXT to find the end of an SGML tag, you must leave at least one
space after it, and there must not be any spaces in the middle of the
SGML tag.

@c ----------------------------------------------------------------------------
@node KTEXT control file, Text input control file, Input text file, Top
@chapter The KTEXT control file

KTEXT uses an overall control file to customize its operation.  This
file is structured as a @dfn{standard format database}, composed of
various fields marked by backslash codes.  The fields in the control
file are as follows.

@table @kbd
@item \textin
specifies the text input control file.  This is used only in analysis
mode.

@item \textout
specifies the text output control file.  This is used only in synthesis
mode.

@item \rules
specifies the PC-KIMMO phonological rules file.

@item \lexicon
specifies the primary PC-KIMMO lexicon file.

@item \grammar
specifies the PC-KIMMO word grammar file.  This is normally used only
in analysis mode.

@item \ach
defines an analysis field change.  This is used only in analysis mode,
after a word has been parsed.

@item \dch
defines a decomposition field change.  This is used only in analysis
mode, after a word has been parsed.

@item \scl
defines a string class for use with the analysis or decomposition
changes.

@item \cat
defines how to extract the word category (part of speech) from the
feature structure built by the word grammar.  This is used only in
analysis mode, and only if a word grammar file is loaded.

@item \fd
defines a labeled feature structure.  This is used only in analysis
mode, and only if a word grammar file is loaded.  This gives names to
feature structures produced by the word grammar for output to the
analysis data file.

@item \rd
defines the root delimiters.  The default pair of delimiters are
@t{<} and @t{>}.
@end table
@set ktext-sample-ctl 7
@noindent
Figure @value{ktext-sample-ctl} shows a sample KTEXT control file.

@example
@group
@b{Figure @value{ktext-sample-ctl}. Sample KTEXT control file}

\textin  engintx.ctl
\rules   d:\opac\test\ktext\englex\english.rul
\lexicon d:\opac\test\ktext\englex\english.lex
\grammar d:\opac\test\ktext\englex\english.grm
\textout engoutx.ctl

\cat <head pos>

\fd singular <number> = SG
\fd plural   <number> = PL
@end group
@end example

When KTEXT reads its control file, it ignores any lines beginning with
field codes other than those listed above.  For example, a line
beginning @code{\co} would be ignored.  Such lines are treated as
comments.  Comments in the control file can also be indicated with the
comment character, which by default is semicolon.  This is the only way
to place comments on the same line as a field.  The comment character
can be changed with the command line option @samp{-c} when running
KTEXT (see chapter 3).

@c ----------------------------------------------------------------------------
@node Text input control file, Text output control file, KTEXT control file, Top
@chapter The text input control file
@include textin.txi
@set textin-title The text input control file

@c ----------------------------------------------------------------------------
@node Text output control file, Analysis files, Text input control file, Top
@chapter The text output control file
@include textout.txi

@c ----------------------------------------------------------------------------
@node Analysis files, KTEXT synthesis output, Text output control file, Top
@chapter KTEXT analysis output
@include anafiles.txi

@c ----------------------------------------------------------------------------
@node KTEXT synthesis output, Bibliography, Analysis files, Top
@chapter KTEXT synthesis output

KTEXT tries to recreate the format of the original input to analysis in
its synthesis output.  The main feature worth noting is that synthesis
ambiguities and failures are marked similarly to analysis ambiguities
and failures in KTEXT analysis output.

@c ----------------------------------------------------------------------------
@node Bibliography, , KTEXT synthesis output, Top
@unnumbered Bibliography

@enumerate
@item
Antworth, Evan L.@. 1990.
@cite{PC-KIMMO: a two-level processor for morphological analysis}.
@tex
\break
@end tex
Occasional Publications in Academic Computing No.@: 16. Dallas, TX:
Summer Institute of Linguistics.

@item
Antworth, Evan L.@. 1995. @cite{User's Guide to PC-KIMMO version 2}.  URL
@tex
\hfil\break
@end tex
@ifset html
<A HREF="ftp://ftp.sil.org/software/dos/pc-kimmo/guide.zip">ftp://ftp.sil.org/software/dos/pc-kimmo/guide.zip</A>
@end ifset
@ifclear html
@w{@t{ftp://ftp.sil.org/software/dos/pc-kimmo/guide.zip}}
@end ifclear
(visited 1997, June 11).

@item
Bloomfield, Leonard. 1917.
@cite{Tagalog texts with grammatical analysis.}
Urbana, IL: University of Illinois.

@item
Jang, Taeho. 1995.
@cite{Computer assisted adaptation of text from Turkish to Korean: design and
implementation}.
Master of Arts in Linguistics, University of Texas at Arlington, Arlington, TX.

@item
Kew, Jonathan and Stephen R. McConnel. 1991.
@cite{Formatting interlinear text}.
Occasional Publications in Academic Computing No.@: 17.
Dallas, TX: Summer Institute of Linguistics.

@item
Knuth, Donald E.@. 1986.
@cite{The @TeX{}book}.
Reading, MA: Addison Wesley Publishing Company.

@item
Oflazer, Kemal. 1994a.
Two-level Description of Turkish Morphology.
@cite{Literary and Linguistic Computing}.
9(2), 137@value{endash}148.

@item
Oflazer, Kemal. 1994b.
@cite{TURKLEX}. URL
@tex
\hfil\break
@end tex
@ifset html
<A HREF="ftp://crl.nmsu.edu/CLR/tools/ling-analysis/morphology/turklex/turklex.tar.z">ftp://crl.nmsu.edu/CLR/tools/ling-analysis/morphology/turklex/turklex.tar.z</A>
@end ifset
@ifclear html
@w{@t{ftp://crl.nmsu.edu/CLR/tools/ling-analysis/morphology/turklex/turklex.tar.z}}
@end ifclear
(visited 1997, June 11).

@item
Simons, Gary F., and John Thomson. 1988.
@cite{How to use IT: interlinear text processing on the Macintosh}.
Edmonds, WA: Linguist's Software.

@item
Simons, Gary F., and Larry Versaw. 1991.
@cite{How to use IT: a guide to interlinear text processing}, 3rd ed.
Dallas, TX: Summer Institute of Linguistics.

@item
Weber, David J., H. Andrew Black, and Stephen R. McConnel. 1988.
@cite{AMPLE: a tool for exploring morphology}.
Occasional Publications in Academic Computing No.@: 12.
Dallas, TX: Summer Institute of Linguistics.

@item
Weber, David J., H. Andrew Black, Stephen R. McConnel, and Alan Buseman. 1990.
@cite{STAMP: a tool for dialect adaptation}.
Occasional Publications in Academic Computing No.@: 15.
Dallas, TX: Summer Institute of Linguistics.
@end enumerate

@c ----------------------------------------------------------------------------
@contents
@bye
