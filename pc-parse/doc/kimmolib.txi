\input pcparse % common TeX setup  @c -*-texinfo-*-
\input texinfo
@c %**start of header
@setfilename kimmolib.info
@settitle PC-Kimmo Function Library Reference Manual
@c %**end of header

@syncodeindex vr fn

@set TITLE PC-Kimmo Function Library Reference Manual
@set SUBTITLE two-level processor functions for morphological analysis
@set VERSION version 2.1.0
@set DATE October 1997
@set AUTHOR by Stephen McConnel
@set COPYRIGHT Copyright @copyright{} 2000 SIL International

@include front.txi

@c ----------------------------------------------------------------------------
@node    Top,       Introduction,  (dir),    (dir)
@comment node-name, next,          previous, up
@menu
* Introduction::

* Naming Conventions::

* Data Structures::

* Global Variables::

* Functions::

* Index::
@end menu
@c ----------------------------------------------------------------------------
@node    Introduction, Naming Conventions, Top,      Top
@comment node-name,    next,               previous, up
@chapter Introduction to the PC-Kimmo function library

One of the original design goals of the PC-Kimmo program was to produce
a reusable function library that could be used in different programs or
with different user interfaces.  The functions and data structures
described in this manual are a result of that design goal.

The PC-Kimmo function library can be used for programs that need to
handle the morphology and phonology of natural language using the
two-level morphology originally invented by Kimmo Koskenniemi.  (His
use of the term morphology should be understood to encompass both what
linguists would consider morphology proper@value{emdash}the
decomposition of words into morphemes@value{emdash}and
phonology@value{emdash}at least in the sense of morphophonemics.)

The author would appreciate feedback directed to the following address:

@example
Stephen McConnel                 (972)708-7361 (office)
Language Software Development    (972)708-7561 (fax)
SIL International
7500 W. Camp Wisdom Road
Dallas, TX 75236                 steve@@acadcomp.sil.org
U.S.A.                        or steve.mcconnel@@sil.org
@end example

@c ----------------------------------------------------------------------------
@node Naming Conventions, Data Structures, Introduction, Top
@set library-name PC-Kimmo
@set library-tag Kimmo
@include naming.txi

@c ----------------------------------------------------------------------------
@node Data Structures, Global Variables, Naming Conventions, Top
@chapter PC-Kimmo data structures

The PC-Kimmo functions operate on a number of different data
structures.  The most important of these are described in the
following sections.  The PC-Kimmo functions also use a number of other
data structures internally, but it should not be necessary for a
programmer to manipulate them directly.

@menu
* KimmoData::
* KimmoResult::
@end menu

@c ----------------------------------------------------------------------------
@page
@node KimmoData, KimmoResult, Data Structures, Data Structures
@section KimmoData
@subheading Definition
@example
#include <stdio.h>
/*
 *  type definition for KimmoData * needed for patr.h
 */
typedef struct kimmo_data KimmoData;
#include "patr.h"               /* needed for PATRData */
/*
 *  forward declarations for internal data types
 */
typedef struct kimmo_alternation KimmoAlternation;
typedef struct kimmo_lexicon     KimmoLexicon;
typedef struct kimmo_pair        KimmoPair;
typedef struct kimmo_rule        KimmoRule;
typedef struct kimmo_subset      KimmoSubset;

struct kimmo_data @{
	/*
	 *  parameters for controlling the PC-Kimmo processing
	 */
	char                bLimit;
	char                iTraceLevel;
	char                bUsePATR;
	char                bSilent;
	char                bShowWarnings;
	char                bAlignment;
	unsigned char       cGlossBegin;
	unsigned char       cGlossEnd;
	unsigned char       cComment;
	FILE *              pLogFP;
	/*
	 *  loaded or derived from the rules file
	 */
	unsigned char **    ppszAlphabet;
	unsigned short      uiAlphabetSize;
	unsigned char       cNull;
	unsigned char       cAny;
	unsigned char       cBoundary;
	char                bTwoLCFile;
	KimmoSubset *       pSubsets;
	unsigned short      uiSubsetCount;
	KimmoRule *         pAutomata;
	unsigned short      uiAutomataSize;
	KimmoPair *         pFeasiblePairs;
	unsigned short      uiFeasiblePairsCount;
	char *              pszRulesFile;
	/*
	 *  loaded or derived from the lexicon file
	 */
	KimmoAlternation *  pAlternations;
	unsigned short      uiAlternationCount;
	KimmoLexicon *      pLexiconSections;
	KimmoLexicon *      pInitialLexicon;
	unsigned short      uiLexiconSectionCount;
	unsigned char **    ppszFeatures;
	unsigned short      uiFeatureCount;
	char *              pszLexiconFile;
	/*
	 *  loaded or derived from the grammar file
	 */
	PATRData            sPATR;
	@};
@end example
@subheading Description
The @code{KimmoData} data structure collects the information used for
data processing within the PC-Kimmo functions.  Its general purpose is
to reduce the number of parameters needed by the various functions.
@table @code
@item bLimit
limits the processing to a single good result if @code{TRUE} (nonzero).

@item iTraceLevel
is the degree of tracing output desired from PC-Kimmo processes (0
means none).

@item bUsePATR
causes the word grammar to be applied to the output of the two-level
processor.  (This requires that a grammar file be loaded).

@item bSilent
disables messages to the ``standard error'' stream (@code{stderr}).

@item bShowWarnings
enables warning messages as well as error messages.

@item bAlignment
causes recognizer file or screen output to be aligned vertically
(underlying form above gloss) if @code{TRUE}.

@item cGlossBegin
@itemx cGlossEnd
are the characters that optionally surround morphnames in synthesizer
input strings.

@item cComment
is the character that begins a comment in an input line.
(@code{KIMMO_DEFAULT_COMMENT} is a symbol for the default value.)

@item pLogFP
is the @code{FILE} pointer for an output log file (@code{NULL} means
none).

@item ppszAlphabet
points to a dynamically allocated array of alphabetic characters.  The
``characters'' are stored as strings since they may be digraphs,
trigraphs, etc.  A maximum of 252 different characters may be stored.
The array is @code{NULL} terminated.

@item uiAlphabetSize
is the number of alphabetic ``characters'' in the array.

@item cNull
is the ``null'' character.

@item cAny
is the ``wild card'' character that matches any character.

@item cBoundary
is the word boundary character that matches the beginning or the end of
a word.

@item bTwoLCFile
records whether the rules were loaded from a TwoLC type rules file.

@item pSubsets
points to a dynamically allocated array of alphabet subset data
structures.

@item uiSubsetCount
is the number of alphabet subsets in the array.

@item pAutomata
points to a dynamically allocated array of two-level automata data
structures.

@item uiAutomataSize
is the number of rules in the automata array.

@item pFeasiblePairs
points to a dynamically allocated array of feasible pair data
structures.

@item uiFeasiblePairsCount
is the number of feasible pairs in the array.

@item pszRulesFile
points to the name of the current PC-Kimmo rules file (@code{NULL}
means none).

@item pAlternations
points to a dynamically allocated array of lexicon section
alternation (continuation class) data structures.

@item uiAlternationCount
is the number of alternations in the array.

@item pLexiconSections
points to an array of PC-Kimmo lexicon data structures, one for each
section of the lexicon.

@item pInitialLexicon
points to the logical first ("INITIAL") section of lexicon.

@item uiLexiconSectionCount
is the number of sections (data structures) in the lexicon array.

@item ppszFeatures
points to a dynamically allocated array of possible feature (template)
labels.

@item uiFeatureCount
is the number of feature labels in the array.

@item pszLexiconFile
points to the name of the current PC-Kimmo lexicon file (@code{NULL}
means none).

@item sPATR
contains the information loaded from the grammar file, which includes the
name of the current PC-Kimmo word grammar file.
@end table
@subheading Source File
@file{kimmo.h}

@menu
* applyKimmoGenerator::
* applyKimmoRecognizer::
* applyKimmoSynthesizer::
* checkKimmoRuleStatus::
* concatKimmoMorphFeatures::
* concatKimmoMorphGlosses::
* concatKimmoMorphLexemes::
* freeKimmoLexicon::
* freeKimmoRules::
* loadKimmoLexicon::
* loadKimmoRules::
* setKimmoRuleStatus::
* writeKimmoFeasiblePairs::
* writeKimmoLexiconSection::
* writeKimmoLexiconSectionNames::
* writeKimmoResults::
* writeKimmoRule::
* writeKimmoRulesStatus::
@end menu

@c ----------------------------------------------------------------------------
@page
@node KimmoResult, , KimmoData, Data Structures
@section KimmoResult
@subheading Definition
@example
/*
 *  type definition for KimmoResult * needed for patr.h
 */
typedef struct kimmo_result KimmoResult;
#include "patr.h"               /* needed for PATREdgeList */
/*
 *  forward declaration for internal data type
 */
typedef struct kimmo_morpheme KimmoMorpheme;

struct kimmo_result @{
	KimmoResult *       pNext;
	unsigned char *     pszSynthesis;
	KimmoMorpheme *     pAnalysis;
	PATREdgeList *      pParseChart;
	unsigned char *     pszResult;
	unsigned char *     pszGloss;
	short               bOkay;
	@};
@end example
@subheading Description
The @code{KimmoResult} data structure contains a single result from one
of the PC-Kimmo processing functions (@code{applyKimmoGenerator},
@code{applyKimmoRecognizer}, or @code{applyKimmoSynthesizer}).  It can
be used to build a linked list for ambiguous results.
@table @code
@item pNext
points to the next result, if any.

@item pszSynthesis
points to a synthesized surface form created by
@code{applyKimmoGenerator} or @code{applyKimmoSynthesizer}.

@item pAnalysis
points to a list of morpheme data structures created by
@code{applyKimmoRecognizer}.

@item pParseChart
points to a PATR parse chart created by @code{applyKimmoRecognizer}.

@item pszResult
points to a result string created by @code{applyKimmoGenerator},
@code{applyKimmoRecognizer}, or @code{applyKimmoSynthesizer}.  It
differs from @code{pszSynthesis} in that it has the ``null'' characters
removed.

@item pszGloss
points to a ``gloss'' string created by @code{applyKimmoRecognizer}.

@item bOkay
is a Boolean variable made available for programmar use.  It is set
@code{FALSE} by @code{applyKimmoGenerator},
@code{applyKimmoRecognizer}, and @code{applyKimmoSynthesizer}.
@end table
@subheading Source File
@file{kimmo.h}

@menu
* applyKimmoGenerator::
* applyKimmoRecognizer::
* applyKimmoSynthesizer::
* freeKimmoResult::
* writeKimmoResults::
@end menu

@c ----------------------------------------------------------------------------
@node Global Variables, Functions, Data Structures, Top
@chapter The PC-Kimmo function library global variables

This chapter gives the proper usage information about each of the
global variables found in the PC-Kimmo function library.  The
@file{kimmo.h} header file contains the extern declarations for all of
these variables.

@menu
* bCancelKimmoOperation_g::
* cKimmoPatchSep_g::
* iKimmoPatchlevel_g::
* iKimmoRevision_g::
* iKimmoVersion_g::
* pszKimmoCompileDate_g::
* pszKimmoCompileFormat_g::
* pszKimmoCompileTime_g::
* pszKimmoDate_g::
* pszKimmoTestVersion_g::
* pszKimmoYear_g::
* uiKimmoCharArraySize_g::
* uiKimmoLexItemArraySize_g::
* uiKimmoShortArraySize_g::
@end menu

@c ----------------------------------------------------------------------------
@page
@node bCancelKimmoOperation_g, cKimmoPatchSep_g, Global Variables, Global Variables
@section bCancelKimmoOperation_g
@subheading Syntax
@example
#include "kimmo.h"

extern int      bCancelKimmoOperation_g;
@end example
@subheading Description
@code{bCancelKimmoOperation_g} can be set asynchronously to interrupt a
PC-Kimmo parse that seems to be stuck.
@subheading Example
@smallexample
#include <signal.h>
#include "kimmo.h"
#include "patr.h"
...
void sigint_handler(int iSignal_in)
@{
bCancelKimmoOperation_g = TRUE;
bCancelPATROperation_g = TRUE;  /* remember embedded PATR parser */
signal(SIGINT, sigint_handler);
@}
...
signal(SIGINT, sigint_handler);
...
@end smallexample
@subheading Source File
@file{kimmdata.c}

@menu
* applyKimmoGenerator::
* applyKimmoRecognizer::
* applyKimmoSynthesizer::
* loadKimmoLexicon::
* loadKimmoRules::
@end menu

@c ----------------------------------------------------------------------------
@page
@node cKimmoPatchSep_g, iKimmoPatchlevel_g, bCancelKimmoOperation_g, Global Variables
@section cKimmoPatchSep_g
@subheading Syntax
@example
#include "kimmo.h"

extern const char       cKimmoPatchSep_g;
@end example
@subheading Description
@code{cKimmoPatchSep_g} is used to separate the revision and patch
level values when printing the PC-Kimmo version number.  @code{'a'}
indicates an alpha release, @code{'b'} indicates a beta release, and
@code{'.'} indicates a production release.
@subheading Example
@ifset txt
See the example for @code{iKimmoVersion_g} below.
@end ifset
@ifclear txt
@xref{iKimmoVersion_g, , Example}.
@end ifclear
@subheading Source File
@file{kimmdata.c}

@c ----------------------------------------------------------------------------
@page
@node iKimmoPatchlevel_g, iKimmoRevision_g, cKimmoPatchSep_g, Global Variables
@section iKimmoPatchlevel_g
@subheading Syntax
@example
#include "kimmo.h"

extern const int        iKimmoPatchlevel_g;
@end example
@subheading Description
@code{iKimmoPatchlevel_g} is the current @dfn{patch level} of the
PC-Kimmo function library and program.  This is the third level version
number, reflecting bug fixes or internal improvements that should be
functionally invisible to users.
@subheading Example
@ifset txt
See the example for @code{iKimmoVersion_g} below.
@end ifset
@ifclear txt
@xref{iKimmoVersion_g, , Example}.
@end ifclear
@subheading Source File
@file{kimmdata.c}

@c ----------------------------------------------------------------------------
@page
@node iKimmoRevision_g, iKimmoVersion_g, iKimmoPatchlevel_g, Global Variables
@section iKimmoRevision_g
@subheading Syntax
@example
#include "kimmo.h"

extern const int        iKimmoRevision_g;
@end example
@subheading Description
@code{iKimmoRevision_g} is the current @dfn{revision level} of the
PC-Kimmo function library and program.  This is the second level
version number, reflecting changes to program behavior that require
changes to the @cite{PC-Kimmo Reference Manual}.
@subheading Example
@ifset txt
See the example for @code{iKimmoVersion_g} below.
@end ifset
@ifclear txt
@xref{iKimmoVersion_g, , Example}.
@end ifclear
@subheading Source File
@file{kimmdata.c}

@c ----------------------------------------------------------------------------
@page
@node iKimmoVersion_g, pszKimmoCompileDate_g, iKimmoRevision_g, Global Variables
@section iKimmoVersion_g
@subheading Syntax
@example
#include "kimmo.h"

extern const int        iKimmoVersion_g;
@end example
@subheading Description
@code{iKimmoVersion_g} is the current @dfn{version} number of the
PC-Kimmo function library and program.  This is the top level version
number, reflecting a major rewrite of the program or major changes that
make it incompatible with earlier versions of the program.
@subheading Example
@smallexample
#include <stdio.h>
#include "kimmo.h"
...
fprintf(stderr,
		"PC-Kimmo version %d.%d%c%d (%s), Copyright %s SIL\n",
		iKimmoVersion_g, iKimmoRevision_g, cKimmoPatchSep_g,
		iKimmoPatchlevel_g, pszKimmoDate_g, pszKimmoYear_g);
#ifdef __DATE__
fprintf(stderr, pszKimmoCompileFormat_g,
		pszKimmoCompileDate_g, pszKimmoCompileTime_g);
#else
if (pszKimmoTestVersion_g != NULL)
	fputs(pszKimmoTestVersion_g, stderr);
#endif
...
@end smallexample
@subheading Source File
@file{kimmdata.c}

@c ----------------------------------------------------------------------------
@page
@node pszKimmoCompileDate_g, pszKimmoCompileFormat_g, iKimmoVersion_g, Global Variables
@section pszKimmoCompileDate_g
@subheading Syntax
@example
#include "kimmo.h"

#ifdef __DATE__
extern const char *     pszKimmoCompileDate_g;
#endif
@end example
@subheading Description
@code{pszKimmoCompileDate_g} points to a string containing the date on
which the PC-Kimmo library was compiled.  It exists only if the C
compiler preprocessor supports the @code{__DATE__} constant.
@subheading Example
@ifset txt
See the example for @code{iKimmoVersion_g} above.
@end ifset
@ifclear txt
@xref{iKimmoVersion_g, , Example}.
@end ifclear
@subheading Source File
@file{kimmdata.c}

@c ----------------------------------------------------------------------------
@page
@node pszKimmoCompileFormat_g, pszKimmoCompileTime_g, pszKimmoCompileDate_g, Global Variables
@section pszKimmoCompileFormat_g
@subheading Syntax
@example
#include "kimmo.h"

#ifdef __DATE__
#ifdef __TIME__
extern const char *     pszKimmoCompileFormat_g;
#endif
#endif
@end example
@subheading Description
@code{pszKimmoCompileFormat_g} points to a @code{printf} style format
string suitable for displaying @code{pszKimmoCompileDate_g} and
@code{pszKimmoCompileTime_g}.  It exists only if the C compiler
preprocessor supports the @code{__DATE__} and @code{__TIME__} constants.
@subheading Example
@ifset txt
See the example for @code{iKimmoVersion_g} above.
@end ifset
@ifclear txt
@xref{iKimmoVersion_g, , Example}.
@end ifclear
@subheading Source File
@file{kimmdata.c}

@c ----------------------------------------------------------------------------
@page
@node pszKimmoCompileTime_g, pszKimmoDate_g, pszKimmoCompileFormat_g, Global Variables
@section pszKimmoCompileTime_g
@subheading Syntax
@example
#include "kimmo.h"

#ifdef __TIME__
extern const char *     pszKimmoCompileTime_g;
#endif
@end example
@subheading Description
@code{pszKimmoCompileTime_g} points to a string containing the time at
which the PC-Kimmo library was compiled.  It exists only if the C
compiler preprocessor supports the @code{__TIME__} constant.
@subheading Example
@ifset txt
See the example for @code{iKimmoVersion_g} above.
@end ifset
@ifclear txt
@xref{iKimmoVersion_g, , Example}.
@end ifclear
@subheading Source File
@file{kimmdata.c}

@c ----------------------------------------------------------------------------
@page
@node pszKimmoDate_g, pszKimmoTestVersion_g, pszKimmoCompileTime_g, Global Variables
@section pszKimmoDate_g
@subheading Syntax
@example
#include "kimmo.h"

extern const char *     pszKimmoDate_g;
@end example
@subheading Description
@code{pszKimmoDate_g} points to a string containing the date on
which the PC-Kimmo library was last modified.
@subheading Example
@ifset txt
See the example for @code{iKimmoVersion_g} above.
@end ifset
@ifclear txt
@xref{iKimmoVersion_g, , Example}.
@end ifclear
@subheading Source File
@file{kimmdata.c}

@c ----------------------------------------------------------------------------
@page
@node pszKimmoTestVersion_g, pszKimmoYear_g, pszKimmoDate_g, Global Variables
@section pszKimmoTestVersion_g
@subheading Syntax
@example
#include "kimmo.h"

#ifndef __DATE__
extern const char *     pszKimmoTestVersion_g;
#endif
@end example
@subheading Description
@code{pszKimmoTestVersion_g} points to a string describing the test
status of PC-Kimmo (either alpha or beta).  If this is a production
release version, it is set to @code{NULL}.  It is defined only if the C
compiler preprocessor does not support the @code{__DATE__} constant.
@subheading Example
@ifset txt
See the example for @code{iKimmoVersion_g} above.
@end ifset
@ifclear txt
@xref{iKimmoVersion_g, , Example}.
@end ifclear
@subheading Source File
@file{kimmdata.c}

@c ----------------------------------------------------------------------------
@page
@node pszKimmoYear_g, uiKimmoCharArraySize_g, pszKimmoTestVersion_g, Global Variables
@section pszKimmoYear_g
@subheading Syntax
@example
#include "kimmo.h"

extern const char *     pszKimmoYear_g;
@end example
@subheading Description
@code{pszKimmoYear_g} points to a string containing the year in
which the PC-Kimmo library was last modified.  This is suitable for a
copyright notice assigning the copyright to SIL International.
@subheading Example
@ifset txt
See the example for @code{iKimmoVersion_g} above.
@end ifset
@ifclear txt
@xref{iKimmoVersion_g, , Example}.
@end ifclear
@subheading Source File
@file{kimmdata.c}

@c ----------------------------------------------------------------------------
@page
@node uiKimmoCharArraySize_g, uiKimmoLexItemArraySize_g, pszKimmoYear_g, Global Variables
@section uiKimmoCharArraySize_g
@subheading Syntax
@example
#include "kimmo.h"

extern size_t   uiKimmoCharArraySize_g;
@end example
@subheading Description
@code{uiKimmoCharArraySize_g} determines how big a buffer is allocated
for holding strings loaded from the PC-Kimmo lexicon.  A larger size
reduces the number of calls to @code{malloc}, and the amount of memory
overhead lost for each allocation, but increases the amount of memory
wasted by not being used.  The default value is @code{8000}.  Setting
@code{uiKimmoCharArraySize_g} to @code{0} causes each lexicon string
to be individually allocated with @code{malloc}.
@subheading Example
@smallexample
#include "kimmo.h"
...
unsigned char   szLexiconFile_g[256];
KimmoData       sKimmoData_g;
...
uiKimmoCharArraySize_g    = 16364;
uiKimmoLexItemArraySize_g = 16364;
uiKimmoShortArraySize_g   = 16364;
if (loadKimmoLexicon(szLexiconFile_g, KIMMO_ANALYSIS,
					 &sKimmoData_g) != 0)
	@{
	reportError(ERROR_MSG, "Cannot open lexicon file %s\n",
				szLexiconFile_g);
	@}
...
@end smallexample
@subheading Source File
@file{lexicon.c}

@menu
* loadKimmoLexicon::
@end menu

@c ----------------------------------------------------------------------------
@page
@node uiKimmoLexItemArraySize_g, uiKimmoShortArraySize_g, uiKimmoCharArraySize_g, Global Variables
@section uiKimmoLexItemArraySize_g
@subheading Syntax
@example
#include "kimmo.h"

extern size_t   uiKimmoLexItemArraySize_g;
@end example
@subheading Description
@code{uiKimmoLexItemArraySize_g} determines how many lexical item data
structures are allocated at a time while loading the PC-Kimmo lexicon.
A larger size reduces the number of calls to @code{malloc}, and the
amount of memory overhead lost for each allocation, but increases the
amount of memory wasted by not being used.  The default value is
@code{1000}.  Setting @code{uiKimmoLexItemArraySize_g} to @code{0} causes
each lexical item data structure to be individually allocated with
@code{malloc}.
@subheading Example
@ifset txt
See the example for @code{uiKimmoCharArraySize_g} above.
@end ifset
@ifclear txt
@xref{uiKimmoCharArraySize_g, , Example}.
@end ifclear
@subheading Source File
@file{lexicon.c}

@menu
* loadKimmoLexicon::
@end menu

@c ----------------------------------------------------------------------------
@page
@node uiKimmoShortArraySize_g, , uiKimmoLexItemArraySize_g, Global Variables
@section uiKimmoShortArraySize_g
@subheading Syntax
@example
#include "kimmo.h"

extern size_t   uiKimmoShortArraySize_g;
@end example
@subheading Description
@code{uiKimmoShortArraySize_g} determines how large an array of short
integers is allocated for dispensing to the individual lexical items
while loading the PC-Kimmo lexicon.
A larger size reduces the number of calls to @code{malloc}, and the
amount of memory overhead lost for each allocation, but increases the
amount of memory wasted by not being used.  The default value is
@code{2000}.  Setting @code{uiKimmoShortArraySize_g} to @code{0} causes
each lexical item data structure's array of short integers to be
individually allocated with @code{malloc}.
@subheading Example
@ifset txt
See the example for @code{uiKimmoCharArraySize_g} above.
@end ifset
@ifclear txt
@xref{uiKimmoCharArraySize_g, , Example}.
@end ifclear
@subheading Source File
@file{lexicon.c}

@menu
* loadKimmoLexicon::
@end menu

@c ----------------------------------------------------------------------------
@node Functions, Index, Global Variables, Top
@chapter PC-Kimmo functions

This document gives the proper usage information about each of the
functions found in the PC-Kimmo function library.  The prototypes and type
definitions relevent to the use of these functions are all found in the
@file{kimmo.h} header file.

@menu
* applyKimmoGenerator::
* applyKimmoRecognizer::
* applyKimmoSynthesizer::
* checkKimmoRuleStatus::
* concatKimmoMorphFeatures::
* concatKimmoMorphGlosses::
* concatKimmoMorphLexemes::
* freeKimmoLexicon::
* freeKimmoResult::
* freeKimmoRules::
* loadKimmoLexicon::
* loadKimmoRules::
* setKimmoRuleStatus::
* writeKimmoFeasiblePairs::
* writeKimmoLexiconSection::
* writeKimmoLexiconSectionNames::
* writeKimmoResults::
* writeKimmoRule::
* writeKimmoRulesStatus::
@end menu

@c ----------------------------------------------------------------------------
@page
@node applyKimmoGenerator, applyKimmoRecognizer, Functions, Functions
@section applyKimmoGenerator
@subheading Syntax
@example
#include "kimmo.h"

KimmoResult * applyKimmoGenerator(unsigned char * pszLexForm_in,
								  KimmoData *     pKimmo_in);
@end example
@subheading Description
@code{applyKimmoGenerator} tries to generate the surface form of a word
from the provided lexical form.  The PC-Kimmo rules must be loaded
before this function is called.

The arguments to @code{applyKimmoGenerator} are as follows:
@table @code
@item pszLexForm_in
points to a character string containing the lexical (underlying) form
of a word.

@item pKimmo_in
points to the data for the current language.
@end table
@subheading Return Value
a pointer to a list of results, or NULL if unsuccessful
@subheading Example
@smallexample
#include <stdio.h>
#include <string.h>
#include "kimmo.h"
...
KimmoData       sKimmoData_g;
...
void do_generate(pszForm_in)
unsigned char * pszForm_in;
@{
unsigned char * pszLexForm;
KimmoResult *   pResults;

if ((sKimmoData_g.ppszAlphabet == NULL) || (pszForm_in == NULL))
	return;
pszLexForm = pszForm_in + strspn((char *)pszForm_in, " \t\r\n\f");
if (*pszLexForm == '\0')
	return;
if (sKimmoData_g.pLogFP != NULL)
	fprintf(sKimmoData_g.pLogFP, "%s\n", pszLexForm);

pResults = applyKimmoGenerator(pszLexForm, &sKimmoData_g);

writeKimmoResults(pResults, stderr, &sKimmoData_g);
if (sKimmoData_g.pLogFP != NULL)
	writeKimmoResults(pResults, sKimmoData_g.pLogFP, &sKimmoData_g);
freeKimmoResult(pResults);
@}
@end smallexample
@subheading Source File
@file{generate.c}

@c ----------------------------------------------------------------------------
@page
@node applyKimmoRecognizer, applyKimmoSynthesizer, applyKimmoGenerator, Functions
@section applyKimmoRecognizer
@subheading Syntax
@example
#include "kimmo.h"

KimmoResult * applyKimmoRecognizer(unsigned char * pszSurfaceForm_in,
								   KimmoData *     pKimmo_in);
@end example
@subheading Description
@code{applyKimmoRecognizer} tries to analyze the provided surface form
of a word to create the lexical (underlying) form divided into
morphemes.  If the word can be divided into morphemes, and a word
grammar has been loaded, @code{applyKimmoRecognizer} also tries to
parse the list of morphemes to create a word parse chart with related
feature structures.

The PC-Kimmo rules and lexicon must be loaded before
@code{applyKimmoRecognizer} is called.  If a word parse is desired, the
word grammar must also be loaded before calling this function.

The arguments to @code{applyKimmoRecognizer} are as follows:
@table @code
@item pszSurfaceForm_in
points to a character string containing the surface form of a word.

@item pKimmo_in
points to the data for the current language.
@end table
@subheading Return Value
a pointer to a list of results, or NULL if unsuccessful
@subheading Example
@smallexample
#include <stdio.h>
#include <string.h>
#include "kimmo.h"
...
KimmoData       sKimmoData_g;
...
void do_recognize(pszForm_in)
unsigned char * pszForm_in;
@{
unsigned char * pszSurfForm;
KimmoResult *   pResults;

if (    (sKimmoData_g.ppszAlphabet     == NULL) ||
		(sKimmoData_g.pLexiconSections == NULL) ||
		(pszForm_in == NULL) )
	return;
pszSurfForm = pszForm_in + strspn((char *)pszForm_in, " \t\r\n\f");
if (*pszSurfForm == '\0')
	return;
if (sKimmoData_g.pLogFP != NULL)
	fprintf(sKimmoData_g.pLogFP, "%s\n", pszSurfForm);

pResults = applyKimmoRecognizer(pszSurfForm, &sKimmoData_g);

writeKimmoResults(pResults, stderr, &sKimmoData_g);
if (sKimmoData_g.pLogFP != NULL)
	writeKimmoResults(pResults, sKimmoData_g.pLogFP, &sKimmoData_g);
freeKimmoResult(pResults);
@}
@end smallexample
@subheading Source File
@file{recogniz.c}

@c ----------------------------------------------------------------------------
@page
@node applyKimmoSynthesizer, checkKimmoRuleStatus, applyKimmoRecognizer, Functions
@section applyKimmoSynthesizer
@subheading Syntax
@example
#include "kimmo.h"

KimmoResult * applyKimmoSynthesizer(unsigned char * pszMorphemes_in,
									KimmoData *     pKimmo_in);
@end example
@subheading Description
@code{applyKimmoSynthesizer} tries to synthesize a word from a string
containing an ordered list of morpheme names (glosses) separated by
spaces.  The PC-Kimmo rules and synthesis lexicon must be loaded before
this function is called.

The arguments to @code{applyKimmoSynthesizer} are as follows:
@table @code
@item pszMorphemes_in
points to a character string containing an ordered list of morpheme
names (glosses) separated by spaces.

@item pKimmo_in
points to the data for the current language.  The lexicon stored in the
data must be accessible by gloss (morpheme name) rather than by lexical
(underlying) form.
@end table
@subheading Return Value
a pointer to a list of results, or NULL if unsuccessful
@subheading Example
@smallexample
#include <stdio.h>
#include <string.h>
#include "kimmo.h"
...
KimmoData       sKimmoData_g;
KimmoData       sSynthesisData_g;
...
static void fix_synthesis_data()
@{
sSynthesisData_g.bLimit               = sKimmoData_g.bLimit;
sSynthesisData_g.iTraceLevel          = sKimmoData_g.iTraceLevel;
sSynthesisData_g.bUsePATR             = sKimmoData_g.bUsePATR;
sSynthesisData_g.bSilent              = sKimmoData_g.bSilent;
sSynthesisData_g.bShowWarnings        = sKimmoData_g.bShowWarnings;
sSynthesisData_g.bAlignment           = sKimmoData_g.bAlignment;
sSynthesisData_g.cGlossBegin          = sKimmoData_g.cGlossBegin;
sSynthesisData_g.cGlossEnd            = sKimmoData_g.cGlossEnd;
sSynthesisData_g.cComment             = sKimmoData_g.cComment;
sSynthesisData_g.pLogFP               = sKimmoData_g.pLogFP;
sSynthesisData_g.ppszAlphabet         = sKimmoData_g.ppszAlphabet;
sSynthesisData_g.uiAlphabetSize       = sKimmoData_g.uiAlphabetSize;
sSynthesisData_g.cNull                = sKimmoData_g.cNull;
sSynthesisData_g.cAny                 = sKimmoData_g.cAny;
sSynthesisData_g.cBoundary            = sKimmoData_g.cBoundary;
sSynthesisData_g.bTwoLCFile           = sKimmoData_g.bTwoLCFile;
sSynthesisData_g.pSubsets             = sKimmoData_g.pSubsets;
sSynthesisData_g.uiSubsetCount        = sKimmoData_g.uiSubsetCount;
sSynthesisData_g.pAutomata            = sKimmoData_g.pAutomata;
sSynthesisData_g.uiAutomataSize       = sKimmoData_g.uiAutomataSize;
sSynthesisData_g.pFeasiblePairs       = sKimmoData_g.pFeasiblePairs;
sSynthesisData_g.uiFeasiblePairsCount =
								  sKimmoData_g.uiFeasiblePairsCount;
sSynthesisData_g.pszRulesFile         = sKimmoData_g.pszRulesFile;
memset(&sSynthesisData_g.sPATR, 0, sizeof(PATRData));
@}

void do_synthesize(pszForm_in)
unsigned char * pszForm_in;
@{
unsigned char * pszMorphForm;
KimmoResult *   pResults;

if (    (sKimmoData_g.ppszAlphabet == NULL) ||
		(sSynthesisData_g.pLexiconSections == NULL) ||
		(pszForm_in == NULL) )
	return;
pszMorphForm = pszForm_in + strspn((char *)pszForm_in, " \t\r\n\f");
if (*pszMorphForm == '\0')
	return;
fix_synthesis_data();

if (sKimmoData_g.pLogFP != NULL)
	fprintf(sKimmoData_g.pLogFP, "%s\n", pszMorphForm);

pResults = applyKimmoSynthesizer(pszMorphForm, &sKimmoData_g);

writeKimmoResults(pResults, stderr, &sKimmoData_g);
if (sKimmoData_g.pLogFP != NULL)
	writeKimmoResults(pResults, sKimmoData_g.pLogFP, &sKimmoData_g);
freeKimmoResult(pResults);
@}
@end smallexample
@subheading Source File
@file{synthesi.c}

@c ----------------------------------------------------------------------------
@page
@node checkKimmoRuleStatus, concatKimmoMorphFeatures, applyKimmoSynthesizer, Functions
@section checkKimmoRuleStatus
@subheading Syntax
@example
#include "kimmo.h"

int checkKimmoRuleStatus(int         iRule_in,
						 KimmoData * pKimmo_in);
@end example
@subheading Description
@code{checkKimmoRuleStatus} checks whether or not the given rule is
active.

The arguments to @code{checkKimmoRuleStatus} are as follows:
@table @code
@item iRule_in
is the number of a loaded PC-Kimmo rule.  The first rule is numbered 1,
not 0 as in C arrays.

@item pKimmo_in
points to the data for the current language.
@end table
@subheading Return Value
TRUE if the given rule is active, otherwise FALSE
@subheading Example
@smallexample
#include <stdio.h>
#include "kimmo.h"
...
void show_rule_status(KimmoData * pKimmo_in)
@{
int     i;
int     iCount;
int     iWidth;
int     bActive;

if (pKimmo_in->uiAutomataSize == 0)
	@{
	fprintf(stderr, "    There are no rules.\n");
	return;
	@}
for ( iCount = 0, i = 1 ; i <= pKimmo_in->uiAutomataSize ; ++i )
	@{
	if (checkKimmoRuleStatus(i, pKimmo_in))
		++iCount;
	@}
if (iCount == pKimmo_in->uiAutomataSize)
	@{
	fprintf(stderr, "    Rules are ALL ON.\n");
	return;
	@}
if (iCount == 0)
	@{
	fprintf(stderr, "    Rules are ALL OFF.\n");
	return;
	@}
fprintf(stderr, "    Rules are");
iWidth = 13;
for ( i = 1 ; i <= pKimmo_in->uiAutomataSize ; ++i )
	@{
	if (iWidth == 0)
		@{
		fputs("             ", stderr);
		iWidth = 13;
		@}
	bActive = checkKimmoRuleStatus(i, pKimmo_in);
	if (i < pKimmo_in->uiAutomataSize)
		@{
		fprintf(stderr, "%3d %s", i, bActive ? "ON, ":"OFF,");
		iWidth += 8;
		@}
	else
		@{
		fprintf(stderr, "%3d %s", i, bActive ? "ON ":"OFF");
		iWidth += 7;
		@}
	if (iWidth >= 72)
		@{
		putc( '\n', stderr);
		iWidth = 0;
		@}
	@}
if (iLength != 0)
	putc( '\n', stderr);
@}
@end smallexample
@subheading Source File
@file{rules.c}

@c ----------------------------------------------------------------------------
@page
@node concatKimmoMorphFeatures, concatKimmoMorphGlosses, checkKimmoRuleStatus, Functions
@section concatKimmoMorphFeatures
@subheading Syntax
@example
#include "kimmo.h"

unsigned char * concatKimmoMorphFeatures(
								KimmoMorpheme * pMorphemes_in,
								char *          pszSeparate_in,
								KimmoData *     pKimmo_in);
@end example
@subheading Description
@code{concatKimmoMorphFeatures} concatenates the feature names from a
list of morphemes created by @code{applyKimmoRecognizer} as part of a
@code{KimmoResult} data structure.

The arguments to @code{concatKimmoMorphFeatures} are as follows:
@table @code
@item pMorphemes_in
points to a list of morpheme data structures, usually the
@code{pAnalysis} element of a @code{KimmoResult} data structure.

@item pszSeparate_in
points to a character string used to separate the feature names in the
result.
@item pKimmo_in
points to the data for the current language.
@end table
@subheading Return Value
a pointer to a dynamically allocated string containing the concatenated
feature names from a list of morphemes, or NULL
@subheading Example
@smallexample
#include <stdio.h>
#include <string.h>
#include "kimmo.h"
#include "patr.h"
#include "opaclib.h"
...
void write_as_WordTemplate(unsigned char * pszForm_in,
						   KimmoResult *   pResults_in,
						   KimmoData *     pKimmo_in,
						   FILE *          pOutputFP_in)
@{
KimmoResult *   pResult;
WordAnalysis *  pAnal;
WordTemplate *  pWord;

if ((pszForm_in == NULL) || (pOutputFP_in == NULL))
	return;
/*
 *  allocate and initialize a WordTemplate structure
 */
pWord = (WordTemplate *)allocMemory(sizeof(WordTemplate));
pWord->pszFormat    = NULL;
pWord->pszOrigWord  = pszForm_in;
pWord->paWord       = NULL;
pWord->pszNonAlpha  = NULL;
pWord->iCapital     = 0;
pWord->iOutputFlags = WANT_DECOMPOSITION | WANT_FEATURES |
					  WANT_UNDERLYING    | WANT_ORIGINAL;
pWord->pAnalyses    = NULL;
pWord->pNewWords    = NULL;
/*
 *  convert the results into a list of WordAnalysis structures
 */
for ( pResult = pResults_in ; pResult ; pResult = pResult->pNext )
	@{
	pAnal = (WordAnalysis *)allocMemory(sizeof(WordAnalysis));
	pAnal->pszAnalysis       = (char *)concatKimmoMorphGlosses(
												pResult->pAnalysis,
												" ",
												pKimmo_in);
	pAnal->pszDecomposition  = (char *)concatKimmoMorphLexemes(
												pResult->pAnalysis,
												"-",
												pKimmo_in);
	pAnal->pszCategory       = NULL;
	pAnal->pszProperties     = NULL;
	pAnal->pszFeatures       = (char *)concatKimmoMorphFeatures(
												pResult->pAnalysis,
												" ",
												pKimmo_in);
	pAnal->pszUnderlyingForm = duplicateString(pResult->pszResult);
	pAnal->pszSurfaceForm    = pszForm_in;
	pAnal->pNext             = pWord->pAnalyses;
	pWord->pAnalyses         = pAnal;
	@}
/*
 *  write the WordTemplate data and free the memory it used
 */
writeTemplate(pOutputFP_in, NULL, pWord, NULL);
pWord->pszOrigWord = NULL;
for ( pAnal = pWord->pAnalyses ; pAnal ; pAnal = pAnal->pNext )
	pAnal->pszSurfaceForm = NULL;
freeWordTemplate(pWord);
@}
@end smallexample
@subheading Source File
@file{pckfuncs.c}

@c ----------------------------------------------------------------------------
@page
@node concatKimmoMorphGlosses, concatKimmoMorphLexemes, concatKimmoMorphFeatures, Functions
@section concatKimmoMorphGlosses
@subheading Syntax
@example
#include "kimmo.h"

unsigned char * concatKimmoMorphGlosses(
								KimmoMorpheme * pMorphemes_in,
								char *          pszSeparate_in,
								KimmoData *     pKimmo_in);
@end example
@subheading Description
@code{concatKimmoMorphGlosses} concatenates the glosses from a list of
morphemes created by @code{applyKimmoRecognizer} as part of a
@code{KimmoResult} data structure.


The arguments to @code{concatKimmoMorphGlosses} are as follows:
@table @code
@item pMorphemes_in
points to a list of morpheme data structures, usually the
@code{pAnalysis} element of a @code{KimmoResult} data structure.

@item pszSeparate_in
points to a character string used to separate the morpheme glosses in
the result.

@item pKimmo_in
points to the data for the current language.
@end table
@subheading Return Value
a pointer to a dynamically allocated string containing the concatenated
glosses from a list of morphemes, or NULL
@subheading Example
@ifset txt
See the example for @code{concatKimmoMorphFeatures} above.
@end ifset
@ifclear txt
@xref{concatKimmoMorphFeatures, , Example}.
@end ifclear
@subheading Source File
@file{pckfuncs.c}

@c ----------------------------------------------------------------------------
@page
@node concatKimmoMorphLexemes, freeKimmoLexicon, concatKimmoMorphGlosses, Functions
@section concatKimmoMorphLexemes
@subheading Syntax
@example
#include "kimmo.h"

unsigned char * concatKimmoMorphLexemes(
								KimmoMorpheme * pMorphemes_in,
								char *          pszSeparate_in,
								KimmoData *     pKimmo_in);
@end example
@subheading Description
@code{concatKimmoMorphLexemes} concatenates the lexical (underlying)
forms from a list of morphemes created by @code{applyKimmoRecognizer}
as part of a @code{KimmoResult} data structure.

The arguments to @code{concatKimmoMorphLexemes} are as follows:
@table @code
@item pMorphemes_in
points to a list of morpheme data structures, usually the
@code{pAnalysis} element of a @code{KimmoResult} data structure.

@item pszSeparate_in
points to a character string used to separate the morpheme lexical
forms in the result.

@item pKimmo_in
points to the data for the current language.
@end table
@subheading Return Value
a pointer to a dynamically allocated string containing the concatenated
lexical forms from a list of morphemes, or NULL
@subheading Example
@ifset txt
See the example for @code{concatKimmoMorphFeatures} above.
@end ifset
@ifclear txt
@xref{concatKimmoMorphFeatures, , Example}.
@end ifclear
@subheading Source File
@file{pckfuncs.c}

@c ----------------------------------------------------------------------------
@page
@node freeKimmoLexicon, freeKimmoResult, concatKimmoMorphLexemes, Functions
@section freeKimmoLexicon
@subheading Syntax
@example
#include "kimmo.h"

void freeKimmoLexicon(KimmoData * pKimmo_io);
@end example
@subheading Description
@code{freeKimmoLexicon} frees the memory used to store the lexicon
portion of the KimmoData information.

@code{freeKimmoLexicon} has only one argument:
@table @code
@item pKimmo_io
points to the data for the current language, which includes the lexicon.
@end table
@subheading Return Value
none
@subheading Example
@smallexample
@end smallexample
#include <string.h>
#include "kimmo.h"
#include "patr.h"
...
KimmoData       sKimmoData_g;
KimmoData       sSynthesisData_g;       /* for synthesis lexicon */
...
static void reset_synthesis_data()
@{
sSynthesisData_g.bLimit               = FALSE;
sSynthesisData_g.iTraceLevel          = 0;
sSynthesisData_g.bUsePATR             = FALSE;
sSynthesisData_g.bSilent              = FALSE;
sSynthesisData_g.bShowWarnings        = FALSE;
sSynthesisData_g.bAlignment           = FALSE;
sSynthesisData_g.cGlossBegin          = '\0';
sSynthesisData_g.cGlossEnd            = '\0';
sSynthesisData_g.cComment             = '\0';
sSynthesisData_g.pLogFP               = NULL;
sSynthesisData_g.ppszAlphabet         = NULL;
sSynthesisData_g.uiAlphabetSize       = 0;
sSynthesisData_g.cNull                = '\0';
sSynthesisData_g.cAny                 = '\0';
sSynthesisData_g.cBoundary            = '\0';
sSynthesisData_g.bTwoLCFile           = FALSE;
sSynthesisData_g.pSubsets             = NULL;
sSynthesisData_g.uiSubsetCount        = 0;
sSynthesisData_g.pAutomata            = NULL;
sSynthesisData_g.uiAutomataSize       = 0;
sSynthesisData_g.pFeasiblePairs       = NULL;
sSynthesisData_g.uiFeasiblePairsCount = 0;
sSynthesisData_g.pszRulesFile         = ;
memset(&sSynthesisData_g.sPATR, 0, sizeof(PATRData));
@}

void do_clear()
@{
freeKimmoRules(&sKimmoData_g);
freeKimmoLexicon(&sKimmoData_g);
freePATRGrammar(&sKimmoData_g.sPATR);
sKimmoData_g.bUsePATR     = FALSE;
freePATRInternalMemory();
reset_synthesis_data();         /* prevent double freeing */
freeKimmoLexicon(&sSynthesisData_g);
@}
@subheading Source File
@file{lexicon.c}

@c ----------------------------------------------------------------------------
@page
@node freeKimmoResult, freeKimmoRules, freeKimmoLexicon, Functions
@section freeKimmoResult
@subheading Syntax
@example
#include "kimmo.h"

void freeKimmoResult(KimmoResult * pResults_io);
@end example
@subheading Description
@code{freeKimmoResult} frees the memory used by a list of
@code{KimmoResult} data structures.

@code{freeKimmoResult} has only one argument:
@table @code
@item pResults_io
points to a dynamically allocated list of @code{KimmoResult} data
structures.
@end table
@subheading Return Value
none
@subheading Example
@ifset txt
See the examples for @code{applyKimmoGenerator},
@code{applyKimmoRecognizer}, or @code{applyKimmoSynthesizer} above.
@end ifset
@ifclear txt
@xref{applyKimmoGenerator, , Example},
@xref{applyKimmoRecognizer, , Example}, or
@xref{applyKimmoSynthesizer, , Example}.
@end ifclear
@subheading Source File
@file{pckfuncs.c}

@c ----------------------------------------------------------------------------
@page
@node freeKimmoRules, loadKimmoLexicon, freeKimmoResult, Functions
@section freeKimmoRules
@subheading Syntax
@example
#include "kimmo.h"

void freeKimmoRules(KimmoData * pKimmo_io);
@end example
@subheading Description
@code{freeKimmoRules} frees the memory used to store the rules
portion of the KimmoData information.

@code{freeKimmoRules} has only one argument:
@table @code
@item pKimmo_io
points to the data for the current language, which includes the rules.
@end table
@subheading Return Value
none
@subheading Example
@ifset txt
See the example for @code{freeKimmoLexicon} above.
@end ifset
@ifclear txt
@xref{freeKimmoLexicon, , Example}.
@end ifclear
@subheading Source File
@file{rules.c}

@c ----------------------------------------------------------------------------
@page
@node loadKimmoLexicon, loadKimmoRules, freeKimmoRules, Functions
@section loadKimmoLexicon
@subheading Syntax
@example
#include "kimmo.h"

int loadKimmoLexicon(unsigned char * pszLexiconFile_in,
					 int             eLexiconType_in,
					 KimmoData *     pKimmo_io);
@end example
@subheading Description
@code{loadKimmoLexicon} loads a PC-Kimmo lexicon, starting with the
primary lexicon file.  If a lexicon has already been loaded, then the
existing lexicon is erased before this lexicon file is read.

The arguments to @code{loadKimmoLexicon} are as follows:
@table @code
@item pszLexiconFile_in
points to a character string containing the name of the primary lexicon
file.

@item eLexiconType_in
has one of these two values:
@table @code
@item KIMMO_ANALYSIS
means that the morphemes are accessed by lexical (underlying) form.
@item KIMMO_SYNTHESIS
means that the morphemes are accessed by morpheme name (gloss).
@end table

@item pKimmo_io
points to the data for the current language, which includes the lexicon.
@end table
@subheading Return Value
zero if successful, -1 if an error occurs
@subheading Example
@smallexample
#include "kimmo.h"
#include "patr.h"
...
KimmoData	sKimmoData_g;
...
/*
 *  load the PC-Kimmo data files.
 *  return the number of files successfully loaded (0-3)
 */
int load_kimmo_files(char * pszRules_in,
			 char * pszLexicon_in,
			 char * pszGrammar_in)
@{
if (loadKimmoRules(pszRules_in, &sKimmoData_g) != 0)
	return 0;
if (loadKimmoLexicon(pszLexicon_in,
			 KIMMO_ANALYSIS, &sKimmoData_g) != 0)
	return 1;
if (loadPATRGrammar(pszGrammar_in, &sKimmoData_g.sPATR) == 0)
	return 2;
return 3;
@}
@end smallexample
@subheading Source File
@file{file.c}

@c ----------------------------------------------------------------------------
@page
@node loadKimmoRules, setKimmoRuleStatus, loadKimmoLexicon, Functions
@section loadKimmoRules
@subheading Syntax
@example
#include "kimmo.h"

int loadKimmoRules(unsigned char * pszRuleFile_in,
				   KimmoData *     pKimmo_io);
@end example
@subheading Description
@code{loadKimmoRules} loads a PC-Kimmo rules file.  If rules have
already been loaded, then the existing rules and lexicon are erased
before this rules file is read.

The arguments to @code{loadKimmoRules} are as follows:
@table @code
@item pszRuleFile_in
points to a character string containing the name of the PC-Kimmo rules
file.

@item pKimmo_io
points to the data for the current language, which includes the rules.
@end table
@subheading Return Value
zero if okay, -1 if an error occurs
@subheading Example
@ifset txt
See the example for @code{loadKimmoLexicon} above.
@end ifset
@ifclear txt
@xref{loadKimmoLexicon, , Example}.
@end ifclear
@subheading Source File
@file{file.c}

@c ----------------------------------------------------------------------------
@page
@node setKimmoRuleStatus, writeKimmoFeasiblePairs, loadKimmoRules, Functions
@section setKimmoRuleStatus
@subheading Syntax
@example
#include "kimmo.h"

void setKimmoRuleStatus(int         iRule_in,
						int         bValue_in,
						KimmoData * pKimmo_io);
@end example
@subheading Description
@code{setKimmoRuleStatus} sets the status (active or inactive) of a
given PC-Kimmo rule.  The set of feasible pairs is automatically
recomputed as a side effect of calling this function.

The arguments to @code{setKimmoRuleStatus} are as follows:
@table @code
@item iRule_in
is the number of a loaded PC-Kimmo rule.  The first rule is numbered 1,
not 0 as in C arrays.  If @code{iRule_in} is equal to zero (@code{0}),
then all of the rules are turned on or off according to
@code{bValue_in}.

@item bValue_in
is TRUE to make the rule active, or FALSE (zero) to make the rule
inactive.

@item pKimmo_io
points to the data for the current language, which includes the rules.
@end table
@subheading Return Value
none
@subheading Example
@smallexample
#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include "kimmo.h"
#include "cportlib.h"
...
KimmoData       sKimmoData_g;
...
void do_set_rule(char * pszArgument_in, int bValue_in)
@{
int     i;
char *  pszNumber;
char *  pszNext;

if (    (strcasecmp(pszArgument_in, "all") == 0) ||
		(strcasecmp(pszArgument_in, "al")  == 0) ||
		(strcasecmp(pszArgument_in, "a")   == 0) )
	@{
	setKimmoRuleStatus(0, bValue_in, &sKimmoData_g);
	return;
	@}
for (pszNumber = pszArgument_in ; *pszNumber ; pszNumber = pszNext)
	@{
	i = strtol(pszNumber, &pszNext, 10);
	if (pszNext == pszNumber)
		break;
	if ((i > 0) && (i <= sKimmoData_g.uiAutomataSize))
		setKimmoRuleStatus(i, bValue_in, &sKimmoData_g);
	else
		break;
	@}
if (*pszNumber != '\0')
	fprintf(stderr, "Invalid argument to SET RULE: \"%s\"\n",
			pszNumber);
@}
@end smallexample
@subheading Source File
@file{file.c}

@c ----------------------------------------------------------------------------
@page
@node writeKimmoFeasiblePairs, writeKimmoLexiconSection, setKimmoRuleStatus, Functions
@section writeKimmoFeasiblePairs
@subheading Syntax
@example
#include "kimmo.h"

void writeKimmoFeasiblePairs(FILE *      pOutputFP_in,
							 KimmoData * pKimmo_in);
@end example
@subheading Description
@code{writeKimmoFeasiblePairs} writes a list of the current PC-Kimmo
feasible pairs to the output file.

The arguments to @code{writeKimmoFeasiblePairs} are as follows:
@table @code
@item pOutputFP_in
is an output @code{FILE} pointer.

@item pKimmo_in
points to the data for the current language, which includes the current set
of feasible pairs.
@end table
@subheading Return Value
none
@subheading Example
@smallexample
#include <stdio.h>
#include <string.h>
#include "kimmo.h"
extern char * strlwr P((char * pszString_io));
...
KimmoData	sKimmoData_g;
...
void do_list(char * pszArgument_in)
@{
strlwr(pszArgument_in);
if (	(strcmp(pszArgument_in, "l")       == 0) ||
	(strcmp(pszArgument_in, "lexicon") == 0) )
	writeKimmoLexiconSectionNames(stderr, &sKimmoData_g);
else if ((strcmp(pszArgument_in, "p")     == 0) ||
	 (strcmp(pszArgument_in, "pairs") == 0) )
	writeKimmoFeasiblePairs(stderr, &sKimmoData_g);
else if ((strcmp(pszArgument_in, "r")     == 0) ||
	 (strcmp(pszArgument_in, "rules") == 0) )
	writeKimmoRulesStatus(stderr, &sKimmoData_g);
else
	fprintf(stderr, "Invalid argument for list command: %s\n",
			pszArgument_in);
@}
@end smallexample
@subheading Source File
@file{rules.c}

@c ----------------------------------------------------------------------------
@page
@node writeKimmoLexiconSection, writeKimmoLexiconSectionNames, writeKimmoFeasiblePairs, Functions
@section writeKimmoLexiconSection
@subheading Syntax
@example
#include "kimmo.h"

int writeKimmoLexiconSection(unsigned char * pszLexSection_in,
							 FILE *          pOutputFP_in,
							 KimmoData *     pKimmo_in);
@end example
@subheading Description
@code{writeKimmoLexiconSection} writes the designated section of the
PC-Kimmo lexicon to the output file.  This is useful only for debugging
purposes.

The arguments to @code{writeKimmoLexiconSection} are as follows:
@table @code
@item pszLexSection_in
points to the name of a section of the PC-Kimmo lexicon.

@item pOutputFP_in
is an output @code{FILE} pointer.

@item pKimmo_in
points to the data for the current language, which includes the lexicon.
@end table
@subheading Return Value
@code{TRUE} if successful, @code{FALSE} if the lexicon section does not
exist
@subheading Example
@smallexample
#include <stdio.h>
#include "kimmo.h"
#include "cmd.h"
#include "rpterror.h"
...
KimmoData       sKimmoData_g;
...
void show_lexicon(char * pszLexName_in)
@{
if ((pszLexName_in == NULL) || (pszLexName_in[0] == '\0'))
	@{
	displayNumberedMessage(&sCmdMissingArgument_g,
						   sKimmoData_g.bSilent,
						   sKimmoData_g.bShowWarnings,
						   sKimmoData_g.pLogFP,
						   NULL, 0,
						   "SHOW LEXICON" );
	@}
else if (writeKimmoLexiconSection(pszLexName_in, stderr,
								  &sKimmoData_g) == FALSE)
	@{
	displayNumberedMessage(&sCmdBadArgument_g,
						   sKimmoData_g.bSilent,
						   sKimmoData_g.bShowWarnings,
						   sKimmoData_g.pLogFP,
						   NULL, 0,
						   "SHOW LEXICON", pszLexName_in);
	@}
@}
@end smallexample
@subheading Source File
@file{lexicon.c}

@c ----------------------------------------------------------------------------
@page
@node writeKimmoLexiconSectionNames, writeKimmoResults, writeKimmoLexiconSection, Functions
@section writeKimmoLexiconSectionNames
@subheading Syntax
@example
#include "kimmo.h"

void writeKimmoLexiconSectionNames(FILE *      pOutputFP_in,
								   KimmoData * pKimmo_in);
@end example
@subheading Description
@code{writeKimmoLexiconSectionNames} writes a list of the PC-Kimmo
lexicon section names to the output file.

The arguments to @code{writeKimmoLexiconSectionNames} are as follows:
@table @code
@item pOutputFP_in
is an output @code{FILE} pointer.

@item pKimmo_in
points to the data for the current language, which includes the lexicon.
@end table
@subheading Return Value
none
@subheading Example
@ifset txt
See the example for @code{writeKimmoFeasiblePairs} above.
@end ifset
@ifclear txt
@xref{writeKimmoFeasiblePairs, , Example}.
@end ifclear
@subheading Source File
@file{lexicon.c}

@c ----------------------------------------------------------------------------
@page
@node writeKimmoResults, writeKimmoRule, writeKimmoLexiconSectionNames, Functions
@section writeKimmoResults
@subheading Syntax
@example
#include "kimmo.h"

void writeKimmoResults(KimmoResult * pResults_in,
					   FILE *        pOutputFP_in,
					   KimmoData *   pKimmo_in);
@end example
@subheading Description
@code{writeKimmoResults} writes a list of PC-Kimmo results to the
output file.  If @code{pResults_in} is @code{NULL}, then nothing is
written to the output file.

The arguments to @code{writeKimmoResults} are as follows:
@table @code
@item pResults_in
points to a list of PC-Kimmo processing results as produced by
@code{applyKimmoGenerator}, @code{applyKimmoRecognizer}, or
@code{applyKimmoSynthesizer}.

@item pOutputFP_in
is an output @code{FILE} pointer.

@item pKimmo_in
points to the data for the current language.
@end table
@subheading Return Value
none
@subheading Example
@ifset txt
See the examples for @code{applyKimmoGenerator},
@code{applyKimmoRecognizer}, or @code{applyKimmoSynthesizer} above.
@end ifset
@ifclear txt
@xref{applyKimmoGenerator, , Example},
@xref{applyKimmoRecognizer, , Example}, or
@xref{applyKimmoSynthesizer, , Example}.
@end ifclear
@subheading Source File
@file{pckfuncs.c}

@c ----------------------------------------------------------------------------
@page
@node writeKimmoRule, writeKimmoRulesStatus, writeKimmoResults, Functions
@section writeKimmoRule
@subheading Syntax
@example
#include "kimmo.h"

void writeKimmoRule(unsigned    uiRuleNumber_in,
					FILE *      pOutputFP_in,
					KimmoData * pKimmo_in);
@end example
@subheading Description
@code{writeKimmoRule} writes the designated PC-Kimmo rule to the output
file.  This is useful only for debugging purposes.

The arguments to @code{writeKimmoRule} are as follows:
@table @code
@item uiRuleNumber_in
is the 1-based index number of a PC-Kimmo rule loaded from a rules
file.

@item pOutputFP_in
is an output @code{FILE} pointer.

@item pKimmo_in
points to the data for the current language.
@end table
@subheading Return Value
none
@subheading Example
@smallexample
#include <stdlib.h>
#include "kimmo.h"
#include "cmd.h"
...
KimmoData       sKimmoData_g;
...
void do_show_rule(char * pszArgument_in)
@{
int     k;

if (pszArgument_in == (char *)NULL)
	@{
	displayNumberedMessage(&sCmdMissingKeyword_g,
						   sKimmoData_g.bSilent,
						   sKimmoData_g.bShowWarnings,
						   sKimmoData_g.pLogFP,
						   NULL, 0,
						   "SHOW RULE");
	return;
	@}
k = atoi(pszArgument_in);
if (   (k <= 0) ||
	   (k >  sKimmoData_g.uiAutomataSize) )
	displayNumberedMessage(&sCmdBadArgument_g,
						   sKimmoData_g.bSilent,
						   sKimmoData_g.bShowWarnings,
						   sKimmoData_g.pLogFP,
						   NULL, 0,
						   "SHOW RULE", pszArgument_in);
else
	writeKimmoRule( k, stderr, &sKimmoData_g );
@}
@end smallexample
@subheading Source File
@file{rules.c}

@c ----------------------------------------------------------------------------
@page
@node writeKimmoRulesStatus, , writeKimmoRule, Functions
@section writeKimmoRulesStatus
@subheading Syntax
@example
#include "kimmo.h"

void writeKimmoRulesStatus(FILE *      pOutputFP_in,
						   KimmoData * pKimmo_in);
@end example
@subheading Description
@code{writeKimmoRulesStatus} writes the status (@code{"on"} or
@code{"off"} and name for each of the PC-Kimmo rules currently loaded
from a rules file.

The arguments to @code{writeKimmoRulesStatus} are as follows:
@table @code
@item pOutputFP_in
is an output @code{FILE} pointer.

@item pKimmo_in
points to the data for the current language, which includes the rules.
@end table
@subheading Return Value
none
@subheading Example
@ifset txt
See the example for @code{writeKimmoFeasiblePairs} above.
@end ifset
@ifclear txt
@xref{writeKimmoFeasiblePairs, , Example}.
@end ifclear
@subheading Source File
@file{file.c}

@c ----------------------------------------------------------------------------
@node Index, , Functions, Top
@chapter Index

@printindex fn
@contents
@bye
