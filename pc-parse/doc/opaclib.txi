\input pcparse % common TeX setup  @c -*-texinfo-*-
\input texinfo
@c %**start of header
@setfilename opaclib.info
@settitle OPAC function library reference
@c %**end of header

@set opaclib

@set TITLE OPAC Function Library Reference Manual
@set SUBTITLE functions for linguistic data processing
@set DATE July 1998
@set AUTHOR by Stephen McConnel
@set COPYRIGHT Copyright @copyright{} 2000 SIL International

@include front.txi

@c ----------------------------------------------------------------------------
@node    Top,       Introduction,  (dir),    (dir)
@comment node-name, next,          previous, up
@menu
* Introduction::

* Naming Conventions::

* Data Structures::

* Global Variables::

* Functions::

* Bibliography::
@end menu

@c ----------------------------------------------------------------------------
@node    Introduction, Naming Conventions, Top,      Top
@comment node-name,    next,               previous, up
@chapter Introduction to the OPAC function library

This document describes a library of data structures and functions
developed over the years for programs in the Occasional Publications in
Academic Computing series published by SIL International.  (For SIL
International, "academic" refers to linguistics, literacy, anthropology,
translation, and related fields.)  It is hoped that this documentation
will make future maintenance of these programs easier.

@c ----------------------------------------------------------------------------
@node Naming Conventions, Data Structures, Introduction, Top
@set library-name OPAC
@set library-tag a reference to the relevant OPAC data structure
@include naming.txi

@c ----------------------------------------------------------------------------
@node Data Structures, Global Variables, Naming Conventions, Top
@chapter The OPAC function library data structures

This chapter describes the data structures defined for the OPAC
function library.  These include both general purpose data collection
structures and specialized linguistic processing data structures.  For
each data structure that the library provides, this information
includes which header files to include in your source to obtain its
definition.

@menu
* CaselessLetter::
* Change::
* ChangeEnvironment::
* ChgEnvItem::
* CodeTable::
* LowerLetter::
* NumberedMessage::
* StringClass::
* StringList::
* TextControl::
* Trie::
* UpperLetter::
* WordAnalysis::
* WordTemplate::
@end menu

@c ----------------------------------------------------------------------------
@node CaselessLetter, Change, Data Structures, Data Structures
@page
@section CaselessLetter
@subheading Definition
@example
#include "textctl.h"    /* or template.h or opaclib.h */

typedef struct caseless_letter @{
	unsigned char *          pszLetter;
	struct caseless_letter * pNext;
	@} CaselessLetter;
@end example
@subheading Description
The @code{CaselessLetter} data structure is normally used only inside a
@code{TextControl} data structure.  It stores a multibyte character
string that represents a single caseless letter.

The fields of the @code{CaselessLetter} data structure are as follows:
@table @code
@item pszLetter
points to a caseless multigraph character string.  This string is one or
more characters (bytes) long, and is terminated by a NUL byte.

@item pNext
is a pointer to facilitate keeping a list of caseless letters.
@end table
@subheading Source File
@file{textctl.h}

@menu
* TextControl::
* addWordFormationChars::
* addWordFormationCharStrings::
* matchAlphaChar::
* resetWordFormationChars::
@end menu

@c ----------------------------------------------------------------------------
@node Change, ChangeEnvironment, CaselessLetter, Data Structures
@page
@section Change
@subheading Definition
@example
#include "change.h"     /* or textctl.h or template.h or opaclib.h */

typedef struct change_list @{
	char *               pszMatch;
	char *               pszReplace;
	ChangeEnvironment *  pEnvironment;
	char *               pszDescription;
	struct change_list * pNext;
	@} Change;
@end example
@subheading Description
A @code{Change} data structure stores a single ``consistent change'' to
apply to character strings.  Such consistent changes are usually used
as ordered lists of changes rather than being applied in isolation here
and there.

The fields of the @code{Change} data structure are as follows:
@table @code
@item pszMatch
points to the substring to match in the original string.

@item pszReplace
points to the string with which to replace matched substrings in the
output.

@item pEnvironment
points to the list of alternative environments (if any) for this
change.
@ifset txt
See @code{ChangeEnvironment} below.
@end ifset
@ifclear txt
@xref{ChangeEnvironment}.
@end ifclear

@item pszDescription
points to an optional comment string that describes this change.

@item pNext
is a pointer to facilitate keeping an ordered list of changes.
@end table
@subheading Source File
@file{change.h}

@menu
* TextControl::
* applyChanges::
* buildChangeString::
* freeChangeList::
* getChangeQuote::
* parseChangeString::
@end menu

@c ----------------------------------------------------------------------------
@node ChangeEnvironment, ChgEnvItem, Change, Data Structures
@page
@section ChangeEnvironment
@subheading Definition
@example
#include "change.h"     /* or textctl.h or template.h or opaclib.h */

typedef struct chg_envir @{
	short               bNot;
	ChgEnvItem *        pLeftEnv;
	ChgEnvItem *        pRightEnv;
	struct chg_envir *  pNext;
	@} ChangeEnvironment;
@end example
@subheading Description
The @code{ChangeEnvironment} data structure is normally used only
inside a @code{Change} data structure.

The fields of the @code{ChangeEnvironment} data structure are as follows:
@table @code
@item bNot
indicates the negation of this environment.

@item pLeftEnv
points to the environment to the left of the matched substring.

@item pRightEnv
points to the environment to the right of the matched substring.

@item pNext
points to the next alternative constraint.
@end table
@subheading Source File
@file{change.h}

@menu
* Change::
@end menu

@c ----------------------------------------------------------------------------
@node ChgEnvItem, CodeTable, ChangeEnvironment, Data Structures
@page
@section ChgEnvItem
@subheading Definition
@example
#include "change.h"     /* or textctl.h or template.h or opaclib.h */

typedef struct chg_env_item @{
	char                                iFlags;
	union @{ char *        pszString;
			StringClass *  pClass;   @} u;
	struct chg_env_item *               pNext;
	@} ChgEnvItem;
@end example
@subheading Description
The @code{ChgEnvItem} data structure is normally used only inside a
@code{ChangeEnvironment} data structure, which is normally used only
inside a @code{Change} data structure.

The fields of the @code{ChgEnvItem} data structure are as follows:
@table @code
@item iFlags & E_NOT
signals that this item is not wanted.
@item iFlags & E_CLASS
signals that this item refers to a class of strings instead of a
literal string.
@item iFlags & E_ELLIPSIS
signals that this item may possibly not be contiguous.
@item iFlags & E_OPTIONAL
signals that this item is optional.

@item u.pszString
points to a literal string if @w{@code{iFlags & E_CLASS}} is @code{0}.

@item u.pClass
points to a @code{StringClass} data structure if @w{@code{iFlags & E_CLASS}}
is not @code{0}.
@ifset txt
See @code{StringClass} below.
@end ifset
@ifclear txt
@xref{StringClass}.
@end ifclear

@item pNext
points to the next item in the environment, if any.
@end table
@subheading Source File
@file{change.h}

@menu
* ChangeEnvironment::
@end menu

@c ----------------------------------------------------------------------------
@node CodeTable, LowerLetter, ChgEnvItem, Data Structures
@page
@section CodeTable
@subheading Definition
@example
#include "record.h"     /* or opaclib.h */

typedef struct @{
	char *      pCodeTable;
	unsigned    uiCodeCount;
	char *      pszFirstCode;
	@} CodeTable;
@end example
@subheading Description
The @code{CodeTable} data structure is used to map between the field
codes used in a standard format file and single characters used in
@code{case} labels inside @code{switch} statements in C code.

The fields of the @code{CodeTable} data structure are as follows:
@table @code
@item pCodeTable
points to a primitive change string such as
@w{@code{"match1\0A\0match2\0B\0"}}.  Note that the replacement strings
are assumed to be single characters.

@item uiCodeCount
is the number of entries (match strings with replacement characters) in
@code{pCodeTable}.

@item pszFirstCode
points to the record marker string, that is, the field code that marks
the beginning of a record in the input file.  This would usually be one
of the match strings embedded in @code{pCodeTable}.
@end table
@subheading Source File
@file{record.h}

@menu
* freeCodeTable::
* readStdFormatRecord::
* writeCodeTable::
@end menu

@c ----------------------------------------------------------------------------
@node LowerLetter, NumberedMessage, CodeTable, Data Structures
@page
@section LowerLetter
@subheading Definition
@example
#include "textctl.h"    /* or template.h or opaclib.h */

typedef struct lower_letter @{
	unsigned char *       pszLower;
	StringList *          pUpperList;
	struct lower_letter * pNext;
	@} LowerLetter;
@end example
@subheading Description
The @code{LowerLetter} data structure is normally used only inside a
@code{TextControl} data structure.  It stores a multibyte character
string that represents a single lowercase letter.  It also stores a list
of the corresponding uppercase multigraph character strings.

The fields of the @code{NumberedMessage} data structure are as follows:
@table @code
@item pszLower
points to a lowercase multigraph character string.  This string is one or
more characters (bytes) long, and is terminated by a NUL byte.

@item pUpperList
points to a list of uppercase multigraph character strings.  This list
has at least one element, but may have any number of elements if the
orthography is ambiguous about converting from lowercase to uppercase
forms.  (This is quite unlikely, but allowed by this software.)

@item pNext
is a pointer to facilitate keeping a list of lowercase letters.
@end table
@subheading Source File
@file{textctl.h}

@menu
* TextControl::
* addLowerUpperWFChars::
* addLowerUpperWFCharStrings::
* convLowerToUpper::
* convLowerToUpperSet::
* matchAlphaChar::
* matchLowercaseChar::
* resetWordFormationChars::
@end menu

@c ----------------------------------------------------------------------------
@node NumberedMessage, StringClass, LowerLetter, Data Structures
@page
@section NumberedMessage
@subheading Definition
@example
#include "rpterror.h"   /* or opaclib.h */

typedef struct @{
	int         eType;
	unsigned    uiNumber;
	char *      pszMessage;
	@} NumberedMessage;
@end example
@subheading Description
The @code{NumberedMessage} data structure stores the information for a
single numbered error or warning message.  This is the style of error
reporting used by the PC-Kimmo and PC-PATR programs.

The fields of the @code{NumberedMessage} data structure are as follows:
@table @code
@item eType
is the type of message, one of these symbolic constants:
@table @code
@item ERROR_MSG
is a severe error that aborts the procedure.
@item WARNING_MSG
is a minor error that user should be made aware of.
@item DEBUG_MSG
is a debugging message intended for the programmer.
@end table

@item uiNumber
is the (unique) message number.

@item pszMessage
is a @code{printf} style format string for the message.
@end table
@subheading Source File
@file{rpterror.h}

@menu
* displayNumberedMessage::
@end menu

@c ----------------------------------------------------------------------------
@node StringClass, StringList, NumberedMessage, Data Structures
@page
@section StringClass
@subheading Definition
@example
#include "strclass.h"   /* or change.h or textctl.h or template.h
						   or opaclib.h */

typedef struct string_class @{
	char *                pszName;
	StringList *          pMembers;
	struct string_class * pNext;
	@} StringClass;
@end example
@subheading Description
The @code{StringClass} data structure stores a labeled set of strings.
The intention is that any one of the set of strings may be used in a
matching operation.

The fields of the @code{StringClass} data structure are as follows:
@table @code
@item pszName
points to the name of the string class.

@item pMembers
points to the list of members of the string class.
@ifset txt
See @code{StringList} below.
@end ifset
@ifclear txt
@xref{StringList}.
@end ifclear

@item pNext
is a pointer to facilitate keeping a list of string classes.
@end table
@subheading Source File
@file{strclass.h}

@menu
* ChgEnvItem::
* addStringClass::
* findStringClass::
* freeStringClasses::
* isStringClassMember::
* loadIntxCtlFile::
* loadOutxCtlFile::
* matchBeginWithStringClass::
* matchEndWithStringClass::
* parseChangeString::
* writeStringClasses::
@end menu

@c ----------------------------------------------------------------------------
@node StringList, TextControl, StringClass, Data Structures
@page
@section StringList
@subheading Definition
@example
#include "strlist.h"    /* or strclass.h or change.h or textctl.h
						   or template.h or opaclib.h */

typedef struct strlist
	@{
	char *              pszString;
	struct strlist *    pNext;
	@} StringList;
@end example
@subheading Description
The @code{StringList} data structure is used to store a collection of
character strings.  This collection may be a set (no duplicate
strings), an ordered list, or an unordered list, depending on how the
programmer adds strings to the list.

The fields of the @code{StringList} data structure are as follows:
@table @code
@item pszString
points to a stored string.

@item pNext
points to the next string in the list of strings.
@end table
@noindent
This is one of the most commonly used data structures in the OPAC
function library.
@subheading Source File
@file{strlist.h}

@menu
* StringClass::
* TextControl::
* WordTemplate::
* duplicateStringList::
* equivalentStringLists::
* freeStringList::
* getStringListSize::
* identicalStringLists::
* isMemberOfStringList::
* mergeIntoStringList::
* mergeIntoStringListAtEnd::
* mergeTwoStringLists::
* removeFromStringList::
* squeezeStringList::
* unlinkStringList::
* updateStringList::
* writeStringList::
@end menu

@c ----------------------------------------------------------------------------
@node TextControl, Trie, StringList, Data Structures
@page
@section TextControl
@subheading Definition
@example
#include "textctl.h"    /* or template.h or opaclib.h */

typedef struct text_control @{
	char *              pszTextControlFile;
	LowerLetter *       pLowercaseLetters;
	UpperLetter *       pUppercaseLetters;
	CaselessLetter *    pCaselessLetters;
	Change *            pOrthoChanges;
	Change *            pOutputChanges;
	StringList *        pIncludeFields;
	StringList *        pExcludeFields;
	unsigned char       cFormatMark;
	unsigned char       cAmbig;
	unsigned char       cDecomp;
	unsigned char       cBarMark;
	unsigned char *     pszBarCodes;
	char                bIndividualCapitalize;
	char                bCapitalize;
	unsigned            uiMaxAmbigDecap;
	@} TextControl;
@end example
@subheading Description
The @code{TextControl} data structure is used to control reading a text
file into a (sequence of) @code{WordTemplate} data structure(s), or
writing a (sequence of) @code{WordTemplate} data structure(s) to a text
file.

The fields of the @code{TextControl} data structure are as follows:
@table @code
@item pszTextControlFile
points to the name of the file that the data is loaded from.

@item pLowercaseLetters
points to a list of lowercase word formation character multigraphs, each
of which has a list of one or more corresponding uppercase multigraphs.
This list is sorted by decreasing length of the lowercase multigraph
string.
@ifset txt
See @code{LowerLetter} above.
@end ifset
@ifclear txt
@xref{LowerLetter}.
@end ifclear

@item pUppercaseLetters
points to a list of lowercase word formation character multigraphs, each
of which has a list of one or more corresponding uppercase multigraphs.
This list is sorted by decreasing length of the uppercase multigraph
string.
@ifset txt
See @code{UpperLetter} below.
@end ifset
@ifclear txt
@xref{UpperLetter}.
@end ifclear

@item pCaselessLetters
points to a list of word formation character multigraphs that do not have
distinct lowercase and uppercase forms.  This list is sorted by
decreasing length of the multigraph string.
@ifset txt
See @code{CaselessLetter} above.
@end ifset
@ifclear txt
@xref{CaselessLetter}.
@end ifclear

@item pOrthoChanges
points to an ordered list of input orthography changes.
@ifset txt
See @code{Change} above.
@end ifset
@ifclear txt
@xref{Change}.
@end ifclear

@item pOutputChanges
points to an ordered list of output (orthography) changes.
@ifset txt
See @code{Change} above.
@end ifset
@ifclear txt
@xref{Change}.
@end ifclear

@item pIncludeFields
points to a list of format markers (fields) to include.
@ifset txt
See @code{StringList} above.
@end ifset
@ifclear txt
@xref{StringList}.
@end ifclear

@item pExcludeFields
points to a list of format markers (fields) to exclude.
@ifset txt
See @code{StringList} above.
@end ifset
@ifclear txt
@xref{StringList}.
@end ifclear

@item cFormatMark
is the initial character of format markers.

@item cAmbig
is the character for marking ambiguities and failures.

@item cDecomp
is the character for marking decomposition of words into morphemes.

@item cBarMark
is the initial character of secondary format markers.

@item pszBarCodes
points to a string of characters for secondary format markers.

@item bIndividualCapitalize
flags whether or not to capitalize individual letters within words.

@item bCapitalize
flags whether or not to decapitalize (recapitalize) words.

@item uiMaxAmbigDecap
is the maximum number of ambiguous decapitalizations allowed.
@end table
@subheading Source File
@file{textctl.h}

@menu
* addLowerUpperWFChars::
* addLowerUpperWFCharStrings::
* addWordFormationChars::
* addWordFormationCharStrings::
* convLowerToUpper::
* convLowerToUpperSet::
* convUpperToLower::
* convUpperToLowerSet::
* decapitalizeWord::
* fixSynthesizedWord::
* loadIntxCtlFile::
* loadOutxCtlFile::
* matchAlphaChar::
* matchCaselessChar::
* matchLowercaseChar::
* matchUppercaseChar::
* recapitalizeWord::
* resetTextControl::
* resetWordFormationChars::
* writeWordFormationChars::
@end menu

@c ----------------------------------------------------------------------------
@node Trie, UpperLetter, TextControl, Data Structures
@page
@section Trie
@subheading Definition
@example
#include "trie.h"       /* or opaclib.h */

typedef struct s__trienode
	@{
	unsigned char        cLetter;
	struct s__trienode * pChildren;
	struct s__trienode * pSiblings;
	void *               pTrieInfo;
	@} Trie;
@end example
@subheading Description
A trie is a data structure designed for relatively fast insertion and
relatively fast retrieval of information referenced by a ``key'' string.
See Knuth 1973, pages 481@value{endash}505, for an extended treatment of
tries.

The fields of the @code{Trie} data structure are as follows:
@table @code
@item cLetter
is the letter (key character) at this node.

@item pChildren
points to the children Trie nodes, those that have @code{cLetter} in
their key at this point.

@item pSiblings
points to the sibling Trie nodes, those that have an alternative to
@code{cLetter} in their key at this point.

@item pTrieInfo
points to the stored information, which may be a linked list, an array,
or anything the programmer desires.
@end table
@subheading Source File
@file{trie.h}

@menu
* addDataToTrie::
* eraseTrie::
* findDataInTrie::
* removeDataFromTrie::
* walkTrie::
* writeTrieData::
@end menu

@c ----------------------------------------------------------------------------
@node UpperLetter, WordAnalysis, Trie, Data Structures
@page
@section UpperLetter
@subheading Definition
@example
#include "textctl.h"    /* or template.h or opaclib.h */

typedef struct upper_letter @{
	unsigned char *       pszUpper;
	StringList *          pLowerList;
	struct upper_letter * pNext;
	@} UpperLetter;
@end example
@subheading Description
The @code{UpperLetter} data structure is normally used only inside a
@code{TextControl} data structure.  It stores a multibyte character
string that represents a single uppercase letter.  It also stores a list
of the corresponding lowercase multigraph character strings.

The fields of the @code{NumberedMessage} data structure are as follows:
@table @code
@item pszUpper
points to a uppercase multigraph character string.  This string is one or
more characters (bytes) long, and is terminated by a NUL byte.

@item pLowerList
points to a list of lowercase multigraph character strings.  This list
has at least one element, but may have any number of elements if the
orthography is ambiguous about converting from uppercase to lowercase
forms.

@item pNext
is a pointer to facilitate keeping a list of uppercase letters.
@end table

Application programmers should not need to use this data structure
directly, as its only use is for a list embedded in the
@code{TextControl} data structure.
@subheading Source File
@file{textctl.h}

@menu
* TextControl::
* addLowerUpperWFChars::
* addLowerUpperWFCharStrings::
* convUpperToLower::
* convUpperToLowerSet::
* matchAlphaChar::
* matchUppercaseChar::
* resetWordFormationChars::
@end menu

@c ----------------------------------------------------------------------------
@node WordAnalysis, WordTemplate, UpperLetter, Data Structures
@page
@section WordAnalysis
@subheading Definition
@example
#include "template.h"   /* or opaclib.h */

typedef struct word_analysis @{
	char *                 pszAnalysis;
	char *                 pszDecomposition;
	char *                 pszCategory;
	char *                 pszProperties;
	char *                 pszFeatures;
	char *                 pszUnderlyingForm;
	char *                 pszSurfaceForm;
	struct word_analysis * pNext;
	@} WordAnalysis;
@end example
@subheading Description
The @code{WordAnalysis} data structure is normally used a part of a
@code{WordTemplate} data structure to record the result of
morphological analysis.

The fields of the @code{WordAnalysis} data structure are as follows:
@table @code
@item pszAnalysis
points to an analysis (morphname) string.

@item pszDecomposition
points to the surface form of the word, hyphenated to show morpheme
breaks.  The ``hyphen'' character is typically the one given by the
@code{cDecomp} field of a @code{TextControl} data structure.

@item pszCategory
points to the probable word category, possibly followed by morpheme
categories.  Categories within a morpheme are separated by spaces, and
morphemes are separated by equal signs (@code{=}).

@item pszProperties
points to the morpheme properties, if any.  Properties within a
morpheme are separated by spaces, and morphemes are separated by equal
signs (@code{=}).

@item pszFeatures
points to the morpheme features, if any.  Features within a morpheme
are separated by spaces, and morphemes are separated by equal signs
(@code{=}).

@item pszUnderlyingForm
points to the underlying morpheme forms, separated by the character
given by the @code{cDecomp} field of a @code{TextControl} data
structure.

@item pszSurfaceForm
points to the wordform after decapitalization and orthography changes.

@item pNext
is a pointer to facilitate keeping a list of alternative analyses.
@end table
@subheading Source File
@file{template.h}

@menu
* WordTemplate::
@end menu

@c ----------------------------------------------------------------------------
@node WordTemplate, , WordAnalysis, Data Structures
@page
@section WordTemplate
@subheading Definition
@example
typedef struct @{
	char *          pszFormat;
	char *          pszOrigWord;
	char **         paWord;
	char *          pszNonAlpha;
	short           iCapital;
	short           iOutputFlags;
	WordAnalysis *  pAnalyses;
	StringList *    pNewWords;
	@} WordTemplate;
@end example
@subheading Description
The @code{WordTemplate} data structure is used to hold a single word
for processing, with the original capitalization and punctuation
preserved for restoration on output.

The fields of the @code{WordTemplate} data structure are as follows:
@table @code
@item pszFormat
points to a string that contains any ``formatting'' (non-word)
information prior to the word.

@item pszOrigWord
points to a string containing the original input word.

@item paWord
points to a @code{NULL}-terminated array of alternative surface forms
after decapitalization and orthography changes.

@item pszNonAlpha
points to a string containing any ``formatting'' (non-word) information
following the word.

@item iCapital
is a capitalization flag with one of the following values:
@table @code
@item NOCAP
indicates that there are not uppercase letters in the word.
@item INITCAP
indicates that only the first letter of the word (that can be
upppercase) is uppercase.
@item ALLCAP
indicates that there are no lowercase letters in the word, and two or
more uppercase letters.
@item 4@value{endash}65535
indicates that the word is ``mixed case'', not describable by one of
the standard three values.  The number can be interpreted as a bit
vector, where @code{4} is the first letter being capitalized, @code{8}
is the second letter being capitalized, and so on.  This scheme handles
only the first 14 characters of the word.
@end table

@item iOutputFlags & WANT_DECOMPOSITION
causes the decomposition fields (@code{pAnalyses->pszDecomposition}) to
be written to an output file if set (nonzero).
@item iOutputFlags & WANT_CATEGORY
causes the category fields (@code{pAnalyses->pszCategory}) to be
written to an output file if set.
@item iOutputFlags & WANT_PROPERTIES
causes the property fields (@code{pAnalyses->pszProperties}) to be
written to an output file if set.
@item iOutputFlags & WANT_FEATURES
causes the feature descriptor fields (@code{pAnalyses->pszFeatures}) to
be written to an output file if set.
@item iOutputFlags & WANT_UNDERLYING
causes the underlying form fields (@code{pAnalyses->pszUnderlyingForm})
to be written to an output file if set.
@item iOutputFlags & WANT_ORIGINAL
causes the original word (@code{pszOrigWord}) to be written to an
output file if set.

@item pAnalyses
points to a list of morphological parses produced by analysis
functions, and possibly modified by transfer functions.
@ifset txt
See @code{WordAnalysis} above.
@end ifset
@ifclear txt
@xref{WordAnalysis}.
@end ifclear

@item pNewWords
points to a list of wordforms created by synthesis functions.
@ifset txt
See @code{StringList} above.
@end ifset
@ifclear txt
@xref{StringList}.
@end ifclear
@end table
@subheading Source File
@file{template.h}

@menu
* decapitalizeWord::
* fixSynthesizedWord::
* freeWordTemplate::
* readSentenceOfTemplates::
* readTemplateFromAnalysis::
* readTemplateFromText::
* readTemplateFromTextString::
* writeTemplate::
* writeTextFromTemplate::
@end menu

@c ----------------------------------------------------------------------------
@node Global Variables, Functions, Data Structures, Top
@chapter The OPAC function library global variables

This chapter gives the proper usage information about each of the
global variables found in the OPAC function library.  For each global
variable that the library provides, this information includes which
header files to include in your source to obtain the extern declaration
for that variable.

@menu
* pfOutOfMemory_g::
* pRecordBuffer_g::
* szOutOfMemoryMarker_g::
* szRecordKey_g::
* uiRecordBufferSize_g::
* uiTrieArrayBlockSize_g::
@end menu

@c ----------------------------------------------------------------------------
@node pfOutOfMemory_g, pRecordBuffer_g, Global Variables, Global Variables
@page
@section pfOutOfMemory_g
@subheading Syntax
@example
#include "allocmem.h"   /* or opaclib.h */

extern void (* pfOutOfMemory_g)(size_t uiSize_in);
@end example
@subheading Description
@code{pfOutOfMemory_g} points to a function used by @code{allocMemory}
and related functions whenever @code{malloc} or @code{realloc} return a
@code{NULL}.  This function has one argument, the size of the
allocation request that failed.  It is assumed that this function does
not return normally, so that programs that use @code{allocMemory} do
not need to check for a successful memory allocation.  This can be
satisfied either by aborting the program or by judicious use of
@code{setjmp} and @code{longjmp}.

The default value for @code{pfOutOfMemory_g} is @code{NULL}.
This causes a function to be used which simply displays an error
message (using @code{szOutOfMemoryMarker_g}) and aborts the program.
@subheading Example
@smallexample
#include <stdio.h>
#include <setjmp.h>
#include "allocmem.h"
...
static jmp_buf jmpNoMemory_m;

static void out_of_memory(uiRequest_in)
size_t uiRequest_in;
@{
fprintf(stderr,
		"Out of memory requesting %lu bytes---trying to recover",
		(unsigned long)uiRequest_in);
longjmp( jmpNoMemory_m, 1 );
@}

char * processData()
@{
char *  p;

if (setjmp( jmpNoMemory_m ))
	@{
	/* free any memory left hanging in mid air */
	...
	return NULL;
	@}
pfOutOfMemory_g = out_of_memory;
p = processSafely();
pfOutOfMemory_g = NULL;         /* restore default behavior */
return p;
@}
@end smallexample
@subheading Source File
@file{allocmem.c}

@menu
* allocMemory::
* duplicateString::
* fitAllocStringExactly::
* reallocMemory::
@end menu

@c ----------------------------------------------------------------------------
@node pRecordBuffer_g, szOutOfMemoryMarker_g, pfOutOfMemory_g, Global Variables
@page
@section pRecordBuffer_g
@subheading Syntax
@example
#include "record.h"     /* or opaclib.h */

extern char * pRecordBuffer_g;
@end example
@subheading Description
@code{pRecordBuffer_g} points to the dynamically allocated buffer used
by @code{readStdFormatRecord} for its return value.  Allocating this
buffer is handled automatically (but perhaps not optimally) if the
programmer does not allocate it explicitly.
@subheading Example
@smallexample
#include "record.h"
#include "allocmem.h"
#define BIG_RECSIZE     16000
#define SMALL_RECSIZE     500
...
/*
 *  allocate space for records
 */
pRecordBuffer_g      = (char *)allocMemory( BIG_RECSIZE );
uiRecordBufferSize_g = BIG_RECSIZE;
...
/*
 *  reduce amount of memory allocated for records
 */
freeMemory( pRecordBuffer_g );
pRecordBuffer_g = (char *)allocMemory( SMALL_RECSIZE );
uiRecordBufferSize_g = SMALL_RECSIZE;
...
/*
 *  release memory allocated for records
 */
cleanupAfterStdFormatRecord();
@end smallexample
@subheading Source File
@file{record.c}

@menu
* cleanupAfterStdFormatRecord::
* readStdFormatRecord::
@end menu

@c ----------------------------------------------------------------------------
@node szOutOfMemoryMarker_g, szRecordKey_g, pRecordBuffer_g, Global Variables
@page
@section szOutOfMemoryMarker_g
@subheading Syntax
@example
#include "allocmem.h"   /* or opaclib.h */

extern char szOutOfMemoryMarker_g[/*101*/];
@end example
@subheading Description
@code{szOutOfMemoryMarker_g} is a character array used by
@code{allocMemory} and friends whenever @code{malloc} or @code{realloc}
return a @code{NULL} and @code{pfOutOfMemory_g} is @code{NULL}.  The
contents of the character array are used as part of the error message
notifying the user that a request for more memory has failed.

The default value for @code{szOutOfMemoryMarker_g} is to be empty (all
@code{NUL} bytes).  This means that no context sensitive information is
provided in the error message displayed just before the program aborts.
@subheading Example
@smallexample
#include "allocmem.h"
...
int *   piArray;
...
strncpy(szOutOfMemoryMarker_g, "creating huge array", 100);
piArray = allocMemory( 100000 * sizeof(int) );
@end smallexample
@subheading Source File
@file{allocmem.c}

@menu
* allocMemory::
* duplicateString::
* fitAllocStringExactly::
* reallocMemory::
@end menu

@c ----------------------------------------------------------------------------
@node szRecordKey_g, uiRecordBufferSize_g, szOutOfMemoryMarker_g, Global Variables
@page
@section szRecordKey_g
@subheading Syntax
@example
#include "record.h"     /* or opaclib.h */
/*#define MAX_RECKEY_SIZE 64*/

extern char szRecordKey_g[MAX_RECKEY_SIZE];
@end example
@subheading Description
@code{readStdFormatRecord} stores the first @code{MAX_RECKEY_SIZE-1}
characters following the record marker in @code{szRecordKey_g}.  This
may or may not be useful information.
@subheading Example
@smallexample
#include <stdio.h>
#include "record.h"
#include "rpterror.h"
...
void load_dictionary(
	char *      pszInputFile_in,
	CodeTable * pCodeTable_in,
	int         cComment_in)
@{
FILE *          pInputFP;
char *          pRecord;
char *          pszField;
char *          pszNextField;
unsigned        uiRecordCount = 0;

pInputFP = fopen(pszInputFile_in, "r");
if (pInputFP == NULL)
	@{
	reportError(WARNING_MSG, "Cannot open dictionary file %s\n",
				pszInputFile_in);
	return;
	@}
while ((pRecord = readStdFormatRecord(pInputFP,
									  pCodeTable_in,
									  cComment_in,
									  &uiRecordCount)) != NULL)
	@{
	pszField = pRecord;
	while (*pszField)
		@{
		pszNextField = pszField + strlen(pszField) + 1;
		switch (*pszField)
			@{
			case 'A':
				...
				break;
			case 'B':
				...
				break;
			...
			default:
				reportError(WARNING_MSG,
			"Warning: unrecognized field in record %u (%s)\n%s\n",
					uiRecordCount, szRecordKey_in, pszField);
				break;
			@}
		...
		pszField = pszNextField;
		@}
	...
	@}
cleanupAfterStdFormatRecord();
fclose(pInputFP);
...
@}
@end smallexample
@subheading Source File
@file{record.c}

@menu
* readStdFormatRecord::
@end menu

@c ----------------------------------------------------------------------------
@node uiRecordBufferSize_g, uiTrieArrayBlockSize_g, szRecordKey_g, Global Variables
@page
@section uiRecordBufferSize_g
@subheading Syntax
@example
#include "record.h"     /* or opaclib.h */

extern unsigned uiRecordBufferSize_g;
@end example
@subheading Description
@code{uiRecordBufferSize_g} stores the number of bytes allocated for
@code{pRecordBuffer_g}.
@subheading Example
@ifset txt
See the example for @code{pRecordBuffer_g} above.
@end ifset
@ifclear txt
@xref{pRecordBuffer_g, , Example}.
@end ifclear
@subheading Source File
@file{record.c}

@menu
* cleanupAfterStdFormatRecord::
* readStdFormatRecord::
@end menu

@c ----------------------------------------------------------------------------
@node uiTrieArrayBlockSize_g, , uiRecordBufferSize_g, Global Variables
@page
@section uiTrieArrayBlockSize_g
@subheading Syntax
@example
#include "trie.h"       /* or opaclib.h */

extern size_t uiTrieArrayBlockSize_g;
@end example
@subheading Description
@code{Trie} nodes are allocated @code{uiTrieArrayBlockSize_g} nodes at
a time for efficiency.
The default value for @code{uiTrieArrayBlockSize_g} is 2000, which
minimizes the number of calls to @code{allocateMemory}, but potentially
wastes several thousand bytes of memory.
@subheading Example
@smallexample
#include "strlist.h"
#include "trie.h"
...
Trie *          pLexicon = NULL;
StringList *    pNewString;
...
VOIDP addStringToList(VOIDP pNew_in, VOIDP pList_in)
@{
StringList *    pList = pList_in;
StringList *    pNew  = pNew_in;

pNew->pNext = pList;
return pNew;
@}
...
uiTrieArrayBlockSize_g = 63;    /* less time efficient, but
								   more space efficient */
...
pNewString = mergeIntoStringList(NULL, "Test value");
pLexicon = addDataToTrie(pLexicon, pNewString->pszString, pNewString,
						 addStringToList, 3);
@end smallexample
@subheading Source File
@file{trie.c}

@menu
* addDataToTrie::
* eraseTrie::
@end menu

@c ----------------------------------------------------------------------------
@node Functions, Bibliography, Global Variables, Top
@chapter The OPAC functions

This chapter gives the proper usage information about each of the
functions found in the OPAC function library.  For each function that
the library provides, this information includes which header files to
include in your source to obtain prototypes and type definitions
relevent to the use of that function.

@menu
* addDataToTrie::
* addLowerUpperWFChars::
* addLowerUpperWFCharStrings::
* addStringClass::
* addToStringList::
* addWordFormationChars::
* addWordFormationCharStrings::
* allocMemory::
* applyChanges::
* buildAdjustedFilename::
* buildChangeString::
* checkFileError::
* cleanupAfterStdFormatRecord::
* convLowerToUpper::
* convLowerToUpperSet::
* convUpperToLower::
* convUpperToLowerSet::
* decapitalizeWord::
* displayNumberedMessage::
* duplicateString::
* duplicateStringList::
* equivalentStringLists::
* eraseCharsInString::
* eraseTrie::
* exitSafely::
* fcloseWithErrorCheck::
* findDataInTrie::
* findStringClass::
* fitAllocStringExactly::
* fixSynthesizedWord::
* fopenAlways::
* freeChangeList::
* freeCodeTable::
* freeMemory::
* freeStringClasses::
* freeStringList::
* freeWordAnalysisList::
* freeWordTemplate::
* getAndClearAllocMemorySum::
* getChangeQuote::
* getStringListSize::
* identicalStringLists::
* isMemberOfStringList::
* isolateWord::
* isStringClassMember::
* loadIntxCtlFile::
* loadOutxCtlFile::
* matchAlphaChar::
* matchBeginning::
* matchBeginWithStringClass::
* matchCaselessChar::
* matchEnd::
* matchEndWithStringClass::
* matchLowercaseChar::
* matchUppercaseChar::
* mergeIntoStringList::
* mergeIntoStringListAtEnd::
* mergeTwoStringLists::
* parseChangeString::
* promptUser::
* readLineFromFile::
* readSentenceOfTemplates::
* readStdFormatField::
* readStdFormatRecord::
* readTemplateFromAnalysis::
* readTemplateFromText::
* readTemplateFromTextString::
* reallocMemory::
* recapitalizeWord::
* removeDataFromTrie::
* removeFromStringList::
* reportError::
* reportMessage::
* reportProgress::
* resetTextControl::
* resetWordFormationChars::
* setAllocMemoryTracing::
* setAllocMemoryTrap::
* showAmbiguousProgress::
* squeezeStringList::
* tokenizeString::
* trimTrailingWhitespace::
* unlinkStringList::
* updateStringList::
* walkTrie::
* writeAllocMemoryDebugMsg::
* writeChange::
* writeCodeTable::
* writeStringClasses::
* writeStringList::
* writeTemplate::
* writeTextFromTemplate::
* writeTrieData::
* writeWordAnalysisList::
* writeWordFormationChars::
@end menu

@c ----------------------------------------------------------------------------
@node addDataToTrie, addLowerUpperWFChars, Functions, Functions
@page
@section addDataToTrie
@subheading Syntax
@example
#include "trie.h"       /* or opaclib.h */

Trie * addDataToTrie(Trie *       pTrieHead_io,
					 const char * pszKey_in,
					 void *       pInfo_in,
					 void * (*    pfLinkInfo_in)(void * pNew_in,
												 void * pList_io),
					 int          iMaxTrieDepth_in);
@end example
@subheading Description
@code{addDataToTrie} adds information to a trie, using the given
insertion key.

The arguments to @code{addDataToTrie} are as follows:
@table @code
@item pTrieHead_io
points to the head of a trie.  This may be @code{NULL} the first time
@code{addDataToTrie} is called.  Each subsequent call should use the
value returned by the preceding call.

@item pszKey_in
points to the insertion key (a character string).

@item pInfo_in
points to a generic data structure.  The exact definition depends on
the application using the @code{Trie} for data storage and retrieval.

@item pfLinkInfo_in
points to a function for adding information to the @code{pTrieInfo}
field of the leaf @code{Trie} data structure found or created for this
key.  The function has two arguments:
@table @code
@item pNew_in
points to a single data item to store.
@item pList_io
points to a collection of items stored at a @code{Trie} node
(@code{Trieinfo}), or is @code{NULL}.
@end table
@noindent
The function returns the updated pointer to the data collection for
storing as the value of @code{pTrieInfo}.

@item iMaxTrieDepth_in
is the maximum depth to which the trie is built.  If this is less than
the maximum length of key strings, then the data structure stored in
the trie must include the key as one of its elements for future
reference.
@end table
@subheading Return Value
a pointer to the head of the modified trie
@subheading Example
@smallexample
#include <stdio.h>
#include <string.h>
#include "trie.h"
#include "rpterror.h"
#include "allocmem.h"
...
typedef struct lex_item @{
	struct lex_item *   pLink;          /* link to next item */
	struct lex_item *   pNext;          /* link to next homograph */
	unsigned char *     pszForm;        /* lexical form (word) */
	unsigned char *     pszGloss;       /* lexical gloss */
	unsigned short      uiCategory;     /* lexical category */
	@} LexItem;
...
Trie *          pLexicon_g;
unsigned long   uiLexiconCount_g;
static char     szWhitespace_m[7] = " \t\r\n\f\v";
...
static void * add_lex_item(void * pNew_in, void * pList_in)
@{
LexItem *       pLex;
/*
 *  be a little paranoid
 */
if (pNew_in == NULL)
	return pList_in;
/*
 *  link the list of items that start out the same
 */
((LexItem *)pNew_in)->pLink = (LexItem *)pList_in;
/*
 *  link the list of homographs
 */
for ( pLex = (LexItem *)pList_in ; pLex ; pLex = pLex->pLink )
	@{
	if (strcmp(((LexItem *)pNew_in)->pszForm, pLex->pszForm) == 0)
		@{
		((LexItem *)pNew_in)->pNext = pLex;
		break;
		@}
	@}
return pNew_in;
@}

void load_lexicon(char * pszLexiconFile_in)
@{
FILE *          pLexiconFP;
char            szBuffer[512];
char *          pszForm;
char *          pszGloss;
char *          pszCategory;
LexItem *       pLexItem;

if (pszLexiconFile_in == NULL)
	@{
	reportError(WARNING_MSG, "Missing input lexicon filename\n");
	return;
	@}
pLexiconFP = fopen(pszLexiconFile_in, "r");
if (pLexiconFP == NULL)
	@{
	reportError(WARNING_MSG, "Cannot open lexicon file %s for input\n",
				pszLexiconFile_in);
	return;
	@}
while (fgets(szBuffer, 512, pLexiconFP) != NULL)
	@{
	pszForm     = strtok(szBuffer, szWhitespace_m);
	pszGloss    = strtok(NULL,     szWhitespace_m);
	pszCategory = strtok(NULL,     szWhitespace_m);
	if (    (pszForm     == NULL) ||
			(pszGloss    == NULL) ||
			(pszCategory == NULL) )
		continue;

	pLexItem = (LexItem *)allocateMemory((unsigned)sizeof(LexItem));
	pLexItem->pLink      = NULL;
	pLexItem->pNext      = NULL;
	pLexItem->pszForm    = duplicateString(pszForm);
	pLexItem->pszGloss   = duplicateString(pszGloss);
	pLexItem->uiCategory = index_lexical_category(pszCategory);

	pLexicon_g = addDataToTrie(pLexicon_g, pszForm, pLexItem,
							   add_lex_item, 3);
	++uiLexiconCount_g;
	@}
fclose(pLexiconFP);
@}
@end smallexample
@subheading Source File
@file{trie.c}

@c ----------------------------------------------------------------------------
@node addLowerUpperWFChars, addLowerUpperWFCharStrings, addDataToTrie, Functions
@page
@section addLowerUpperWFChars
@subheading Syntax
@example
#include "textctl.h"    /* or template.h or opaclib.h */

void addLowerUpperWFChars(char *        pszLUPairs_in,
						  TextControl * pTextCtl_io);
@end example
@subheading Description
@code{addLowerUpperWFChars} scans the input string for character pairs.
The first member of each pair is added to the set of (multibyte)
lowercase alphabetic characters, and the second member is added to the
set of (multibyte) uppercase alphabetic characters.  Note that there may
be a many-to-many mapping between lowercase and uppercase characters.

The arguments to @code{addLowerUpperWFChars} are as follows:
@table @code
@item pszLUPairs_in
points to a string containing lowercase/UPPERCASE character pairs.
Whitespace characters in the string are ignored.

@item pTextCtl_io
points to a data structure that contains orthographic information,
including the mappings between lowercase and uppercase letters.
@end table
@subheading Return Value
none
@subheading Example
@smallexample
#include "textctl.h"
...
TextControl sTextInputCtl_m;
...
void set_alphabetic(pszField_in)
char *  pszField_in;
@{
int     code;
char *  psz;

psz  = pszField_in;
code = *psz++;
switch (code)
	@{
	case 'A':   /* alphabetic (word formation) characters */
		addWordFormationChars(psz, &sTextInputCtl_m);
		break;
	case 'L':   /* lower-upper word formation characters */
		addLowerUpperWFChars(psz, &sTextInputCtl_m);
		break;
	case 'a':   /* multibyte alphabetic (word formation) characters */
		addWordFormationCharStrings(psz, &sTextInputCtl_m);
		break;
	case 'l':   /* multibyte lower-upper word formation characters */
		addLowerUpperWFCharStrings(psz, &sTextInputCtl_m);
		break;
	default:
		break;
	@}
@}

void reset_alphabetic()
@{
resetWordFormationChars(&sTextInputCtl_m);
@}
@end smallexample
@subheading Source File
@file{myctype.c}

@c ----------------------------------------------------------------------------
@node addLowerUpperWFCharStrings, addStringClass, addLowerUpperWFChars, Functions
@page
@section addLowerUpperWFCharStrings
@subheading Syntax
@example
#include "textctl.h"    /* or template.h or opaclib.h */

void addLowerUpperWFCharStrings(char *        pszLUPairs_in,
								TextControl * pTextCtl_io);
@end example
@subheading Description
@code{addLowerUpperWFCharStrings} scans the input string for pairs of
multibyte characters.  The first member of each pair is added to the set
of multibyte lowercase alphabetic characters, and the second member is
added to the set of multibyte uppercase alphabetic characters.  Note that
there may be a many-to-many mapping between lowercase and uppercase
multibyte characters.

The arguments to @code{addLowerUpperWFChars} are as follows:
@table @code
@item pszLUPairs_in
points to a string containing multibyte lowercase/UPPERCASE character
pairs.  Whitespace is used to separate the multibyte characters from each
other, and the pairs from each other.

@item pTextCtl_io
points to a data structure that contains orthographic information,
including the mappings between lowercase and uppercase letters.
@end table
@subheading Return Value
none
@subheading Example
@ifset txt
See the example for @code{addLowerUpperWFChars} above.
@end ifset
@ifclear txt
@xref{addLowerUpperWFChars, , Example}.
@end ifclear
@subheading Source File
@file{myctype.c}

@c ----------------------------------------------------------------------------
@node addStringClass, addToStringList, addLowerUpperWFCharStrings, Functions
@page
@section addStringClass
@subheading Syntax
@example
#include "strclass.h"   /* or change.h or textctl.h or template.h
						   or opaclib.h */

StringClass * addStringClass(char *        pszField_in,
							 StringClass * pClasses_io);
@end example
@subheading Description
@code{addStringClass} adds a string class to the list of string
classes.  String classes are used in string environments such as those
in the consistent change notation supported by the OPAC function
library.

The arguments to @code{addStringClass} are as follows:
@table @code
@item pszField_in
points to a string containing a string class definition: the class name
followed by the set of members.

@item pClasses_io
points to the list of string classes.  This may be @code{NULL} the
first time @code{addStringClass} is called.  Each subsequent call
should use the value returned by the preceding call.
@end table
@subheading Return Value
a pointer to the head of the updated list of string classes
@subheading Example
@smallexample
#include "change.h"     /* includes strclass.h */
...
static Change *         pChanges_m = NULL;
static StringClass *    pClasses_m = NULL;
...
void store_change_info(pszField_in)
char *  pszField_in;
@{
Change *        pChg;
char *          psz;
int             code;

if (pszField_in == NULL)
	return;
psz  = pszField_in;
code = *psz++;          /* grab the table code */
switch (code)
	@{
	case 'C':           /* change */
		pChg = parseChangeString( psz, pClasses_m );
		if (pChg != (Change *)NULL)
			@{
			pChg->pNext = pChanges_m;
			pChanges_m = pChg;
			@}
		break;
	case 'S':           /* string class */
		pClasses_m = addStringClass( psz, pClasses_m );
		break;
	default:
		break;
	@}
@}
@end smallexample
@subheading Source File
@file{strcla.c}

@c ----------------------------------------------------------------------------
@node addToStringList, addWordFormationChars, addStringClass, Functions
@page
@section addToStringList
@subheading Syntax
@example
#include "strlist.h"

StringList * addToStringList(StringList * pList_in,
							 const char * pszString_in);
@end example
@subheading Description
@code{addToStringList} adds a string to the beginning of a list of
strings.  It does not check whether the string is already in the list.

The arguments to @code{addToStringList} are as follows:
@table @code
@item pList_in
points to a list of strings.  It may be @code{NULL} to signal an empty list.

@item pszString_in
points to a @code{NUL}-terminated character string.
@end table
@subheading Return Value
a pointer to the revised list
@subheading Example
@smallexample
#include "strlist.h"
...
StringList * pStrings = NULL;
...
				/* pStrings-->NULL */
pStrings = addToStringList(pStrings, "this");
				/* pStrings-->"this"-->NULL */
pStrings = addToStringList(pStrings, "test");
				/* pStrings-->"test"-->"this"-->NULL */
pStrings = addToStringList(pStrings, "is");
				/* pStrings-->"is"-->"test"-->"this"-->NULL */
pStrings = addToStringList(pStrings, "a");
				/* pStrings-->"a"-->"is"-->"test"-->"this"-->NULL */
pStrings = addToStringList(pStrings, "test");
				/* pStrings-->"test"-->"a"-->"is"-->"test"-->"this"-->NULL */
@end smallexample
@subheading Source File
@file{add_sl.c}

@c ----------------------------------------------------------------------------
@node addWordFormationChars, addWordFormationCharStrings, addToStringList, Functions
@page
@section addWordFormationChars
@subheading Syntax
@example
#include "textctl.h"    /* or template.h or opaclib.h */

void addWordFormationChars(char *        pszLetters_in,
						   TextControl * pTextCtl_io);
@end example
@subheading Description
@code{addWordFormationChars} scans the input string for non-whitespace
characters.  Each such character is added to the set of alphabetic
characters that do not have a lowercase/UPPERCASE distinction.  (An
English example would be the apostrophe character.)

The arguments to @code{addWordFormationChars} are as follows:
@table @code
@item pszLetters_in
points to a string containing (caseless) alphabetic characters.

@item pTextCtl_io
points to a data structure that contains orthographic information.
@end table
@subheading Return Value
none
@subheading Example
@ifset txt
See the example for @code{addLowerUpperWFChars} above.
@end ifset
@ifclear txt
@xref{addLowerUpperWFChars, , Example}.
@end ifclear
@subheading Source File
@file{myctype.c}

@c ----------------------------------------------------------------------------
@node addWordFormationCharStrings, allocMemory, addWordFormationChars, Functions
@page
@section addWordFormationCharStrings
@subheading Syntax
@example
#include "textctl.h"    /* or template.h or opaclib.h */

void addWordFormationCharStrings(char *        pszLetters_in,
								 TextControl * pTextCtl_io);
@end example
@subheading Description
@code{addWordFormationCharStrings} scans the input string for multibyte
characters.  Each such multibyte character sequence is added to the set
of multibyte caseless alphabetic characters.

The arguments to @code{addWordFormationCharStrings} are as follows:
@table @code
@item pszLetters_in
points to a string containing multibyte (caseless) alphabetic
characters.  Whitespace separates the multibyte characters.

@item pTextCtl_io
points to a data structure that contains orthographic information.
@end table
@subheading Return Value
none
@subheading Example
@ifset txt
See the example for @code{addLowerUpperWFChars} above.
@end ifset
@ifclear txt
@xref{addLowerUpperWFChars, , Example}.
@end ifclear
@subheading Source File
@file{myctype.c}

@c ----------------------------------------------------------------------------
@node allocMemory, applyChanges, addWordFormationCharStrings, Functions
@page
@section allocMemory
@subheading Syntax
@example
#include "allocmem.h"   /* or opaclib.h */

void * allocMemory(size_t uiSize_in);
@end example
@subheading Description
@code{allocMemory} provides a ``safe'' interface to @code{malloc}.  If
the requested memory cannot be allocated, the function pointed to by
@code{pfOutOfMemory_g} is called.  If @code{pfOutOfMemory_g} is
@code{NULL}, then the default behavior is to display an error message
incorporating the string stored in @code{szOutOfMemoryMarker_g} and
abort the program.

It is assumed that @code{allocMemory} always returns a good value.
This implies that any function pointed to by @code{pfOutOfMemory_g}
either aborts the program or uses @code{longjmp} to escape to a safe
place in the program.

@code{allocMemory} has a single argument:
@table @code
@item uiSize_in
is the number of bytes to allocate.
@end table
@subheading Return Value
a pointer to the beginning of the memory area allocated
@subheading Example
@smallexample
#include "allocmem.h"
...
char * p;
...
p = allocMemory(75);
@end smallexample
@subheading Source File
@file{allocmem.c}

@c ----------------------------------------------------------------------------
@node applyChanges, buildAdjustedFilename, allocMemory, Functions
@page
@section applyChanges
@subheading Syntax
@example
#include "change.h"     /* or textctl.h or template.h or opaclib.h */

char * applyChanges(const char *   pszString_in,
					const Change * pChangeList_in);
@end example
@subheading Description
@code{applyChanges} applies a list of consistent changes to a string.
The function steps through the list of changes, applying each change as
often as necessary before trying the next change in the list.  The
input string is not changed; rather, a copy is created, modified, and
returned.

The arguments to @code{applyChanges} are as follows:
@table @code
@item pszString_in
points to a string to be changed.

@item pChangeList_in
points to a list of changes to apply to the string.
@end table
@subheading Return Value
a pointer to a dynamically allocated and (possibly) changed string
@subheading Example
@smallexample
#include "change.h"
...
Change * pChanges_m;
...
char * pszChanged;
...
pszChanged = applyChanges("this is a test", pChanges_m);
...
freeMemory( pszChanged );
@end smallexample
@subheading Source File
@file{change.c}

@c ----------------------------------------------------------------------------
@node buildAdjustedFilename, buildChangeString, applyChanges, Functions
@page
@section buildAdjustedFilename
@subheading Syntax
@example
#include "opaclib.h"

char * buildAdjustedFilename(const char * pszFilename_in,
							 const char * pszBasePathname_in,
							 const char * pszExtension_in);
@end example
@subheading Description
@code{buildAdjustedFilename} builds a filename from the pieces given.
If the base pathname contains directory information, and the input
filename is not an absolute pathname, the leading directory information
is added to the output filename.  If the extension is given, and the
input filename does not have an extension, the extension is added to
the output filename if the file cannot be opened for input without it.

The arguments to @code{buildAdjustedFilename} are as follows:
@table @code
@item pszFilename_in
points to a filename string.

@item pszBasePathname_in
points to a base file pathname string, or is @code{NULL}.

@item pszExtension_in
points to a filename extension string, or is @code{NULL}.
@end table
@subheading Return Value
a pointer to a dynamically allocated filename string
@subheading Example
@smallexample
#include "opaclib.h"
...
int readControlFile(char * pszControlFile_in)
@{
char * pszIncludeFile;
char   szBuffer[512];
FILE * pControlFP;
char * p;

pControlFP = fopen(pszControlFile_in, "r");
if (pControlFP == NULL)
	return 0;
while (fgets(szBuffer, 512, pControlFP) != NULL)
	@{
	p = szBuffer + strlen(szBuffer) - 1;
	if (*p == '\n')
		*p = '\0';
	if (strncmp(szBuffer, "\\include", 8) == 0)
		@{
		pszIncludeFile = szBuffer + 8;
		pszIncludeFile += strspn(pszIncludeFile, " \t\r\n\f");
		if (*pszIncludeFile == '\0')
			continue;
		pszIncludeFile = buildAdjustedFilename(pszIncludeFile,
											   pszControlFile_in,
											   ".ctl");
		readControlFile(pszIncludeFile);
		freeMemory(pszIncludeFile);
		@}
	...
	@}
fclose(pControlFP);
return 1;
@}
@end smallexample
@subheading Source File
@file{adjfname.c}

@c ----------------------------------------------------------------------------
@node buildChangeString, checkFileError, buildAdjustedFilename, Functions
@page
@section buildChangeString
@subheading Syntax
@example
#include "change.h"     /* or textctl.h or template.h or opaclib.h */

char * buildChangeString(const Change * pChange_in);
@end example
@subheading Description
@code{buildChangeString} builds a textual representation of the given
consistent change data structure.

@code{buildChangeString} has one argument:
@table @code
@item pChange_in
points to a single consistent change data structure.  (The @code{pNext}
field of the @code{Change} data structure is ignored.)
@end table
@subheading Return Value
a pointer to a dynamically allocated string representing the change, or
@code{NULL} if an error occurs
@subheading Example
@smallexample
#include "change.h"
...
void displayChangeList(Change * pChanges_in)
@{
Change *        pChange;
char *          pszChange;

for ( pChange = pChanges_in ; pChange ; pChange = pChange->pNext )
	@{
	pszChange = buildChangeString( pChange );
	fprintf(stderr, "%s\n", pszChange);
	freeMemory( pszChange );
	@}
@}
@end smallexample
@subheading Source File
@file{change.c}

@c ----------------------------------------------------------------------------
@node checkFileError, cleanupAfterStdFormatRecord, buildChangeString, Functions
@page
@section checkFileError
@subheading Syntax
@example
#include <stdio.h>
#include "opaclib.h"

void checkFileError(FILE *       pOutputFP_in,
					const char * pszProcessName_in,
					const char * pszFilename_in);
@end example
@subheading Description
@code{checkFileError} checks for an error in the output file
@code{pOutputFP_in} whose name is given by @code{pszFilename_in}.  If
an error occurred, the output file is deleted and the program exits
with an error message.

The arguments to @code{checkFileError} are as follows:
@table @code
@item pOutputFP_in
is an output FILE pointer.

@item pszProcessName_in
points to a string indicating where the error occurred.

@item pszFilename_in
points to the name of the output file.
@end table
@subheading Return Value
none
@subheading Example
@smallexample
#include <stdio.h>
#include "cportlib.h"
...
FILE * fp;
char   filename[100];
...
checkFileError(fp, "Program Name", filename);
fclose(fp);
@end smallexample
@subheading Source File
@file{fulldisk.c}

@c ----------------------------------------------------------------------------
@node cleanupAfterStdFormatRecord, convLowerToUpper, checkFileError, Functions
@page
@section cleanupAfterStdFormatRecord
@subheading Syntax
@example
#include "record.h"     /* or opaclib.h */

void cleanupAfterStdFormatRecord(void);
@end example
@subheading Description
@code{cleanupAfterStdFormatRecord} frees any memory allocated for
@code{readStdFormatRecord}.

@code{cleanupAfterStdFormatRecord} does not have any arguments.
@subheading Return Value
none
@subheading Example
@smallexample
#include <stdio.h>
#include "record.h"
static CodeTable sLexTable_m = @{ "\\w\0W\0\\c\0C\\f\0F\\g\0G\0",
								  4, "\\w" @};
...
int load_lexicon(pszLexiconFile_in, cComment_in)
char *  pszLexiconFile_in;
int     cComment_in;
@{
FILE *          fp;
unsigned        uiRecordCount = 0;
char *          pRecord;
/*
 *  open the lexicon file
 */
if (pszLexiconFile_in == NULL)
	return( 0 );
fp = fopen(pszLexiconFile_in, "r");
if (fp == (FILE *)NULL)
	return( 0 );
/*
 *  load all the records from the lexicon file
 */
uiRecordCount = 0;
while ((pRecord = readStdFormatRecord(fp,
									  &sLexTable_m,
									  cComment_in,
									  &uiRecordCount)) != NULL)
	@{
	...
	@}
/*
 *  close the lexicon file and erase the temporary data structures
 */
fclose(fp);
cleanupAfterStdFormatRecord();
return( 1 );
@}
@end smallexample
@subheading Source File
@file{record.c}

@c ----------------------------------------------------------------------------
@node convLowerToUpper, convLowerToUpperSet, cleanupAfterStdFormatRecord, Functions
@page
@section convLowerToUpper
@subheading Syntax
@example
#include "textctl.h"    /* or template.h or opaclib.h */

const unsigned char * convLowerToUpper(const unsigned char * pszString_in,
									   const TextControl *   pTextCtl_in);
@end example
@subheading Description
@code{convLowerToUpper} checks whether the input string begins with a
multibyte lowercase character.  If so, it returns the (first)
corresponding multibyte uppercase character.

This function depends on previous calls to @code{addLowerUpperWFChars} or
@code{addLowerUpperWFCharStrings} to establish the mappings between
lowercase and uppercase multibyte characters.
(@code{addLowerUpperWFChars} and @code{addLowerUpperWFCharStrings} are
implicitly called by @code{loadIntxCtlFile} and @code{loadOutxCtlFile}.)

The arguments to @code{convLowerToUpper} are as follows:
@table @code
@item pszString_in
points to a @code{NUL}-terminated character string.

@item pTextCtl_in
points to a data structure that contains orthographic information,
including the mappings between lowercase and uppercase letters.
@end table
@subheading Return Value
a pointer to a @code{NUL}-terminated string containing the (primary)
corresponding multibyte uppercase character, or @code{NULL} if the input
string does not begin with a multibyte lowercase character.  This may
point to a static buffer that may be overwritten by the next call to
@code{convLowerToUpper}.
@subheading Example
@smallexample
#include "textctl.h"
...
static TextControl      sTextCtl_m;
static StringClass *    pStringClasses_m;
static char             szOutxFilename_m[100];
...
loadOutxCtlFile(szOutxFilename_m, ';', &sTextCtl_m, &pStringClasses_m);
...
unsigned char * upcaseString(unsigned char * pszString_in)
@{
size_t          iCharSize;
size_t          iUCSize;
size_t          iUpperLength;
unsigned char * p;
unsigned char * pUC;
unsigned char * pszUpper;
unsigned char * q;

if (pszString_in == NULL)
	return NULL;
for ( p = pszString_in ; *p ; p += iCharSize )
	@{
	if ((iCharSize = matchAlphaChar(p, &sTextCtl_m)) == 0)
		iCharSize = 1;
	pUC = convLowerToUpper(p, &sTextCtl_m);
	if (pUC != NULL)
		iUpperLength += strlen((char *)pUC);
	else
		iUpperLength += iCharSize;
	@}
pszUpper = allocMemory(iUpperLength + 1);
for ( p = pszString_in, q = pszUpper ; *p ; p += iCharSize )
	@{
	if ((iCharSize = matchAlphaChar(p, &sTextCtl_m)) == 0)
		iCharSize = 1;
	pUC = convLowerToUpper(p, &sTextCtl_m);
	if (pUC != NULL)
		@{
		iUCSize = strlen((char *)pUC);
		memcpy(q, pUC, iUCSize);
		q += iUCSize;
		@}
	else
		@{
		memcpy(q, p, iCharSize);
		q += iCharSize;
		@}
	@}
pszUpper[iUpperLength] = NUL;
return pszUpper;
@}
@end smallexample
@subheading Source File
@file{myctype.c}

@c ----------------------------------------------------------------------------
@node convLowerToUpperSet, convUpperToLower, convLowerToUpper, Functions
@page
@section convLowerToUpperSet
@subheading Syntax
@example
#include "textctl.h"    /* or template.h or opaclib.h */

const StringList * convLowerToUpperSet(const unsigned char * pszString_in,
									   const TextControl *   pTextCtl_in);
@end example
@subheading Description
@code{convLowerToUpperSet} checks whether the input string begins with a
multibyte lowercase character.  If so, it returns the complete set of
corresponding multibyte uppercase characters.

This function depends on previous calls to @code{addLowerUpperWFChars} or
@code{addLowerUpperWFCharStrings} to establish the mappings between
lowercase and uppercase multibyte characters.
(@code{addLowerUpperWFChars} and @code{addLowerUpperWFCharStrings} are
implicitly called by @code{loadIntxCtlFile} and @code{loadOutxCtlFile}.)

The arguments to @code{convLowerToUpperSet} are as follows:
@table @code
@item pszString_in
points to a @code{NUL}-terminated character string.

@item pTextCtl_in
points to a data structure that contains orthographic information,
including the mappings between lowercase and uppercase letters.
@end table
@subheading Return Value
a pointer to a list of @code{NUL}-terminated strings containing the
corresponding multibyte uppercase characters, or @code{NULL} if the input
string does not begin with a multibyte lowercase character.  This may
point to a static buffer that may be overwritten by the next call to
@code{convLowerToUpperSet}.
@subheading Example
#include "textctl.h"
#include "rpterror.h"
...
StringList * upcaseWord(pszWord_in, pTextCtl_in)
char *              pszWord_in;
const TextControl * pTextCtl_in;
@{
size_t              uiCharCount;
size_t              uiLowerCount;
size_t              uiNumberAlternatives;
size_t              uiSpan;
size_t              uiWordLength;
size_t              k;
int                 iLength;
unsigned char *     p;
StringList *        pUpcaseList = NULL;
const StringList *  pUpperSet;
const StringList *  ps;
/*
 *  count the number of multibyte characters in the string
 *  count the lowercase letters
 *  calculate the number of (ambiguous) upcase conversions
 *  calculate the maximum length of the upcased word
 */
uiCharCount = 0;
uiLowerCount = 0;
uiNumberAlternatives = 1;
uiWordLength = 1;           /* count the terminating NUL byte */
for ( p = (unsigned char *)pszWord_in ; *p != NUL ; p += iLength )
	@{
	iLength = matchAlphaChar(p, pTextCtl_in);
	if (iLength == 0)
		iLength = 1;
	++uiCharCount;
	if (matchLowercaseChar(p, pTextCtl_in) != 0)
		@{
		++uiLowerCount;
		pUpperSet = convLowerToUpperSet(p, pTextCtl_in);
		uiNumberAlternatives *= getStringListSize( pUpperSet );
		uiSpan = 0;
		for ( ps = pUpperSet ; ps ; ps = ps->pNext )
			@{
			k = strlen( ps->pszString );
			if (k > uiSpan)
				uiSpan = k;
			@}
		@}
	else
		uiSpan = iLength;
	uiWordLength += uiSpan;
	@}
if (uiLowerCount == 0)
	@{
	/*
	 *  the word is already all uppercase
	 */
	return addToStringList(NULL, pszWord_in);
	@}
else
	@{
	/*
	 *  convert word to all uppercase (possibly ambiguosly)
	 */
	char *      pszCapWord;
	char *      pszUpper;
	size_t      uiNum;
	int         iUpperLength;
	size_t      i;
	size_t      j;

	if (uiNumberAlternatives < 1)
		@{
		reportError(ERROR_MSG,
					"error getting uppercase equivalents for \"%s\"\n",
					pszWord_in);
		return NULL;
		@}
	if (uiNumberAlternatives > 500)
		@{
		reportError(WARNING_MSG,
				   "%lu uppercase equivalents is too many: storing only 500\n",
					uiNumberAlternatives);
		uiNumberAlternatives = 500;
		@}
	pszCapWord = allocMemory(uiWordLength);
	for ( i = 0 ; i < uiNumberAlternatives ; ++i )
		@{
		strcpy(pszCapWord, pszWord_in);
		uiSpan = 1;
		j = 0;
		for ( p = (unsigned char *)pszCapWord ; *p ; p += iLength )
			@{
			iLength = matchLowercaseChar(p, pTextCtl_in);
			if (iLength != 0)
				@{
				pUpperSet = convLowerToUpperSet(p, pTextCtl_in);
				uiNum = getStringListSize(pUpperSet);
				pszUpper = pUpperSet->pszString;
				if (uiNum > 1)
					@{
					k = (i / uiSpan) % uiNum;
					uiSpan *= uiNum;
					for ( ps = pUpperSet ; ps ; ps = ps->pNext )
						@{
						if (k == 0)
							@{
							pszUpper = ps->pszString;
							break;
							@}
						--k;
						@}
					@}
				/*
				 *  replace the lowercase multibyte character with an
				 *  equivalent uppercase multibyte character
				 */
				iUpperLength = strlen(pszUpper);
				if (iUpperLength != iLength)
					memmove(p + iUpperLength,
							p + iLength,
							strlen((char *)p + iLength) + 1);
				memcpy(p, pszUpper, iUpperLength);
				iLength = iUpperLength;
				@}
			else
				@{
				iLength = matchAlphaChar(p, pTextCtl_in);
				if (iLength == 0)
					iLength = 1;
				@}
			++j;
			@}
		pUpcaseList = addToStringList(pUpcaseList, pszCapWord);
		@}
	freeMemory( pszCapWord );
	@}
return pUpcaseList;
@}
@subheading Source File
@file{myctype.c}

@c ----------------------------------------------------------------------------
@node convUpperToLower, convUpperToLowerSet, convLowerToUpperSet, Functions
@page
@section convUpperToLower
@subheading Syntax
@example
#include "textctl.h"    /* or template.h or opaclib.h */

const unsigned char * convUpperToLower(const unsigned char * pszString_in,
									   const TextControl *   pTextCtl_in);
@end example
@subheading Description
@code{convUpperToLower} checks whether the input string begins with a
multibyte uppercase character.  If so, it returns the (first)
corresponding multibyte lowercase character.

This function depends on previous calls to @code{addLowerUpperWFChars} or
@code{addLowerUpperWFCharStrings} to establish the mappings between
lowercase and uppercase multibyte characters.
(@code{addLowerUpperWFChars} and @code{addLowerUpperWFCharStrings} are
implicitly called by @code{loadIntxCtlFile} and @code{loadOutxCtlFile}.)

The arguments to @code{convUpperToLower} are as follows:
@table @code
@item pszString_in
points to a @code{NUL}-terminated character string.

@item pTextCtl_in
points to a data structure that contains orthographic information,
including the mappings between lowercase and uppercase letters.
@end table
@subheading Return Value
a pointer to a @code{NUL}-terminated string containing the (primary)
corresponding multibyte lowercase character, or @code{NULL} if the input
string does not begin with a multibyte uppercase character.  This may
point to a static buffer that may be overwritten by the next call to
@code{convUpperToLower}.
@subheading Example
@smallexample
#include "textctl.h"
...
static TextControl      sTextCtl_m;
static StringClass *    pStringClasses_m;
static char             szIntxFilename_m[100];
...
loadIntxCtlFile(szIntxFilename_m, ';', &sTextCtl_m, &pStringClasses_m);
...
unsigned char * downcaseString(unsigned char * pszString_in)
@{
size_t          iCharSize;
size_t          iLCSize;
size_t          iLowerLength;
unsigned char * p;
unsigned char * pLC;
unsigned char * pszLower;
unsigned char * q;

if (pszString_in == NULL)
	return NULL;
for ( p = pszString_in ; *p ; p += iCharSize )
	@{
	if ((iCharSize = matchAlphaChar(p, &sTextCtl_m)) == 0)
		iCharSize = 1;
	pLC = convUpperToLower(p, &sTextCtl_m);
	if (pLC != NULL)
		iLowerLength += strlen((char *)pLC);
	else
		iLowerLength += iCharSize;
	@}
pszLower = allocMemory(iLowerLength + 1);
for ( p = pszString_in, q = pszLower ; *p ; p += iCharSize )
	@{
	if ((iCharSize = matchAlphaChar(p, &sTextCtl_m)) == 0)
		iCharSize = 1;
	pLC = convUpperToLower(p, &sTextCtl_m);
	if (pLC != NULL)
		@{
		iLCSize = strlen((char *)pLC);
		memcpy(q, pLC, iLCSize);
		q += iLCSize;
		@}
	else
		@{
		memcpy(q, p, iCharSize);
		q += iCharSize;
		@}
	@}
pszLower[iLowerLength] = NUL;
return pszLower;
@}
@end smallexample
@subheading Source File
@file{myctype.c}

@c ----------------------------------------------------------------------------
@node convUpperToLowerSet, decapitalizeWord, convUpperToLower, Functions
@page
@section convUpperToLowerSet
@subheading Syntax
@example
#include "textctl.h"    /* or template.h or opaclib.h */

const StringList * convUpperToLowerSet(const unsigned char * pszString_in,
									   const TextControl *   pTextCtl_in);
@end example
@subheading Description
@code{convUpperToLowerSet} checks whether the input string begins with a
multibyte uppercase character.  If so, it returns the complete set of
corresponding multibyte lowercase characters.

This function depends on previous calls to @code{addLowerUpperWFChars} or
@code{addLowerUpperWFCharStrings} to establish the mappings between
lowercase and uppercase multibyte characters.
(@code{addLowerUpperWFChars} and @code{addLowerUpperWFCharStrings} are
implicitly called by @code{loadIntxCtlFile} and @code{loadOutxCtlFile}.)

The arguments to @code{convUpperToLowerSet} are as follows:
@table @code
@item pszString_in
points to a @code{NUL}-terminated character string.

@item pTextCtl_in
points to a data structure that contains orthographic information,
including the mappings between lowercase and uppercase letters.
@end table
@subheading Return Value
a pointer to a list of @code{NUL}-terminated strings containing the
corresponding multibyte lowercase characters, or @code{NULL} if the input
string does not begin with a multibyte uppercase character.  This may
point to a static buffer that may be overwritten by the next call to
@code{convUpperToLowerSet}.
@subheading Example
@smallexample
#include "textctl.h"
#include "rpterror.h"
...
StringList * downcaseWord(pszWord_in, pTextCtl_in)
char *              pszWord_in;
const TextControl * pTextCtl_in;
@{
size_t              uiCharCount;
size_t              uiUpperCount;
size_t              uiNumberAlternatives;
size_t              uiSpan;
size_t              uiWordLength;
size_t              k;
int                 iLength;
unsigned char *     p;
StringList *        pDowncaseList = NULL;
const StringList *  pLowerSet;
const StringList *  ps;
/*
 *  count the number of multibyte characters in the string
 *  count the uppercase letters
 *  calculate the number of (ambiguous) downcase conversions
 *  calculate the maximum length of the downcased word
 */
uiCharCount = 0;
uiUpperCount = 0;
uiNumberAlternatives = 1;
uiWordLength = 1;           /* count the terminating NUL byte */
for ( p = (unsigned char *)pszWord_in ; *p != NUL ; p += iLength )
	@{
	iLength = matchAlphaChar(p, pTextCtl_in);
	if (iLength == 0)
		iLength = 1;
	++uiCharCount;
	if (matchUppercaseChar(p, pTextCtl_in) != 0)
		@{
		++uiUpperCount;
		pLowerSet = convUpperToLowerSet(p, pTextCtl_in);
		uiNumberAlternatives *= getStringListSize( pLowerSet );
		uiSpan = 0;
		for ( ps = pLowerSet ; ps ; ps = ps->pNext )
			@{
			k = strlen( ps->pszString );
			if (k > uiSpan)
				uiSpan = k;
			@}
		@}
	else
		uiSpan = iLength;
	uiWordLength += uiSpan;
	@}
if (uiUpperCount == 0)
	@{
	/*
	 *  the word is already all lowercase
	 */
	return addToStringList(NULL, pszWord_in);
	@}
else
	@{
	/*
	 *  convert word to all lowercase (possibly ambiguosly)
	 */
	char *      pszDecapWord;
	char *      pszLower;
	size_t      uiNum;
	int         iLowerLength;
	size_t      i;
	size_t      j;

	if (uiNumberAlternatives < 1)
		@{
		reportError(ERROR_MSG,
					"error getting lowercase equivalents for \"%s\"\n",
					pszWord_in);
		return NULL;
		@}
	if (uiNumberAlternatives > 500)
		@{
		reportError(WARNING_MSG,
				   "%lu lowercase equivalents is too many: storing only 500\n",
					uiNumberAlternatives);
		uiNumberAlternatives = 500;
		@}
	pszDecapWord = allocMemory(uiWordLength);
	for ( i = 0 ; i < uiNumberAlternatives ; ++i )
		@{
		strcpy(pszDecapWord, pszWord_in);
		uiSpan = 1;
		j = 0;
		for ( p = (unsigned char *)pszDecapWord ; *p ; p += iLength )
			@{
			iLength = matchUppercaseChar(p, pTextCtl_in);
			if (iLength != 0)
				@{
				pLowerSet = convUpperToLowerSet(p, pTextCtl_in);
				uiNum = getStringListSize(pLowerSet);
				pszLower = pLowerSet->pszString;
				if (uiNum > 1)
					@{
					k = (i / uiSpan) % uiNum;
					uiSpan *= uiNum;
					for ( ps = pLowerSet ; ps ; ps = ps->pNext )
						@{
						if (k == 0)
							@{
							pszLower = ps->pszString;
							break;
							@}
						--k;
						@}
					@}
				/*
				 *  replace the uppercase multibyte character with an
				 *  equivalent lowercase multibyte character
				 */
				iLowerLength = strlen(pszLower);
				if (iLowerLength != iLength)
					memmove(p + iLowerLength,
							p + iLength,
							strlen((char *)p + iLength) + 1);
				memcpy(p, pszLower, iLowerLength);
				iLength = iLowerLength;
				@}
			else
				@{
				iLength = matchAlphaChar(p, pTextCtl_in);
				if (iLength == 0)
					iLength = 1;
				@}
			++j;
			@}
		pDowncaseList = addToStringList(pDowncaseList, pszDecapWord);
		@}
	freeMemory( pszDecapWord );
	@}
return pDowncaseList;
@}
@end smallexample
@subheading Source File
@file{myctype.c}

@c ----------------------------------------------------------------------------
@node decapitalizeWord, displayNumberedMessage, convUpperToLowerSet, Functions
@page
@section decapitalizeWord
@subheading Syntax
@example
#include "template.h"   /* or opaclib.h */

int decapitalizeWord(WordTemplate *      pWord_io,
					 const TextControl * pTextCtl_in);
@end example
@subheading Description
int (pWord_io, pTextCtl_in)
WordTemplate *  pWord_io;       /* pointer to WordTemplate structure
TextControl *   pTextCtl_in;

@code{decapitalizeWord} converts the input word to all lowercase (possibly
ambiguously) and returns a capitalization flag:
@table @code
@item 0 (NOCAP)
The input word had no uppercase letters.
@item 1 (INITCAP)
The input word had a single capital letter at the beginning.
@item 2 (ALLCAP)
The input word had all uppercase letters.
@item >4
The input word had a mixture of uppercase and lowercase letters.
@end table
After the conversion to all lowercase, any orthography changes stored
in @code{pTextCtl_in} are applied.

The arguments to @code{decapitalizeWord} are as follows:
@table @code
@item pWord_io
points to a data structure that contains the original word and receives
the decapitalized word.
@item pTextCtl_in
points to a data structure that contains orthographic information.
@end table
@subheading Return Value
the capitalization flag for the word
@subheading Example
@smallexample
#include "template.h"   /* includes textctl.h */
...
WordTemplate * buildTemplate(
	char *        pszWord_in,
	TextControl * pTextCtl_in)
@{
WordTemplate *  pTemplate;

if (pszWord_in == NULL)
	return NULL;
pTemplate = (WordTemplate *)allocMemory(sizeof(WordTemplate));
pTemplate->pszOrigWord = duplicateString( pszWord_in );
pTemplate->iCapital = decapitalizeWord( pTemplate, pTextCtl_in);
return pTemplate;
@}
@end smallexample
@subheading Source File
@file{textin.c}

@c ----------------------------------------------------------------------------
@node displayNumberedMessage, duplicateString, decapitalizeWord, Functions
@page
@section displayNumberedMessage
@subheading Syntax
@example
#include "rpterror.h"   /* or opaclib.h */

void displayNumberedMessage(const NumberedMessage * pMessage_in,
							int                     bSilent_in,
							int                     bShowWarnings_in,
							FILE *                  pLogFP_in,
							const char *            pszFilename_in,
							unsigned                uiLineNumber_in,
							...);
@end example
@subheading Description
@code{displayNumberedMessage} writes a numbered error or warning
message to the standard error output (screen), optionally writing it to
a log file as well.  For GUI programs, the programmer must write a
different version of @code{displayNumberedMessage} to satisfy the link
requirements of other functions in the OPAC library.  This would
typically display a message box or write to a message window.

The arguments to @code{displayNumberedMessage} are as follows:
@table @code
@item pMessage_in
points to a @code{NumberedMessage} data structure that contains the
message type, the message number, and the format string for the
message.

@item bSilent_in
specifies that no screen output occurs if @code{TRUE} (nonzero).

@item bShowWarnings_in
specifies that warning messages (not just error messages) are displayed
if @code{TRUE} (nonzero).

@item pLogFP_in
is a @code{FILE} pointer to an open log file, or is @code{NULL}.

@item pszFilename_in
points to the name of the input file in which the error occurred, or is
@code{NULL}.

@item uiLineNumber_in
is the line number in the input file on which the error occurred, or is
zero (@code{0}).

@item @dots{}
represents any number of additional arguments needed by the
@code{printf} style format string given by @code{pMessage_in}.
@end table
@subheading Return Value
none
@subheading Example
@smallexample
#include <stdio.h>
#include "opaclib.h"    /* includes rpterror.h */
...
int     bSilent_g       = 0;
int     bShowWarnings_g = 1;
FILE *  pLogFP_g        = NULL;
...
static NumberedMessage sCannotOpen_m      = @{ ERROR_MSG,   100,
	"Cannot open %s file %s" @};
static NumberedMessage sIgnoreRedundant_m = @{ WARNING_MSG, 101,
	"Ignoring all but first \\%s line" @};
static char *   aszCodes_m[] = @{
	"\\lexicon",
	"\\grammar",
	...
	NULL
	@};
...
FILE *          pControlFP;
char *          pszControlFile;
unsigned        uiLineNumber;
char *          pszLexFile;
char **         ppszField;
char *          p;
unsigned        i;
...
pControlFP = fopen(pszControlFile, "r");
if (pControlFP == (FILE *)NULL)
	@{
	displayNumberedMessage(&sCannotOpen_m,
						   bSilent_g, bShowWarnings_g, pLogFP_g,
						   NULL, 0,
						   "log", pszControlFile);
	exit(1);
	@}
uiLineNumber = 1;
while ((ppszField = readStdFormatField(pControlFP,
									   aszCodes_m, NUL)) != NULL)
	@{
	switch (**ppszField)
		@{
		case 1:                 /* "\\lexicon" */
			if (pszLexFile != (char *)NULL)
				displayNumberedMessage(&sIgnoreRedundant_m,
									   bSilent_g, bShowWarnings_g,
									   pLogFP_g,
									   pszControlFile, uiLineNumber,
									   "lexicon");
			else
				@{
				p = strtok(ppszField[0]+1, " \t\r\n\f\v");
				pszLexFile = buildAdjustedFilename(p,
												   pszControlFile,
												   ".lex");
				@}
			break;
		...
		@}
	...
	for ( i = 0 ; ppszField[i] ; ++i )
		++uiLineNumber;
	@}
...
@end smallexample
@subheading Source File
@file{textin.c}

@c ----------------------------------------------------------------------------
@node duplicateString, duplicateStringList, displayNumberedMessage, Functions
@page
@section duplicateString
@subheading Syntax
@example
#include "allocmem.h"   /* or opaclib.h */

char * duplicateString(const char * pszString_in);
@end example
@subheading Description
@code{duplicateString} creates a copy of an existing @code{NUL}-terminated
character string.  It calls @code{allocateMemory} to get the memory to
store the copy of the string.  If @code{pszString_in} is @code{NULL},
then @code{duplicateString} returns @code{NULL}.

This is the same as the standard function @code{strdup}, except that it
calls @code{allocateMemory} instead of @code{malloc}.

@code{duplicateString} has one argument:
@table @code
@item pszString_in
points to a @code{NUL}-terminated character string.
@end table
@subheading Return Value
a pointer to the newly allocated and copied duplicate string
@subheading Example
@smallexample
#include "template.h"   /* includes textctl.h */
...
WordTemplate * buildTemplate(
	char *        pszWord_in,
	TextControl * pTextCtl_in)
@{
WordTemplate *  pTemplate;

if (pszWord_in == NULL)
	return NULL;
pTemplate = (WordTemplate *)allocMemory(sizeof(WordTemplate));
pTemplate->pszOrigWord = duplicateString( pszWord_in );
pTemplate->iCapital = decapitalizeWord( pTemplate, pTextCtl_in);
return pTemplate;
@}
@end smallexample
@subheading Source File
@file{allocmem.c}

@c ----------------------------------------------------------------------------
@node duplicateStringList, equivalentStringLists, duplicateString, Functions
@page
@section duplicateStringList
@subheading Syntax
@example
#include "strlist.h"    /* or strclass.h or change.h or textctl.h
						   or template.h or opaclib.h */

StringList * duplicateStringList(const StringList * pList_in);
@end example
@subheading Description
@code{duplicateStringList} copies a list of strings to create another,
identical list of strings.  If @code{pList_in} is @code{NULL}, then
@code{duplicateStringList} returns @code{NULL}.

@code{duplicateStringList} has one argument:
@table @code
@item pList_io
points to a list of strings.
@end table
@subheading Return Value
a pointer to the new list of dynamically allocated strings
@subheading Example
@smallexample
#include "strlist.h"
...
StringList * pList1;
StringList * pList2;
...
pList2 = duplicateStringList(pList1);
...
freeStringList( pList2 );
pList2 = NULL;
@end smallexample
@subheading Source File
@file{copy_sl.c}

@c ----------------------------------------------------------------------------
@node equivalentStringLists, eraseCharsInString, duplicateStringList, Functions
@page
@section equivalentStringLists
@subheading Syntax
@example
#include "strlist.h"    /* or strclass.h or change.h or textctl.h
						   or template.h or opaclib.h */

int equivalentStringLists(const StringList * pFirst_in,
						  const StringList * pSecond_in);
@end example
@subheading Description
@code{equivalentStringLists} tests whether or not two string lists
contain the same strings.  The strings do not have to be in the same
order in the two lists.  Duplicate strings in either list are
immaterial.

The arguments to @code{equivalentStringLists} are as follows:
@table @code
@item pFirst_in
points to a list of strings.

@item pSecond_in
points to another list of strings.
@end table
@subheading Return Value
nonzero (TRUE) if the lists are equal, otherwise zero (FALSE)
@subheading Example
@smallexample
#include "strlist.h"
...
StringList * pList1;
StringList * pList2;
...
if (equivalentStringLists(pList1, pList2))
	@{
	...
	@}
@end smallexample
@subheading Source File
@file{equiv_sl.c}

@c ----------------------------------------------------------------------------
@node eraseCharsInString, eraseTrie, equivalentStringLists, Functions
@page
@section eraseCharsInString
@subheading Syntax
@example
#include "opaclib.h"

char * eraseCharsInString(char *       pszString_io,
						  const char * pszEraseChars_in);
@end example
@subheading Description
@code{eraseCharsInString} erases any characters from
@code{pszEraseChars_in} that are found in @code{pszString_io}, possibly
shortening @code{pszString_io} as a side-effect.

The arguments to @code{eraseCharsInString} are as follows:
@table @code
@item pszString_io
points to the input (and output) string.

@item pszEraseChars_in
points to the characters to erase from the input string.
@end table
@subheading Return Value
a pointer to the possibly modified string
@subheading Example
@smallexample
#include "opaclib.h"    /* includes allocmem.h */
...
static char szMarkers_m[] = "-=#";
...
static int get_score(pszMarkedWord_in)
const char *    pszMarkedWord_in;
@{
char *  pszWord;
int     iScore = 0;

if (pszMarkedWord_in != NULL)
	@{
	pszWord = eraseCharsInString(duplicateString(pszMarkedWord_in),
								 szMarkers_m);
	...
	freeMemory(pszWord);
	@}
return iScore;
@}
@end smallexample
@subheading Source File
@file{erasecha.c}

@c ----------------------------------------------------------------------------
@node eraseTrie, exitSafely, eraseCharsInString, Functions
@page
@section eraseTrie
@subheading Syntax
@example
#include "trie.h"       /* or opaclib.h */

void eraseTrie(Trie *  pTrieHead_io,
			   void (* pfEraseInfo_in)(void * pList_io));
@end example
@subheading Description
@code{eraseTrie} walks through a trie, freeing all the memory allocated
for the trie and for the information it stores.

The arguments to @code{eraseTrie} are as follows:
@table @code
@item pTrieHead_io
points to the head of a trie.

@item pfEraseInfo_in
points to a function for erasing the stored information.  The function
has one argument:
@table @code
@item pList_io
points to a data collection to erase, presumably by freeing memory.
@end table
@noindent
The function does not return a value.
@end table
@subheading Return Value
none
@subheading Example
@smallexample
#include "trie.h"
#include "allocmem.h"
...
typedef struct lex_item @{
	struct lex_item *   pLink;          /* link to next element */
	struct lex_item *   pNext;          /* link to next homograph */
	unsigned char *     pszForm;        /* lexical form (word) */
	unsigned char *     pszGloss;       /* lexical gloss */
	unsigned short      uiCategory;     /* lexical category */
	@} LexItem;
...
Trie *          pLexicon_g;
unsigned long   uiLexiconCount_g;
...
static void erase_lex_item(void * pList)
@{
LexItem *       pItem;
LexItem *       pNextItem;

for ( pItem = (LexItem *)pList ; pItem ; pItem = pNextItem )
	@{
	pNextItem = pItem->pLink;
	if (pItem->pszForm != NULL)
		freeMemory(pItem->pszForm);
	if (pItem->pszGloss != NULL)
		freeMemory(pItem->pszGloss);
	freeMemory(pItem);
	@}
@}

void free_lexicon()
@{
if (pLexicon_g != NULL)
	@{
	eraseTrie(pLexicon_g, erase_lex_item);
	pLexicon_g = NULL;
	@}
uiLexiconCount_g = 0L;
@}
@end smallexample
@subheading Source File
@file{trie.c}

@c ----------------------------------------------------------------------------
@node exitSafely, fcloseWithErrorCheck, eraseTrie, Functions
@page
@section exitSafely
@subheading Syntax
@example
#include "opaclib.h"

int exitSafely(int iCode_in);
@end example
@subheading Description
@code{exitSafely} replaces @code{exit}.  When compiled for Microsoft
Windows, the program should define @code{exitSafely} to not call
@code{exit} because Windows doesn't like that very much!

@code{exitSafely} has one argument:
@table @code
@item iCode_in
is the program status code to return from the program.
@end table

@subheading Return Value
none, but it must be defined as returning int to keep everyone happy
@subheading Example
@smallexample
#include <stdlib.h>
#include "opaclib.h"
...
char *  pszCopy;
...
pszCopy = strdup("This is a test!");
if (pszCopy == NULL)
	@{
	...
	exitSafely(2);
	@}
@end smallexample
@subheading Source File
@file{safeexit.c}

@c ----------------------------------------------------------------------------
@node fcloseWithErrorCheck, findDataInTrie, exitSafely, Functions
@page
@section fcloseWithErrorCheck
@subheading Syntax
@example
#include "opaclib.h"

void fcloseWithErrorCheck(FILE *       pOutputFP_in,
						  const char * pszFilename_in);
@end example
@subheading Description
@code{fcloseWithErrorCheck} checks for the output file for write
errors, and closes it.  If an error is detected, it is reported using
@code{reportError}.

The arguments to @code{fcloseWithErrorCheck} are as follows:
@table @code
@item pOutputFP_in
is an output FILE pointer.

@item pszFilename_in
points to the name of the output file.
@end table
@subheading Return Value
none
@subheading Example
@smallexample
#include <stdio.h>
#include "opaclib.h"
...
FILE * pOutput;
char * pszFilename;
...
pOutput = fopen(pszFilename, "w");
if (pOutput != NULL)
	@{
	...
	fcloseWithErrorCheck(pOutput, pszFilename);
	pOutput = NULL;
	@}
@end smallexample
@subheading Source File
@file{errcheck.c}

@c ----------------------------------------------------------------------------
@node findDataInTrie, findStringClass, fcloseWithErrorCheck, Functions
@page
@section findDataInTrie
@subheading Syntax
@example
#include "trie.h"       /* or opaclib.h */

void * findDataInTrie(const Trie * pTrieHead_in,
					  const char * pszKey_in);
@end example
@subheading Description
@code{findDataInTrie} searches the trie for information stored using
the key for access.  The pointer returned is not guaranteed to point to
only desired information unless the length of the key is less than the
maximum depth of the trie.  You may need to scan over the list (or
array) to get exactly what you want.

The arguments to @code{findDataInTrie} are as follows:
@table @code
@item pTrieHead_in
points to the head of a trie.

@item pszKey_in
points to the key string.
@end table
@subheading Return Value
a pointer to the generic information found in the trie, or @code{NULL} if
the search fails
@subheading Example
@smallexample
#include "trie.h"
...
typedef struct lex_item @{
	struct lex_item *   pLink;          /* link to next element */
	struct lex_item *   pNext;          /* link to next homograph */
	unsigned char *     pszForm;        /* lexical form (word) */
	unsigned char *     pszGloss;       /* lexical gloss */
	unsigned short      uiCategory;     /* lexical category */
	@} LexItem;
...
Trie *          pLexicon_g;
...
LexItem * find_entries(unsigned char * pszWord_in)
@{
LexItem *       pLex;

for (   pLex = findDataInTrie(pLexicon_g, pszWord_in) ;
		pLex ;
		pLex = pLex->pLink )
	@{
	if (strcmp(pLex->pszForm, pszWord_in) == 0)
		@{
		/*
		 *  since add_lex_item() links the homographs together,
		 *  this points to a list containing only the homographs
		 */
		return pLex;
		@}
	@}
return NULL;
@}
@end smallexample
@subheading Source File
@file{trie.c}

@c ----------------------------------------------------------------------------
@node findStringClass, fitAllocStringExactly, findDataInTrie, Functions
@page
@section findStringClass
@subheading Syntax
@example
#include "strclass.h"   /* or change.h or textctl.h or template.h
						   or opaclib.h */

StringClass * findStringClass(const char *        pszName_in,
							  const StringClass * pClasses_in);
@end example
@subheading Description
@code{findStringClass} searches a list of string classes for a specific
string class by name.

The arguments to @code{findStringClass} are as follows:
@table @code
@item pszName_in
points to the name of the desired string class.

@item pClasses_in
points to a collection of string classes to search.
@end table
@subheading Return Value
a pointer to the string class found, or @code{NULL} if not found
@subheading Example
@smallexample
#include "strclass.h"
#include "rpterror.h"
...
static StringClass *    pClasses_m = NULL;
...
StringClass *   pClass;
char *          pszClassName;
...
pClass = findStringClass( pszClassName, pClasses_m);
if (pClass == NULL)
	reportError(WARNING_MSG, "Undefined class %s\n", pszName);
...
@end smallexample
@subheading Source File
@file{strcla.c}

@c ----------------------------------------------------------------------------
@node fitAllocStringExactly, fixSynthesizedWord, findStringClass, Functions
@page
@section fitAllocStringExactly
@subheading Syntax
@example
#include "allocmem.h"   /* or opaclib.h */

char * fitAllocStringExactly(char * pszString_in);
@end example
@subheading Description
@code{fitAllocStringExactly} shrinks the allocated buffer to exactly
fit the string.  The program is aborted with an error message if it
somehow runs out of memory.
@ifset txt
(See @code{allocMemory} above
@end ifset
@ifclear txt
(@xref{allocMemory},
@end ifclear
for details about this error message.)

@code{fitAllocStringExactly} has one argument:
@table @code
@item pszString_in
points to a string in a possibly overlarge allocated buffer.
@end table
@subheading Return Value
a pointer to the (possibly) reallocated block
@subheading Example
@smallexample
#include <stdio.h>
#include "allocmem.h"
...
char * read_line(FILE * pInputFP_in)
@{
char *  pszBuffer;
size_t  uiBufferSize = 500;
size_t  uiLineLength;

if ((pInputFP_in == NULL) || feof(pInputFP_in))
	return NULL;
pszBuffer = allocMemory(uiBufferSize);
if (fgets(pszBuffer, uiBufferSize, pInputFP_in) == NULL)
	@{
	freeMemory(pszBuffer);
	return NULL;
	@}
while (strchr(pszBuffer, '\n') == NULL)
	@{
	uiBufferSize += 500;
	pszBuffer = reallocMemory(pszBuffer, uiBufferSize);
	uiLineLength = strlen(pszBuffer);
	if (fgets(pszBuffer + uiLineLength,
			  uiBufferSize - uiLineLength, pInputFP_in) == NULL)
		break;
	@}
return fitAllocStringExactly( pszBuffer );
@}
@end smallexample
@subheading Source File
@file{allocmem.c}

@c ----------------------------------------------------------------------------
@node fixSynthesizedWord, fopenAlways, fitAllocStringExactly, Functions
@page
@section fixSynthesizedWord
@subheading Syntax
@example
#include "opaclib.h"

void fixSynthesizedWord(WordTemplate *      pTemplate_io,
						const TextControl * pTextCtl_in);
@end example
@subheading Description
@code{fixSynthesizedWord} applies the output orthography changes and
recapitalization to the list of synthesized wordforms.  The list is
updated to reflect these changes, and to minimize any ensuing
ambiguity.

The arguments to @code{fixSynthesizedWord} are as follows:
@table @code
@item pTemplate_io
points to a data structure that contains the (possibly ambiguous)
word synthesis list and capitalization information.

@item pTextCtl_in
points to a data structure that contains orthographic information.
@end table
@subheading Return Value
none
@subheading Example
@smallexample
#include "template.h"
...
TextControl     sTextControl_g;
...
FILE *          pInputFP;
FILE *          pOutputFP;
WordTemplate *  pWord;
...
for (;;)
	@{
	pWord = readTemplateFromAnalysis(pInputFP, &sTextControl_g);
	if (pWord == NULL)
		break;
	pWord->pNewWords = synthesize_word(pWord->pAnalyses,
									   &sTextControl_g);
	fixSynthesizedWord(pWord, &TextControl_g);
	writeTextFromTemplate( pOutputFP, pWord, &sTextControl_g);
	freeWordTemplate( pWord );
	@}
@end smallexample
@subheading Source File
@file{textout.c}

@c ----------------------------------------------------------------------------
@node fopenAlways, freeChangeList, fixSynthesizedWord, Functions
@page
@section fopenAlways
@subheading Syntax
@example
#include "opaclib.h"

FILE * fopenAlways(char *       pszFilename_io,
				   const char * pszMode_in);
@end example
@subheading Description
@code{fopenAlways} opens a file, prompting the user if necessary and
retrying until successful.  If it is not @code{NULL},
@code{pszFilename_io} is updated to contain the name of the file
actually opened.  @code{fopenAlways} uses @code{fopen} to open the
file, and repeatedly prompts the user for a filename if @code{fopen}
fails.

The buffer pointed to by pszFilename_io must be (at least)
@code{FILENAME_MAX} bytes long.  If @code{FILENAME_MAX} is not defined
by @file{stdio.h}, then it is assumed to be 128.

@table @code
@item pszFilename_io
points to a buffer for holding the name of the file, or is
@code{NULL}.

@item pszMode_in
points to an @code{fopen} mode string (usually @code{"r"} or
@code{"w"}).
@end table
@subheading Return Value
a valid FILE pointer
@subheading Example
@smallexample
#include <stdio.h>
#include "opaclib.h"
...
FILE * pInputFP;
char   szFilename[FILENAME_MAX];
...
pInputFP = fopenAlways(szFilename, "r");
...
fclose(pInputFP);
pInputFP = NULL;
@end smallexample
@subheading Source File
@file{ufopen.c}

@c ----------------------------------------------------------------------------
@node freeChangeList, freeCodeTable, fopenAlways, Functions
@page
@section freeChangeList
@subheading Syntax
@example
#include "change.h"     /* or textctl.h or template.h or opaclib.h */

void freeChangeList(Change * pList_io);
@end example
@subheading Description
@code{freeChangeList} frees the memory allocated for a list of
consistent change structures.

@code{freeChangeList} has one argument:
@table @code
@item pList_io
points to a list of consistent change structures.
@end table
@subheading Return Value
none
@subheading Example
@smallexample
#include "change.h"
...
Change * pChangeList_g;
...
void add_change(char * pszChange_in)
@{
Change * pTail;
if (pChangeList_g == NULL)
	pChangeList_g = parseChangeString( pszChange_in );
else
	@{
	for (pTail = pChangeList_g ; pTail->pNext ; pTail = pTail->pNext)
		;
	pTail->pNext = parseChangeString( pszChange_in );
	@}
@}
...
freeChangeList( pChangeList_g );
pChangeList_g = NULL;
@end smallexample
@subheading Source File
@file{change.c}

@c ----------------------------------------------------------------------------
@node freeCodeTable, freeMemory, freeChangeList, Functions
@page
@section freeCodeTable
@findex freeCodeTable
@subheading Syntax
@example
#include "record.h"

void freeCodeTable(CodeTable * pCodeTable_io);
@end example
@subheading Description
@code{freeCodeTable} frees the memory allocated for a @code{CodeTable}
data structure.

@code{freeCodeTable} has only one argument:
@table @code
@item pCodeTable_io
points to a @code{CodeTable} data structure that contains information
that is no longer needed.
@end table
@subheading Return Value
none
@subheading Example
@smallexample
#include "record.h"
#include "ample.h"

AmpleData sAmpleData_g;
char szCodesFilename_g[100];
char szDictFilename_g[100];
...
loadAmpleDictCodeTables(szCodesFilename_g, &sAmpleData_g, FALSE);
...
loadAmpleDictionary(szDictFilename_g, PFX, &sAmpleData_g);
freeCodeTable( sAmpleData_g.pPrefixTable );
sAmpleData_g.pPrefixTable = NULL;
@end smallexample
@subheading Source File
@file{free_ct.c}

@c ----------------------------------------------------------------------------
@node freeMemory, freeStringClasses, freeCodeTable, Functions
@page
@section freeMemory
@subheading Syntax
@example
#include "allocmem.h"   /* or opaclib.h */

void freeMemory(void * pBlock_io);
@end example
@subheading Description
@code{freeMemory} provides a ``safe'' interface to @code{free}.  It
ignores @code{NULL} as an argument.  (But passing @code{NULL} is still
poor practice!)  This is the only protection added to @code{free}:
passing random memory addresses to @code{freeMemory}, or passing the
same address twice, will result in memory corruption and program
crashes!

@code{freeMemory} has one argument:
@table @code
@item pBlock_io
points to a dynamically allocated block of memory to deallocate.
@end table
@subheading Return Value
none
@subheading Example
@smallexample
#include <stdio.h>
#include "allocmem.h"
...
char * read_line(FILE * pInputFP_in)
@{
char *  pszBuffer;
size_t  uiBufferSize = 500;
size_t  uiLineLength;

if ((pInputFP_in == NULL) || feof(pInputFP_in))
	return NULL;
pszBuffer = allocMemory(uiBufferSize);
if (fgets(pszBuffer, uiBufferSize, pInputFP_in) == NULL)
	@{
	freeMemory(pszBuffer);
	return NULL;
	@}
return pszBuffer;
@}
@end smallexample
@subheading Source File
@file{allocmem.c}

@c ----------------------------------------------------------------------------
@node freeStringClasses, freeStringList, freeMemory, Functions
@page
@section freeStringClasses
@subheading Syntax
@example
#include "strclass.h"   /* or change.h or textctl.h or template.h
						   or opaclib.h */

void freeStringClasses(StringClass * pClasses_io);
@end example
@subheading Description
@code{freeStringClasses} frees the memory allocated for the list of
string classes.

@code{freeStringClasses} has one argument:
@table @code
@item pClasses_io
points to a list of string classes.
@end table
@subheading Return Value
none
@subheading Example
@smallexample
#include "change.h"     /* includes strclass.h */
...
static Change *         pChanges_m;
static StringClass *    pClasses_m;
...
void free_change_info()
@{
freeChangeList( pChanges_m );
freeStringClasses( pClasses_m );
pChanges_m = NULL;
pClasses_m = NULL;
@}
@end smallexample
@subheading Source File
@file{strcla.c}

@c ----------------------------------------------------------------------------
@node freeStringList, freeWordAnalysisList, freeStringClasses, Functions
@page
@section freeStringList
@subheading Syntax
@example
#include "strlist.h"    /* or strclass.h or change.h or textctl.h
						   or template.h or opaclib.h */

void freeStringList(StringList * pList_io);
@end example
@subheading Description
@code{freeStringList} deletes a list of strings, freeing all the memory
used by the list of strings.

@code{freeStringList} has one argument:
@table @code
@item pList_io
points to a list of strings.
@end table
@subheading Return Value
none
@subheading Example
@smallexample
#include "strlist.h"
...
StringList * pNames_g;
...
freeStringList(pNames_g);
pNames_g = NULL;
...
@end smallexample
@subheading Source File
@file{free_sl.c}

@c ----------------------------------------------------------------------------
@node freeWordAnalysisList, freeWordTemplate, freeStringList, Functions
@page
@section freeWordAnalysisList
@subheading Syntax
@example
#include "template.h"

void freeWordAnalysisList(WordAnalysis * pAnalyses_io);
@end example
@subheading Description
@code{freeWordAnalysisList} frees the memory allocated for a list of
@code{WordAnalysis} data structures.

@code{freeWordAnalysisList} has one argument:
@table @code
@item pAnalyses_io
points to a list of @code{WordAnalysis} data structures.
@end table
@subheading Return Value
none
@subheading Example
@smallexample
#include "template.h"
...
WordTemplate *	pWord;
...
if (pWord->pAnalyses != NULL)
	freeWordAnalysisList(pWord->pAnalyses);
...
@end smallexample
@subheading Source File
@file{wordanal.c}

@c ----------------------------------------------------------------------------
@node freeWordTemplate, getAndClearAllocMemorySum, freeWordAnalysisList, Functions
@page
@section freeWordTemplate
@subheading Syntax
@example
#include "template.h"   /* or opaclib.h */

void freeWordTemplate(WordTemplate * pWord_io);
@end example
@subheading Description
@code{freeWordTemplate} frees everything in a @code{WordTemplate} data
structure, including the structure itself.

@code{freeWordTemplate} has one argument:
@table @code
@item pWord_io
points to a @code{WordTemplate} data structure to free.
@end table
@subheading Return Value
none
@subheading Example
@smallexample
#include "template.h"
...
TextControl sTextCtl_g;
...
WordAnalysis * merge_analyses(
	WordAnalysis *  pList_in,
	WordAnalysis *  pAnal_in)
@{
...
@}
...
void process(
	FILE * pInputFP_in,
	FILE * pOutputFP_in)
@{
WordTemplate *  pWord;
WordAnalysis *  pAnal;
unsigned        uiAmbiguityCount;
unsigned long   uiWordCount;

for ( uiWordCount = 0L ;; )
	@{
	pWord = readTemplateFromText(pInputFP_in, &sTextCtl_g);
	if (pWord == NULL)
		break;
	uiAmbiguityCount = 0;
	if (pWord->paWord != NULL)
		@{
		for ( i = 0 ; pWord->paWord[i] ; ++i )
			@{
			pAnal = analyze(pWord->paWord[i]);
			pWord->pAnalyses = merge_analyses(pWord->pAnalyses,
											  pAnal);
			@}
		for (pAnal = pWord->pAnalyses ; pAnal ; pAnal = pAnal->pNext)
			++uiAmbiguityCount;
		@}
	uiWordCount = showAmbiguousProgress(uiAmbiguityCount,
										uiWordCount);
	writeTemplate(pOutputFP_in, NULL, pWord, &sTextCtl_g);
	freeWordTemplate(pWord);
	@}
@}
@end smallexample
@subheading Source File
@file{free_wt.c}

@c ----------------------------------------------------------------------------
@node getAndClearAllocMemorySum, getChangeQuote, freeWordTemplate, Functions
@page
@section getAndClearAllocMemorySum
@subheading Syntax
@example
#include "allocmem.h"   /* or opaclib.h */

unsigned long getAndClearAllocMemorySum(void);
@end example
@subheading Description
@code{getAndClearAllocMemorySum} returns the amount of memory used by
@code{allocMemory} calls since the last call to
@code{getAndClearAllocMemorySum}.  It does not account for calls to
@code{freeMemory}, which greatly reduces its accuracy.

@code{getAndClearAllocMemorySum} does not have any arguments.
@subheading Return Value
the number of bytes of memory requested by @code{allocMemory} calls
since the last call to @code{getAndClearAllocMemorySum}
@subheading Example
@smallexample
#include <stdio.h>
#include "allocmem.h"
...
getAndClearAllocMemorySum();    /* reset the counter */
...
p = allocMemory(500);
...
p = duplicateString("this is a test");
...
printf("%lu bytes allocated recently\n", getAndClearAllocMemorySum());
@end smallexample
@subheading Source File
@file{allocmem.c}

@c ----------------------------------------------------------------------------
@node getChangeQuote, getStringListSize, getAndClearAllocMemorySum, Functions
@page
@section getChangeQuote
@subheading Syntax
@example
#include "change.h"     /* or textctl.h or template.h or opaclib.h */

int getChangeQuote(const char * pszMatch_in,
				   const char * pszReplace_in);
@end example
@subheading Description
@code{getChangeQuote} finds a suitable ``quote'' character that is not
used in either input string.

The arguments to @code{getChangeQuote} are as follows:
@table @code
@item pszMatch_in
points to the string to change from.

@item pszReplace_in
points to the string to change to.
@end table
@subheading Return Value
a character suitable for quoting the match and replace strings
@subheading Example
@smallexample
#include <string.h>
#include "change.h"
#include "allocmem.h"

char * composeChangeString(pszMatch_in, pszReplace_in, pszEnvir_in)
const char *    pszMatch_in;
const char *    pszReplace_in;
const char *    pszEnvir_in;
@{
char *  pszChange;
size_t  uiLength;
char    cQuote;

if ((pszMatch_in == NULL) && (pszReplace_in == NULL))
	return NULL;
if (pszMatch_in == NULL)
	pszMatch_in = "";
if (pszReplace_in == NULL)
	pszReplace_in = "";

uiEnvirLength   = strlen( pszEnvir_in );
uiLength = strlen( pszMatch_in ) + strlen( pszReplace_in ) + 6;
if ((pszEnvir_in != NULL) && (*pszEnvir_in != '\0'))
	uiLength += strlen( pszEnvir_in ) + 1;
pszChange = allocMemory(uiLength);

cQuote = getChangeQuote(pszMatch_in, pszReplace_in);

sprintf(pszChange, "%c%s%c %c%s%c",
		cQuote, pszMatch_in, cQuote, cQuote, pszReplace_in, cQuote);
if ((pszEnvir_in != NULL) && (*pszEnvir_in != '\0'))
	strcat(strcat(pszChange, " "), pszEnvir_in);

return pszChange;
@}
@end smallexample
@subheading Source File
@file{change.c}

@c ----------------------------------------------------------------------------
@node getStringListSize, identicalStringLists, getChangeQuote, Functions
@page
@section getStringListSize
@subheading Syntax
@example
#include "strlist.h"    /* or strclass.h or change.h or textctl.h
						   or template.h or opaclib.h */

unsigned getStringListSize(const StringList * pList_in);
@end example
@subheading Description
@code{getStringListSize} counts the number of strings stored in the
list.  It does not check for duplicate strings or for @code{NULL}
string pointers, just for the total number of data structures linked
together.

@code{getStringListSize} has one argument:
@table @code
@item pList_in
points to a list of strings.
@end table
@subheading Return Value
the number of strings in the list
@subheading Example
@smallexample
#include <stdio.h>
#include "strlist.h"
...
void writeAmbigWords(pList_in, cAmbig_in, pOutputFP_in)
const StringList * pList_in;
int                cAmbig_in;
FILE *             pOutputFP_in;
@{
char    szAmbig[2];

if (pList_in == NULL)
	fprintf(pOutputFP_in, "%c0%c%c", cAmbig_in, cAmbig_in, cAmbig_in);
else if (pList_in->pNext)
	@{
	fprintf(pOutputFP_in, "%c%u%c",
			cAmbig_in, getStringListSize(pList_in), cAmbig_in );
	szAmbig[0] = cAmbig_in;
	szAmbig[1] = '\0';
	writeStringList( pList_in, szAmbig, pOutputFP_in );
	fprintf(pOutputFP_in, "%c", cAmbig_in);
	@}
else
	fputs(pList_in->pszString, pOutputFP_in);
@}
@end smallexample
@subheading Source File
@file{size_sl.c}

@c ----------------------------------------------------------------------------
@node identicalStringLists, isMemberOfStringList, getStringListSize, Functions
@page
@section identicalStringLists
@subheading Syntax
@example
#include "strlist.h"    /* or strclass.h or change.h or textctl.h
						   or template.h or opaclib.h */

int identicalStringLists(const StringList * pFirstList_in,
						 const StringList * pSecondList_in);
@end example
@subheading Description
@code{identicalStringLists} checks whether or not two lists of strings
are identical, that is, whether they have the same strings in the same
order.

The arguments to @code{identicalStringLists} are as follows:
@table @code
@item pFirstList_in
points to a list of strings.

@item pSecondList_in
points to another list of strings.
@end table
@subheading Return Value
nonzero (TRUE) if the lists are identical, otherwise zero (FALSE)
@subheading Example
@smallexample
#include "strlist.h"
...
StringList * pList1;
StringList * pList2;
...
if (identicalStringLists(pList1, pList2))
	@{
	...
	@}
@end smallexample
@subheading Source File
@file{equal_sl.c}

@c ----------------------------------------------------------------------------
@node isMemberOfStringList, isolateWord, identicalStringLists, Functions
@page
@section isMemberOfStringList
@subheading Syntax
@example
#include "strlist.h"    /* or strclass.h or change.h or textctl.h
						   or template.h or opaclib.h */

int isMemberOfStringList(const StringList * pList_in,
						 const char *       pszString_in);
@end example
@subheading Description
@code{isMemberOfStringList} checks whether a string is stored in a list
of strings.

The arguments to @code{isMemberOfStringList} are as follows:
@table @code
@item pList_in
points to a list of strings.

@item pszString_in
points to the string to be checked.
@end table
@subheading Return Value
nonzero (TRUE) if the string is found in the list, otherwise zero (FALSE)
@subheading Example
@smallexample
#include "strlist.h"
...
static StringList *  pFiles_m = NULL;
...
void processFileOnce(const char * pszFile_in)
@{
if ((pszFile_in != NULL) && !isMemberOfStringList(pFiles_m, pszFile_in))
	@{
	pFiles_m = mergeIntoStringList(pFiles_m, pszFile_in);
	...
	@}
@}
@end smallexample
@subheading Source File
@file{membr_sl.c}

@c ----------------------------------------------------------------------------
@node isolateWord, isStringClassMember, isMemberOfStringList, Functions
@page
@section isolateWord
@subheading Syntax
@example
#include "opaclib.h"

char * isolateWord(char * pszLine_io);
@end example
@subheading Description
@code{isolateWord} isolates the ``word'' pointed to by its argument by
replacing the first whitespace character following the word with a @code{NUL}
character.  It then steps the pointer to the beginning of the next
``word'' in the input string.

@code{isolateWord} skips over any leading whitespace in the input string
before trying to isolate a ``word''.

@code{isolateWord} has one argument:
@table @code
@item pszLine_io
points to a @code{NUL}-terminated character string.
@end table
@subheading Return Value
a pointer to the first character of the next following word, which may be
the @code{NUL} character at the end of the input string
@subheading Example
@smallexample
#include <string.h>
#include "opaclib.h"    /* includes strlist.h */
...
StringList * pTraceMorphs_m = NULL;
...
void addTraceMorphs(char * pszLine_in)
@{
char *  pszMorph;
char *  pszEnd;

if (pszLine_in == NULL)
	return;
for (   pszMorph = pszLine_in + strspn(pszLine_in, " \r\n\t\f\v");
		*pszMorph_in ;
		pszMorph = pszEnd )
	@{
	pszEnd = isolateWord( pszMorph );   /* isolate the morpheme */
	if (strcmp(pszMorph, "0") == 0)     /* If 0, put in NUL */
		*pszMorph = NUL;
	pTraceMorphs_m = mergeIntoStringList(pTraceMorphs_m, pszMorph);
	@}
@}
@end smallexample
@subheading Source File
@file{isolatew.c}

@c ----------------------------------------------------------------------------
@node isStringClassMember, loadIntxCtlFile, isolateWord, Functions
@page
@section isStringClassMember
@subheading Syntax
@example
#include "strclass.h"   /* or change.h or textctl.h or template.h
						   or opaclib.h */

int isStringClassMember(const char *        pszString_in,
						const StringClass * pClass_in);
@end example
@subheading Description
@code{isStringClassMember} searches a string class for a specific
string.

The arguments to @code{isStringClassMember} are as follows:
@table @code
@item pszString_in
points to the string to look for.

@item pClass_in
points to a string class.
@end table
@subheading Return Value
nonzero (TRUE) if the string is found in the class, otherwise zero (FALSE)
@subheading Example
@smallexample
#include "strclass.h"
...
static StringClass *    pClasses_m;
...
int isClassMember(const char * pszString_in,
				  const char * pszClassName_in)
@{
StringClass *   pClass;

pClass = findStringClass(pszClassName_in, pClasses_m);
if (pClass == NULL)
	return 0;
return isStringClassMember(pszString_in, pClass);
@}
@end smallexample
@subheading Source File
@file{strcla.c}

@c ----------------------------------------------------------------------------
@node loadIntxCtlFile, loadOutxCtlFile, isStringClassMember, Functions
@page
@section loadIntxCtlFile
@subheading Syntax
@example
#include "textctl.h"    /* or template.h or opaclib.h */

int loadIntxCtlFile(const char *   pszFilename_in,
					int            cComment_in,
					TextControl *  pTextCtl_out,
					StringClass ** ppStringClasses_io);
@end example
@subheading Description
@code{loadIntxCtlFile} loads a text input control file into memory.
This is a standard format file containing one data record with the
following fields (not necessarily in this order):
@table @code
@item \ambig
defines the character used to mark ambiguities in the output after
processing.  (This does not really belong in a ``text input'' control
file, but exists for historical reasons and is kept for compatibility.)
The @code{\ambig} field is optional, and may occur only once.

@item \barchar
defines the character used to start a short formatting command that
consists of this character and the immediately following character.
Its name comes from the use of the vertical bar character (@code{|}) in
the S.I.L. Manuscripter program in the early 1980's.  The
@code{\barchar} field is optional, and may occur only once.  An empty
field disables this feature.

@item \barcodes
defines the characters allowed to follow the @code{\barchar} character
to form formatting commands.  Whitespace (spaces, tabs, or newlines) in
this field is optional.  The @code{\barcodes} field is optional, and
may occur any number of times.  Its effect is cumulative.

@item \ch
defines an input othography change to apply to words after they have
been decapitalized, but before any other processing takes place.  A
change consists of two or three parts, in this order: a match string, a
replace string, and an optional environment.  The match string and
replace string must be quoted by some character that does not appear in
either string.  (ASCII single quotes and double quotes are most often
used for this purpose.)  The syntax of the environment is too
complicated to discuss here: see Weber 1988 (pages 68-74, 82-83,
and 86-90) for details.  The @code{\ch} field is optional, and may
occur any number of times.  An ordered list of consistent changes is
built by the function.  Each change is applied to each input word as
many times as necessary before the next change is applied.

@item \dsc
defines the character used to segment words in the output after
processing.  This is typically for dividing words into morphemes.
(This does not really belong in a ``text input'' control file, but
exists for historical reasons and is kept for compatibility.)  The
@code{\dsc} field is optional, and may occur only once.

@item \excl
specifies one or more ``fields'' to exclude from processing in the
input file.  Fields in the input file are marked by formatting commands
such as those defined by the @code{\format} field in the text input
control file.  The @code{\excl} field lists one or more field codes
(formatting commands) complete with the leading @code{\format}
character.  Field codes are separated by whitespace (spaces, tabs, or
newlines).  The @code{\excl} field is optional, and may occur any
number of times.  Its effect is cumulative.  If any @code{\excl} fields
occur, then no @code{\incl} fields are allowed, and all fields in the
input file that are not explicitly listed in a @code{\excl} field will
be processed.

@item \format
defines the character used to start a formatting command in the input
text.  The formatting command is assumed to consist of this characters
and all following contiguous nonwhitespace characters.  The
@code{\format} field is optional, and may occur only once.

@item \incl
specifies one or more ``fields'' to include in processing in the input
file.  Fields in the input file are marked by formatting commands such
as those defined by the @code{\format} field in the text input control
file.  The @code{\incl} field lists one or more field codes (formatting
commands) complete with the leading @code{\format} character.  Field
codes are separated by whitespace (spaces, tabs, or newlines).  The
@code{\incl} field is optional, and may occur any number of times.  Its
effect is cumulative.  If any @code{\incl} fields occur, then no
@code{\excl} fields are allowed, and only those fields in the input
file that are explicitly listed in a @code{\incl} field will be
processed.

@item \luwfc
defines one or more ``word formation characters'' that have distinct
lowercase and uppercase forms.  The lowercase form is given first and
must be followed by its uppercase form.  The functions that use this
information allow several lowercase characters to map onto a single
uppercase character, and one lowercase character to map onto several
uppercase characters.  Whitespace (spaces, tabs, or newlines) in this
field is optional.  The @code{\luwfc} field is optional, and may occur
any number of times.  Its effect is cumulative.  For lowercase and
uppercase forms that are represented by two or more adjacent characters
(bytes), use the @code{\luwfcs} field described below.

@item \luwfcs
defines one or more ``word formation character multigraphs'' that have
distinct lowercase and uppercase forms.  The lowercase form is given
first and must be followed by its uppercase form.  The functions that use
this information allow several lowercase character multigraphs to map
onto a single uppercase character multigraph, and one lowercase character
multigraph to map onto several uppercase character multigraphs.
Whitespace (spaces, tabs, or newlines) in this field is significant: each
multigraph is separated from its neighbors by one or more whitespace
characters.  The @code{\luwfcs} field is optional, and may occur any
number of times.  Its effect is cumulative.  Note that @code{\luwfcs}
fields may be used to replace @code{\luwfc} fields, or the two types of
fields may be mixed together in the control file.

The implementation underlying the @code{\luwfcs} field does not require
that the lowercase and uppercase forms occupy the same number of
characters (bytes).

@item \maxdecap
defines the maximum number of alternative decapitalizations to produce
when multiple lowercase characters map onto a single uppercase
character.  This probably matters only for handling words that are
entirely capitalized, as the number of alternatives can grow very
rapidly with the length of the word.  The @code{\maxdecap} field is
optional, and may occur only once.

@item \nocap
dictates that the orthography does not use capitalization at all.  If
this field is present, then the @code{\luwfc} and @code{\luwfcs} fields
should not be used.  The @code{\nocap} field is optional, and may occur
only once.

@item \noincap
dictates that capitalization applies to only the first character of a
word, or to all characters of a word, but not to individual characters.
That is, it tells to program not to attempt to deal with names
like @samp{McConnel}.  The @code{\noincap} field is optional, and may
occur only once.

@item \scl
defines a string class, presumably for use by one or more orthography
input changes.  The first item in the field is the name of the class.
All other items are members of the class.  Items are separated by
whitespace (spaces, tabs, or newlines).  The @code{\scl} field is
optional, and any number of string classes may be defined.  A string
class definition must occur before any @code{\ch} field that uses that
string class.

@item \wfc
defines one or more ``word formation characters'' that do not have
distinct lowercase and uppercase forms.  Whitespace (spaces, tabs, or
newlines) in this field is optional.  The @code{\wfc} field is
optional, and may occur any number of times.  Its effect is cumulative.
For caseless forms that are represented by two or more adjacent characters
(bytes), use the @code{\wfcs} field described below.

@item \wfcs
defines one or more multibyte ``word formation characters'' that do not
have distinct lowercase and uppercase forms.  Whitespace (spaces, tabs,
or newlines) in this field is required to separate the different
multibyte characters.  The @code{\wfcs} field is optional, and may occur
any number of times.  Its effect is cumulative.  Note that @code{\wfcs}
fields may be used to replace @code{\wfc} fields, or the two types of
fields may be mixed together in the control file.
@end table
@noindent
For more details about this file, see
@ifset txt
the AMPLE Reference Manual, section 8 `Text Input Control File'.
@end ifset
@ifclear txt
@ref{Text input control file, , Text Input Control File, ample.info,
AMPLE Reference Manual}.
@end ifclear

The arguments to @code{loadIntxCtlFile} are as follows:
@table @code
@item pszFilename_in
points to the name of the text input control file.

@item cComment_in
is the character used to initiate comments on lines in the file.

@item pTextCtl_out
points to a data structure for storing information read from the file.

@item ppStringClasses_io
is the address of a pointer to a set of string classes possibly used by
@code{\ch} fields or added to by @code{\scl} fields.
@end table
@subheading Return Value
zero if successful, nonzero if an error occurs
@subheading Example
@smallexample
#include <stdio.h>
#include "textctl.h"    /* includes strclass.h */
#include "rpterror.h"
...
char               szIntxFilename_g[200];
TextControl        sTextControl_g;
StringClass *      pStringClasses_g = NULL;
static TextControl sDefaultTextControl_m = @{
	NULL,       /* filename */
	NULL,       /* ordered array of lowercase letters */
	NULL,       /* ordered array of matching uppercase letters */
	NULL,       /* array of caseless letters */
	NULL,       /* list of input orthography changes */
	NULL,       /* list of output (orthography) changes */
	NULL,       /* list of format markers (fields) to include */
	NULL,       /* list of format markers (fields) to exclude */
	'\\',       /* initial character of format markers (field codes) */
	'%',        /* character for marking ambiguities and failures */
	'-',        /* character for marking decomposition */
	'|',        /* initial character of secondary format markers */
	NULL,       /* (Manuscripter) bar codes */
	TRUE,       /* flag whether to capitalize individual letters */
	TRUE,       /* flag whether to decapitalize/recapitalize */
	100         /* maximum number of decapitalization alternatives */
	@};
...
memcpy(&sTextControl_g, &sDefaultTextControl_m, sizeof(TextControl));
fprintf(stderr, "Text Control File (xxINTX.CTL) [none]: ");
fgets( szIntxFilename_g, 200, stdin );
if (szIntxFilename_g[0])
	@{
	if (loadIntxCtlFile(szIntxFilename_g, ';',
						sTextControl_g, pStringClasses_g) != 0)
		@{
		reportError(ERROR_MSG, "Error reading text control file %s\n",
					szIntxFilename_g);
		@}
	@}
if (    (sTextControl_g.cBarMark == NUL) &&
		(sTextControl_g.pszBarCodes != NULL) )
	@{
	freeMemory(sTextControl_g.pszBarCodes);
	sTextControl_g.pszBarCodes = NULL;
	@}
if (    (sTextControl_g.cBarMark != NUL) &&
		(sTextControl_g.pszBarCodes == NULL) )
	@{
	sTextControl_g.pszBarCodes = (unsigned char *)duplicateString(
													"bdefhijmrsuvyz");
	@}
@end smallexample
@subheading Source File
@file{loadintx.c}

@c ----------------------------------------------------------------------------
@node loadOutxCtlFile, matchAlphaChar, loadIntxCtlFile, Functions
@page
@section loadOutxCtlFile
@subheading Syntax
@example
#include "textctl.h"    /* or template.h or opaclib.h */

int loadOutxCtlFile(const char *   pszFilename_in,
					int            cComment_in,
					TextControl *  pTextCtl_out,
					StringClass ** ppStringClasses_io);
@end example
@subheading Description
@code{loadOutxCtlFile} loads a text output control file into memory.
This is a standard format file containing one data record with the
following fields (not necessarily in this order):
@table @code
@item \ambig
defines the character used to mark ambiguities in the output after
processing.  The @code{\ambig} field is optional, and may occur only
once.

@item \ch
defines an output othography change to apply to words after they have
processed, but before they are recapitalized.  A change consists of two
or three parts, in this order: a match string, a replace string, and an
optional environment.  The match string and replace string must be
quoted by some character that does not appear in either string.  (ASCII
single quotes and double quotes are most often used for this purpose.)
The syntax of the environment is too complicated to discuss here: see
Weber 1988 (pages 68-74, 82-83, and 86-90) for details.  The
@code{\ch} field is optional, and may occur any number of times.  An
ordered list of consistent changes is built by the function.  Each
change is applied to each output word as many times as necessary before
the next change is applied.

@item \dsc
defines the character used to segment words in the output after
processing.  This is typically for dividing words into morphemes.
(This does not really belong in a ``text output'' control file, but
exists for historical reasons and is kept for compatibility.)  The
@code{\dsc} field is optional, and may occur only once.

@item \format
defines the character used to start a formatting command in the input
text.  The formatting command is assumed to consist of this characters
and all following contiguous nonwhitespace characters.  The
@code{\format} field is optional, and may occur only once.

@item \luwfc
defines one or more ``word formation characters'' that have distinct
lowercase and uppercase forms.  The lowercase form is given first and
must be followed by its uppercase form.  The functions that use this
information allow several lowercase characters to map onto a single
uppercase character, and one lowercase character to map onto several
uppercase characters.  Whitespace (spaces, tabs, or newlines) in this
field is optional.  The @code{\luwfc} field is optional, and may occur
any number of times.  Its effect is cumulative.  For lowercase and
uppercase forms that are represented by two or more adjacent characters
(bytes), use the @code{\luwfcs} field described below.

@item \luwfcs
defines one or more ``word formation character multigraphs'' that have
distinct lowercase and uppercase forms.  The lowercase form is given
first and must be followed by its uppercase form.  The functions that use
this information allow several lowercase character multigraphs to map
onto a single uppercase character multigraph, and one lowercase character
multigraph to map onto several uppercase character multigraphs.
Whitespace (spaces, tabs, or newlines) in this field is significant: each
multigraph is separated from its neighbors by one or more whitespace
characters.  The @code{\luwfcs} field is optional, and may occur any
number of times.  Its effect is cumulative.  Note that @code{\luwfcs}
fields may be used to replace @code{\luwfc} fields, or the two types of
fields may be mixed together in the control file.

The implementation underlying the @code{\luwfcs} field does not require
that the lowercase and uppercase forms occupy the same number of
characters (bytes).

@item \scl
defines a string class, presumably for use by one or more orthography
output changes.  The first item in the field is the name of the class.
All other items are members of the class.  Items are separated by
whitespace (spaces, tabs, or newlines).  The @code{\scl} field is
optional, and any number of string classes may be defined.  A string
class definition must occur before any @code{\ch} field that uses that
string class.

@item \wfc
defines one or more ``word formation characters'' that do not have
distinct lowercase and uppercase forms.  Whitespace (spaces, tabs, or
newlines) in this field is optional.  The @code{\wfc} field is
optional, and may occur any number of times.  Its effect is cumulative.
For caseless forms that are represented by two or more adjacent characters
(bytes), use the @code{\wfcs} field described below.

@item \wfcs
defines one or more multibyte ``word formation characters'' that do not
have distinct lowercase and uppercase forms.  Whitespace (spaces, tabs,
or newlines) in this field is required to separate the different
multibyte characters.  The @code{\wfcs} field is optional, and may occur
any number of times.  Its effect is cumulative.  Note that @code{\wfcs}
fields may be used to replace @code{\wfc} fields, or the two types of
fields may be mixed together in the control file.
@end table
Note that these are only a subset of the fields allowed in a text input
control file.
@noindent
For more details about this file, see
@ifset txt
the KTEXT Reference Manual, section 8 `Text Output Control File'.
@end ifset
@ifclear txt
@ref{Text output control file, , The text output control file,
ktext.info, KTEXT Reference Manual}.
@end ifclear

The arguments to @code{loadOutxCtlFile} are as follows:
@table @code
@item pszFilename_in
points to the name of the text output control file.

@item cComment_in
is the character used to initiate comments on lines in the file.

@item pTextCtl_out
points to a data structure for storing information read from the
file.

@item ppStringClasses_io
is the address of a pointer to a set of string classes possibly used by
@code{\ch} fields or added to by @code{\scl} fields.
@end table
@subheading Return Value
zero if successful, nonzero if an error occurs
@subheading Example
@smallexample
#include <stdio.h>
#include "textctl.h"    /* includes strclass.h */
#include "rpterror.h"
...
char               szOutxFilename_g[200];
TextControl        sOutputControl_g;
StringClass *      pStringClasses_g = NULL;
...
memset(&sOutputControl_g, 0, sizeof(TextControl));
fprintf(stderr, "Text Output Control File (xxOUTX.CTL) [none]: ");
fgets(szOutxFilename_g, 200, stdin);
if (szOutxFilename_g[0])
	@{
	if (loadOutxCtlFile(szOutxFilename_g, ';',
						sOutputControl_g, pStringClasses_g) != 0)
		@{
		reportError(ERROR_MSG,
					"Error reading text output control file %s\n",
					szOutxFilename_g);
		@}
	@}
@end smallexample
@subheading Source File
@file{loadoutx.c}

@c ----------------------------------------------------------------------------
@node matchAlphaChar, matchBeginning, loadOutxCtlFile, Functions
@page
@section matchAlphaChar
@subheading Syntax
@example
#include "textctl.h"    /* or template.h or opaclib.h */

int matchAlphaChar(const unsigned char * pszString_in,
				   const TextControl *   pTextCtl_in);
@end example
@subheading Description
@code{matchAlphaChar} checks whether the input string begins with a
multibyte alphabetic (word formation) character.  If so, it returns the
number of bytes in the matched multibyte alphabetic character.

This function depends on previous calls to @code{addWordFormationChars},
@code{addWordFormationCharStrings}, @code{addLowerUpperWFChars}, and
@code{addLowerUpperWFCharStrings} to establish the multibyte alphabetic
characters.  (These functions are implicitly called by
@code{loadIntxCtlFile} and @code{loadOutxCtlFile}.)

The arguments to @code{matchAlphaChar} are as follows:
@table @code
@item pszString_in
points to a string to match against.

@item pTextCtl_in
points to a data structure that contains orthographic information.
@end table
@subheading Return Value
the number of bytes occupied by the multibyte alphabetic character at the
beginning of the input string, or zero if the the string does not begin
with a multibyte alphabetic character
@subheading Example
@ifset txt
See the example for @code{convLowerToUpper} above.
@end ifset
@ifclear txt
@xref{convLowerToUpper, , Example}.
@end ifclear
@subheading Source File
@file{myctype.c}

@c ----------------------------------------------------------------------------
@node matchBeginning, matchBeginWithStringClass, matchAlphaChar, Functions
@page
@section matchBeginning
@subheading Syntax
@example
#include "opaclib.h"

int matchBeginning(const char * pszString_in,
				   const char * pszBegin_in);
@end example
@subheading Description
@code{matchBeginning} compares two strings, using the end of the second
string as the cutoff point for the comparison.  It is functionally
equivalent to
@example
(strncmp(pszString_in, pszBegin_in, strlen(pszBegin_in)) == 0)
@end example

The arguments to @code{matchBeginning} are as follows:
@table @code
@item pszString_in
points to a string to examine.

@item pszBegin_in
points to a string to compare to the beginning of the other string.
@end table
@subheading Return Value
nonzero (TRUE) if the two strings are equal up to the end of the second
string, otherwise zero (FALSE)
@subheading Example
@smallexample
#include "opaclib.h"
...
char string[100], match[50];
...
if (matchBeginning(string, match))
	@{
	...
	@}
@end smallexample
@subheading Source File
@file{matchbeg.c}

@c ----------------------------------------------------------------------------
@node matchBeginWithStringClass, matchCaselessChar, matchBeginning, Functions
@page
@section matchBeginWithStringClass
@subheading Syntax
@example
#include "strclass.h"   /* or change.h or textctl.h or template.h
						   or opaclib.h */

size_t matchBeginWithStringClass(const char *        pszString_in,
								 const StringClass * pClass_in);
@end example
@subheading Description
@code{matchBeginWithStringClass} searches a string class to find a
class member that matches the beginning of a string.  It stops at the
first successful match.

The arguments to @code{matchBeginWithStringClass} are as follows:
@table @code
@item pszString_in
points to a string to match against.

@item pClass_in
points to a string class to search for a match.
@end table
@subheading Return Value
the length of the first successful match if found (effectively TRUE),
otherwise zero (FALSE)
@subheading Example
@smallexample
#include "strclass.h"
...
static StringClass *    pClasses_m;
...
int matchesClassMemberAtBeginning(const char * pszString_in,
								  const char * pszClassName_in)
@{
StringClass *   pClass;

pClass = findStringClass(pszClassName_in, pClasses_m);
if (pClass == NULL)
	return 0;
return matchBeginWithStringClass(pszString_in, pClass);
@}
@end smallexample
@subheading Source File
@file{strcla.c}

@c ----------------------------------------------------------------------------
@node matchCaselessChar, matchEnd, matchBeginWithStringClass, Functions
@page
@section matchCaselessChar
@subheading Syntax
@example
#include "textctl.h"

int matchCaselessChar(const unsigned char * pszString_in,
					  const TextControl *   pTextCtl_in);
@end example
@subheading Description
@code{matchCaselessChar} checks whether the input string begins with a
multibyte caseless character.  If so, it returns the number of bytes in
the matched multibyte caseless character.

This function depends on previous calls to @code{addWordFormationChars}
or @code{addWordFormationCharStrings} to establish the multibyte caseless
characters.  (@code{addWordFormationChars} and
@code{addWordFormationCharStrings} are implicitly called by
@code{loadIntxCtlFile} and @code{loadOutxCtlFile}.)

The arguments to @code{matchCaselessChar} are as follows:
@table @code
@item pszString_in
points to a string to match against.

@item pTextCtl_in
points to a data structure that contains orthographic information.
@end table
@subheading Return Value
the number of bytes occupied by the multibyte caseless character at the
beginning of the input string, or zero if the the string does not begin
with a multibyte caseless character
@subheading Example
@ifset txt
See the example for @code{matchLowercaseChar} below.
@end ifset
@ifclear txt
@xref{matchLowercaseChar, , Example}.
@end ifclear
@subheading Source File
@file{myctype.c}

@c ----------------------------------------------------------------------------
@node matchEnd, matchEndWithStringClass, matchCaselessChar, Functions
@page
@section matchEnd
@subheading Syntax
@example
#include "opaclib.h"

int matchEnd(const char * pszString_in,
			 const char * pszTail_in);
@end example
@subheading Description
@code{matchEnd} compares the second string against the end of the
first string.  It is functionally equivalent to
@example
((strlen(pszString_in) < strlen(pszTail_in)) ? 0 :
	(strcmp(pszString_in + strlen(pszString_in) - strlen(pszTail_in),
			pszTail_in) == 0))
@end example

The arguments to @code{matchEnd} are as follows:
@table @code
@item pszString_in
points to a string to examine.

@item pszTail_in
points to a string to compare to the end of the other string.
@end table
@subheading Return Value
nonzero (TRUE) if the second string matches the end of the first string,
otherwise zero (FALSE)
@subheading Example
@smallexample
#include "opaclib.h"
...
char string[100], match[50];
...
if (matchEnd(string, match))
	@{
	...
	@}
@end smallexample
@subheading Source File
@file{matchend.c}

@c ----------------------------------------------------------------------------
@node matchEndWithStringClass, matchLowercaseChar, matchEnd, Functions
@page
@section matchEndWithStringClass
@subheading Syntax
@example
#include "strclass.h"   /* or change.h or textctl.h or template.h
						   or opaclib.h */

size_t matchEndWithStringClass(const char *        pszString_in,
							   const StringClass * pClass_in);
@end example
@subheading Description
@code{matchEndWithStringClass} searches a string class to find a class
member that matches the end of a string.  It stops at the first
successful match.

The arguments to @code{matchEndWithStringClass} are as follows:
@table @code
@item pszString_in
points to a string to match against.

@item pClass_in
points to a string class to search for a match.
@end table
@subheading Return Value
the length of the first successful match if found (effectively TRUE),
otherwise zero (FALSE)
@subheading Example
@smallexample
#include "strclass.h"
...
static StringClass *    pClasses_m;
...
int matchesClassMemberAtEnd(const char * pszString_in,
							const char * pszClassName_in)
@{
StringClass *   pClass;

pClass = findStringClass(pszClassName_in, pClasses_m);
if (pClass == NULL)
	return 0;
return matchEndWithStringClass(pszString_in, pClass);
@}
@end smallexample
@subheading Source File
@file{strcla.c}

@c ----------------------------------------------------------------------------
@node matchLowercaseChar, matchUppercaseChar, matchEndWithStringClass, Functions
@page
@section matchLowercaseChar
@subheading Syntax
@example
#include "textctl.h"    /* or template.h or opaclib.h */

int matchLowercaseChar(const unsigned char * pszString_in,
					   const TextControl *   pTextCtl_in);
@end example
@subheading Description
@code{matchLowercaseChar} checks whether the input string begins with a
multibyte lowercase character.  If so, it returns the number of bytes in
the matched multibyte lowercase character.

This function depends on previous calls to @code{addLowerUpperWFChars} or
@code{addLowerUpperWFCharStrings} to establish the multibyte lowercase
characters.  (@code{addLowerUpperWFChars} and
@code{addLowerUpperWFCharStrings} are implicitly called by
@code{loadIntxCtlFile} and @code{loadOutxCtlFile}.)

The arguments to @code{matchLowercaseChar} are as follows:
@table @code
@item pszString_in
points to a string to match against.

@item pTextCtl_in
points to a data structure that contains orthographic information.
@end table
@subheading Return Value
the number of bytes occupied by the multibyte lowercase character at the
beginning of the input string, or zero if the the string does not begin
with a multibyte lowercase character
@subheading Example
@smallexample
#include "textctl.h"

#define CASELESS -1
#define NOCAP     0
#define INITCAP   1
#define ALLCAP    2
#define MIXCAP    3

int getWordCase(const unsigned char * pszWord_in,
				const TextControl *   pTextCtl_in)
@{
unsigned        uiUpperCount    = 0;
unsigned        uiLowerCount    = 0;
int             bFirstCap       = 0;
int             iLength;
unsigned char * p;

for ( p = pszWord_in ; p && *p ; p += iLength )
	@{
	iLength = matchLowercaseChar(p, pTextCtl_in);
	if (iLength != 0)
		++uiLowerCount;
	else
		@{
		iLength = matchUppercaseChar(p, pTextCtl_in);
		if (iLength != 0)
			@{
			++uiUpperCount;
			if (uiLowerCount == 0)
				bFirstCap = 1;
			@}
		else
			@{
			iLength = matchCaselessChar(p, pTextCtl_in);
			if (iLength == 0)
				iLength = 1;
			@}
		@}
	@}
if ((uiUpperCount == 0) && (uiLowerCount == 0))
	return CASELESS;
else if (uiUpperCount == 0)
	return NOCAP;
else if (bFirstCap && (uiUpperCount == 1))
	return INITCAP;
else if (uiLowerCount == 0)
	return ALLCAP;
else
	return MIXCAP;
@}
@end smallexample
@subheading Source File
@file{myctype.c}

@c ----------------------------------------------------------------------------
@node matchUppercaseChar, mergeIntoStringList, matchLowercaseChar, Functions
@page
@section matchUppercaseChar
@subheading Syntax
@example
#include "textctl.h"    /* or template.h or opaclib.h */

int matchUppercaseChar(const unsigned char * pszString_in,
					   const TextControl *   pTextCtl_in);
@end example
@subheading Description
@code{matchUppercaseChar} checks whether the input string begins with a
multibyte uppercase character.  If so, it returns the number of bytes in
the matched multibyte uppercase character.

This function depends on previous calls to @code{addLowerUpperWFChars} or
@code{addLowerUpperWFCharStrings} to establish the multibyte uppercase
characters.  (@code{addLowerUpperWFChars} and
@code{addLowerUpperWFCharStrings} are implicitly called by
@code{loadIntxCtlFile} and @code{loadOutxCtlFile}.)

The arguments to @code{matchUppercaseChar} are as follows:
@table @code
@item pszString_in
points to a string to match against.

@item pTextCtl_in
points to a data structure that contains orthographic information.
@end table
@subheading Return Value
the number of bytes occupied by the multibyte lowercase character at the
beginning of the input string, or zero if the the string does not begin
with a multibyte lowercase character
@subheading Example
@ifset txt
See the example for @code{matchLowercaseChar} above.
@end ifset
@ifclear txt
@xref{matchLowercaseChar, , Example}.
@end ifclear
@subheading Source File
@file{myctype.c}

@c ----------------------------------------------------------------------------
@node mergeIntoStringList, mergeIntoStringListAtEnd, matchUppercaseChar, Functions
@page
@section mergeIntoStringList
@subheading Syntax
@example
#include "strlist.h"    /* or strclass.h or change.h or textctl.h
						   or template.h or opaclib.h */

StringList * mergeIntoStringList(StringList * pList_io,
								 const char * pszString_in);
@end example
@subheading Description
@code{mergeIntoStringList} adds a string to the beginning of a list of
strings if it is not already present in the list.

The arguments to @code{mergeIntoStringList} are as follows:
@table @code
@item pList_io
points to a list of strings.

@item pszString_in
points to the string to be added.  A copy created with
@code{duplicateString} is stored in the list, not the original string
itself.
@end table
@subheading Return Value
a pointer to the possibly modified list of strings
@subheading Example
@smallexample
#include "strlist.h"
...
StringList * pStrings = NULL;
...
pStrings = mergeIntoStringList(pStrings, "this");
				/* pStrings-->"this"-->NULL */
pStrings = mergeIntoStringList(pStrings, "test");
				/* pStrings-->"test"-->"this"-->NULL */
pStrings = mergeIntoStringList(pStrings, "is");
				/* pStrings-->"is"-->"test"-->"this"-->NULL */
pStrings = mergeIntoStringList(pStrings, "a");
				/* pStrings-->"a"-->"is"-->"test"-->"this"-->NULL */
pStrings = mergeIntoStringList(pStrings, "test");
				/* pStrings-->"a"-->"is"-->"test"-->"this"-->NULL */
@end smallexample
@subheading Source File
@file{add_sl.c}

@c ----------------------------------------------------------------------------
@node mergeIntoStringListAtEnd, mergeTwoStringLists, mergeIntoStringList, Functions
@page
@section mergeIntoStringListAtEnd
@subheading Syntax
@example
#include "strlist.h"    /* or strclass.h or change.h or textctl.h
						   or template.h or opaclib.h */

StringList * mergeIntoStringListAtEnd(StringList * pList_io,
									  const char * pszString_in);
@end example
@subheading Description
@code{mergeIntoStringListAtEnd} adds a string to the end of a list of
strings if it is not already present in the list.

The arguments to @code{mergeIntoStringListAtEnd} are as follows:
@table @code
@item pList_io
points to a list of strings.

@item pszString_in
points to the string to be added.  A copy created with
@code{duplicateString} is stored in the list, not the original string
itself.
@end table
@subheading Return Value
a pointer to the possibly modified list of strings
@subheading Example
@smallexample
#include "strlist.h"
...
StringList * pStrings = NULL;
...
pStrings = mergeIntoStringListAtEnd(pStrings, "this");
				/* pStrings-->"this"-->NULL */
pStrings = mergeIntoStringListAtEnd(pStrings, "test");
				/* pStrings-->"this"-->"test"-->NULL */
pStrings = mergeIntoStringListAtEnd(pStrings, "is");
				/* pStrings-->"this"-->"test"-->"is"-->NULL */
pStrings = mergeIntoStringListAtEnd(pStrings, "a");
				/* pStrings-->"this"-->"test"-->"is"-->"a"-->NULL */
pStrings = mergeIntoStringListAtEnd(pStrings, "test");
				/* pStrings-->"this"-->"test"-->"is"-->"a"-->NULL */
@end smallexample
@subheading Source File
@file{appnd_sl.c}

@c ----------------------------------------------------------------------------
@node mergeTwoStringLists, parseChangeString, mergeIntoStringListAtEnd, Functions
@page
@section mergeTwoStringLists
@subheading Syntax
@example
#include "strlist.h"    /* or strclass.h or change.h or textctl.h
						   or template.h or opaclib.h */

StringList * mergeTwoStringLists(StringList * pFirstList_io,
								 StringList * pSecondList_io);
@end example
@subheading Description
@code{mergeTwoStringLists} merges two lists of strings together to form
a single list.  Any strings in the second list that exist in the first
list are freed.  Neither of the original lists survives this operation.

The arguments to @code{mergeTwoStringLists} are as follows:
@table @code
@item pFirstList_io
points to a list of strings.

@item pSecondList_io
points to another list of strings.
@end table
@subheading Return Value
a pointer to the merged list
@subheading Example
@smallexample
#include "strlist.h"
...
StringList * pStrings = NULL;
StringList * pStrings1 = NULL;
StringList * pStrings2 = NULL;
...
pStrings1 = mergeIntoStringListAtEnd(pStrings1, "this");
pStrings1 = mergeIntoStringListAtEnd(pStrings1, "test");
pStrings1 = mergeIntoStringListAtEnd(pStrings1, "is");
pStrings1 = mergeIntoStringListAtEnd(pStrings1, "a");
pStrings1 = mergeIntoStringListAtEnd(pStrings1, "test");
pStrings2 = mergeIntoStringList(pStrings2, "that");
pStrings2 = mergeIntoStringList(pStrings2, "test");
pStrings2 = mergeIntoStringList(pStrings2, "is");
pStrings2 = mergeIntoStringList(pStrings2, "good");
/* pStrings1-->"this"-->"test"-->"is"-->"a"-->NULL */
/* pStrings2-->"good"-->"is"-->"test"-->"that"-->NULL */
pStrings = mergeTwoStringLists(pStrings1, pStrings2);
/* pStrings-->"good"-->"that"-->"this"-->"test"-->"is"-->"a"-->NULL */
/* pStrings1-->-----------------^ */
/* pStrings2-->??? */
@end smallexample
@subheading Source File
@file{cat_sl.c}

@c ----------------------------------------------------------------------------
@node parseChangeString, promptUser, mergeTwoStringLists, Functions
@page
@section parseChangeString
@subheading Syntax
@example
#include "change.h"     /* or textctl.h or template.h or opaclib.h */

Change * parseChangeString(const char *        pszString_in,
						   const StringClass * pClassList_in);
@end example
@subheading Description
@code{parseChangeString} parses a string to build a Change
structure.

The arguments to @code{parseChangeString} are as follows:
@table @code
@item pszString_in
points to a change definition string.

@item pClasses_in
points to a collection of string classes that may be referenced in
the environment portion of the change definition.
@end table
@subheading Return Value
a pointer to a newly allocated Change structure, or @code{NULL} if an
error occurred while parsing the change definition
@subheading Example
@smallexample
#include "change.h"     /* includes strclass.h */
...
Change * addChange(const char *        pszChange_in,
				   Change *            pChanges_io,
				   const StringClass * pClasses_in)
@{
Change *        pChange;
Change *        pTail;

pChange = parseChangeString(pszChange_in, pClasses_in);
if (pChange != NULL)
	@{
	if (pChanges_io == NULL)
		return pChange;
	/*
	 *  keep the list of changes in the original order
	 */
	for (pTail = pChanges_io ; pTail->pNext ; pTail = pTail->pNext)
		;
	pTail->pNext = pChange;
	@}
return pChanges_io;
@}
@end smallexample
@subheading Source File
@file{change.c}

@c ----------------------------------------------------------------------------
@node promptUser, readLineFromFile, parseChangeString, Functions
@page
@section promptUser
@subheading Syntax
@example
#include "opaclib.h"

void promptUser(const char * pszPrompt_in,
				char *       pszBuffer_out,
				unsigned     uiBufferSize_in);
@end example
@subheading Description
@code{promptUser} prompts the user, then reads a line of input from the
keyboard (normally the standard input).  If an @code{EOF} occurs,
@code{promptUser} tries to reopen the keyboard.

The arguments to @code{promptUser} are as follows:
@table @code
@item pszPrompt_in
points to a prompt message string.

@item pszBuffer_out
points to an input buffer.

@item uiBufferSize_in
is the size of the input buffer (not counting space for the terminating
@code{NUL}).
@end table
@subheading Return Value
none
@subheading Example
@smallexample
#include <stdio.h>
#include "opaclib.h"
...
char    szFilename_g[BUFSIZ+1];
FILE *  pInputFP_g;
char    szBuffer_g[17];
long    iRepeatCount_g;
...
promptUser("Data file: ", szFilename_g, BUFSIZ);
pInputFP_g = fopen(szFilename_g, "r");
...
promptUser("Number of iterations to perform: ", szBuffer_g, 16);
iRepeatCount_g = strtol(szBuffer_g, NULL, 10);
@end smallexample
@subheading Source File
@file{promptus.c}

@c ----------------------------------------------------------------------------
@node readLineFromFile, readSentenceOfTemplates, promptUser, Functions
@page
@section readLineFromFile
@subheading Syntax
@example
#include "opaclib.h"

char * readLineFromFile(FILE *     pInputFP_in,
						unsigned * puiLineNumber_io,
						int        cComment_in);
@end example
@subheading Description
@code{readLineFromFile} reads an arbitrarily long line of input text,
erasing the trailing newline character.  The string returned is
overwritten or freed at the next call to @code{readLineFromFile}.

The arguments to @code{readLineFromFile} are as follows:
@table @code
@item pInputFP_in
is a input @code{FILE} pointer.

@item puiLineNumber_io
points to a line number counter, or is @code{NULL}.

@item cComment_in
is the character that marks the beginning of a comment.
@end table
@subheading Return Value
the address of the buffer containing the @code{NUL}-terminated line, or
@code{NULL} if already at the end of the file
@subheading Example
@smallexample
#include <stdio.h>
#include <string.h>
#include "opaclib.h"

void processFile(const char * pszFilename_in)
@{
FILE *          pInputFP;
unsigned        uiLineNumber;
char *          pszLine;

if (pszFilename_in == NULL)
	return;
pInputFP = fopen(pszFilename_in, "r");
if (pInputFP == NULL)
	return;
uiLineNumber = 1;
while ((pszLine = readLineFromFile(pInputFP,
								   &uiLineNumber, ';')) != NULL)
	@{
	...
	@}
printf("%u lines read from %s\n", uiLineNumber, pszFilename_in);
@}
@end smallexample
@subheading Source File
@file{readline.c}

@c ----------------------------------------------------------------------------
@node readSentenceOfTemplates, readStdFormatField, readLineFromFile, Functions
@page
@section readSentenceOfTemplates
@subheading Syntax
@example
#include "template.h"   /* or opaclib.h */

WordTemplate ** readSentenceOfTemplates(FILE *        pInputFP_in,
										const char *  pszAnaFile_in,
										const char *  pszFinalPunct_in,
										TextControl * pTextCtl_in,
										FILE *        pLogFP_in)
@end example
@subheading Description
@code{readSentenceOfTemplates} reads an arbitrarily long sentence
(sequence of words) from an input analysis file, building an array of
@code{WordTemplate} data structures.  The sentence is terminated by a
sentence-final punctuation character from @code{pszFinalPunct_in}.

The arguments to @code{readSentenceOfTemplates} are as follows:
@table @code
@item pInputFP_in
is an input @code{FILE} pointer.

@item pszAnaFile_in
points to the name of the input analysis file.

@item pszFinalPunct_in
points to a @code{NUL}-terminated string of punctuation characters that
mark the end of a sentence.

@item pTextCtl_in
points to a data structure that contains the decomposition and
ambiguity marker characters.

@item pLogFP_in
is an output @code{FILE} pointer, used to log error messages, or
@code{NULL}.
@end table
@subheading Return Value
a pointer to a dynamically allocated @code{NULL}-terminated array of
pointers to dynamically allocated @code{WordTemplate} structures
@subheading Example
@smallexample
#include <stdio.h>
#include "template.h"
#include "allocmem.h"
#include "rpterror.h"
...
TextControl             sTextControl_g;
static const char       szSentenceFinalPunc_m[] = ".!?";
static const char       szCannotOpen_m[] =
		"Warning: cannot open analysis input file %s\n";
...
void processSentences(char * pszAnaFile_in, FILE * pLogFP_in)
@{
FILE *          pInputFP;
WordTemplate ** pSentence;
unsigned        uiSentenceCount;
unsigned        i;
...
pInputFP = fopen(pszAnaFile_in, "r");
if (pInputFP == NULL)
	@{
	reportError(ERROR_MSG, szCannotOpen_m, pszAnaFile_in);
	if (pLogFP_in != NULL)
		fprintf(pLogFP_in, szCannotOpen_m, pszAnaFile_in);
	return 0;
	@}
for ( uiSentenceCount = 0 ;; ++uiSentenceCount )
	@{
	pSentence = readSentenceOfTemplates(pInputFP,
										pszAnaFile_in,
										szSentenceFinalPunc_m,
										&sTextControl_g,
										pLogFP_in);
	if (pSentence == NULL)
		break;
	...
	for ( i = 0 ; pSentence[i] ; ++i )
		freeWordTemplate( pSentence[i] );
	freeMemory( pSentence );
	@}
return uiSentenceCount;
@}
@end smallexample
@subheading Source File
@file{senttemp.c}

@c ----------------------------------------------------------------------------
@node readStdFormatField, readStdFormatRecord, readSentenceOfTemplates, Functions
@page
@section readStdFormatField
@subheading Syntax
@example
#include "opaclib.h"

char ** readStdFormatField(FILE *        pInputFP_in,
						   const char ** ppszFieldCodes_in,
						   int           cComment_in);
@end example
@subheading Description
@code{readStdFormatField} reads an arbitrarily large text field that
starts with a backslash marker at the beginning of a line.  Each line
of the input field is stored separately in a @code{NULL}-terminated
array of strings.  If the field code at the beginning matches one of
those in the input array of field codes, it is replaced by a single
byte containing the 1-based index of the matching field code.
Otherwise, the field code is left intact except that the backslash
character is replaced by the character code @code{255} (@code{'\377'}).

This function is an alternative to @code{readStdFormatRecord}, which
potentially reads several fields at a time.

The arguments to @code{readStdFormatField} are as follows:
@table @code
@item pInputFP_in
is an input @code{FILE} pointer.

@item ppszFieldCodes_in
points to a @code{NULL}-terminated array of field code strings.

@item cComment_in
is the character used to initiate comments in a line.
@end table
@subheading Return Value
a pointer to a dynamically allocated @code{NULL}-terminated array of
pointers to dynamically allocated lines of text
@subheading Example
@smallexample
#include <stdio.h>
#include "opaclib.h"
...
static char     szWhitespace_m[7] = " \t\r\n\f\v";
...
int read_control_file(char * pszControlFile_in)
@{
int             i;
char *          pszRuleFile    = NULL;
char *          pszLexiconFile = NULL;
char *          pszGrammarFile = NULL;
StringList *    pTraceList     = NULL;
char *          pszMorph;
FILE *          pControlFP;
char **         ppszField;
char *          pszLine;
static char *   aszCodes_s[] = @{
	"\\rules", "\\lexicon", "\\grammar", "\\trace", ..., NULL
	@};

if (pszControlFile_in == NULL)
	return FALSE;
pControlFP = fopen(pszControlFile_in, "r");
if (pControlFP == (FILE *)NULL)
	@{
	reportError(WARNING_MSG, "Cannot open control file %s\n",
				pszControlFile_in);
	return FALSE;
	@}
for (;;)
	@{
	ppszField = readStdFormatField(pControlFP, aszCodes_s, NUL));
	if (ppszField == NULL)
		break;
	switch (**ppszField)
		@{
		case 1:                 /* "\\rules" */
			if (pszRuleFile != NULL)
				reportError(WARNING_MSG,
							"Rule file already specified: %s\n",
							pszRuleFile);
			else
				@{
				for ( i = 0 ; ppszField[i] ; ++i )
					@{
					pszLine = ppszField[i];
					if (i == 0)
						++pszLine;
					pszRuleFile = strtok(pszLine, szWhitespace_m);
					if (pszRuleFile != NULL)
						break;
					@}
				@}
			break;

		case 2:                 /* "\\lexicon" */
			if (pszLexiconFile != NULL)
				reportError(WARNING_MSG,
							"Lexicon file already specified: %s\n",
							pszLexiconFile);
			else
				@{
				for ( i = 0 ; ppszField[i] ; ++i )
					@{
					pszLine = ppszField[i];
					if (i == 0)
						++pszLine;
					pszLexiconFile = strtok(pszLine, szWhitespace_m);
					if (pszLexiconFile != NULL)
						break;
					@}
				@}
			break;

		case 3:                 /* "\\grammar" */
			if (pszGrammarFile != NULL)
				reportError(WARNING_MSG,
							"Grammar file already specified: %s\n",
							pszGrammarFile);
			else
				@{
				for ( i = 0 ; ppszField[i] ; ++i )
					@{
					pszLine = ppszField[i];
					if (i == 0)
						++pszLine;
					pszGrammarFile = strtok(pszLine, szWhitespace_m);
					if (pszGrammarFile != NULL)
						break;
					@}
				@}
			break;

		case 4:                 /* "\\trace" */
			for ( i = 0 ; ppszField[i] ; ++i )
				@{
				pszLine = ppszField[i];
				if (i == 0)
					++pszLine;
				for (   pszMorph = strtok(pszLine, szWhitespace_m) ;
						pszMorph ;
						pszMorph = strtok(NULL, szWhitespace_m)
					@{
					pTraceList = mergeIntoStringList(pTraceList,
													 pszMorph);
					@}
				@}
			break;
...
		default:
			reportError(WARNING_MSG, "Unknown field: \\%s\n",
						ppszField[0] + 1);
			break;
		@}
	for ( i = 0 ; ppszField[i] ; ++i )
		freeMemory(ppszField[i]);
	freeMemory(ppszField);
	@}
fclose(pControlFP);
...
return TRUE;
@}
@end smallexample
@subheading Source File
@file{readfiel.c}

@c ----------------------------------------------------------------------------
@node readStdFormatRecord, readTemplateFromAnalysis, readStdFormatField, Functions
@page
@section readStdFormatRecord
@subheading Syntax
@example
#include "record.h"     /* or opaclib.h */

char * readStdFormatRecord(FILE *            pInputFP_in,
						   const CodeTable * pCodeTable_in,
						   int               cComment_in,
						   unsigned *        puiRecordCount_io);
@end example
@subheading Description
@code{readStdFormatRecord} reads the next record from a standard format
file.  The record is stored in memory as a series of
@code{NUL}-terminated strings stored consecutively in a single buffer,
with the record terminated by two consecutive @code{NUL} bytes.  The
first character of each string is either a character representing the
field code (if found in the code table), or a backslash indicating that
the field code was not recognized.

This function is an alternative to @code{readStdFormatField}, which
always reads only one field at a time.

The arguments to @code{readStdFormatRecord} are as follows:
@table @code
@item pInputFP_in
is an input @code{FILE} pointer.

@item pCodeTable_in
points to the field code table used to decode the standard format file
field code markers.

@item cComment_in
is a character that marks comments in the input file.

@item puiRecordCount_io
points to a counter for keeping track of the number of records read, or
is @code{NULL}.
@end table
@subheading Return Value
a pointer to the buffer containing the record, or @code{NULL} for
@code{EOF}.
@subheading Example
@smallexample
#include <stdio.h>
#include <string.h>
#include "record.h"
...
void loadStdFmtFile(pszFilename_in)
char *          pszFilename_in;
@{
FILE *          pInputFP;
char *          pRecord;
char *          pszField;
char *          pszNextField;
unsigned        uiRecordCount;
static CodeTable sCodeTable_s = @{ "\
\\a\0A\0\
\\d\0D\0\
\\w\0W\0\
\\f\0F\0\
\\c\0C\0\
\\n\0N\0"
	6, "\\a"
	@};

if (pszFilename_in == NULL)
	return;
pInputFP = fopen(pszFilename_in, "r");
if (pInputFP == NULL)
	return;
while ((pRecord = readStdFormatRecord(pInputFP,
									  &sCodeTable_s,
									  ';',
									  &uiRecordCount)) != NULL)
	@{
	pszField = pRecord;
	while ((c = *pszField++) != '\0')
		@{
		pszNextField = pszField + strlen(pszField) + 1;
		switch (c)
			@{
			case 'A':
				...
				break;
			case 'C':
				...
				break;
			case 'D':
				...
				break;
			case 'F':
				...
				break;
			case 'N':
				...
				break;
			case 'W':
				...
				break;
			default:
				...
				break;
			@}
		pszField = pszNextField;
		@}
	...
	@}
cleanupAfterStdFormatRecord();
fclose(pInputFP);
return;
@}
@end smallexample
@subheading Source File
@file{record.c}

@c ----------------------------------------------------------------------------
@node readTemplateFromAnalysis, readTemplateFromText, readStdFormatRecord, Functions
@page
@section readTemplateFromAnalysis
@subheading Syntax
@example
#include "template.h"   /* or opaclib.h */

WordTemplate * readTemplateFromAnalysis(
						   FILE *              pInputFP_in,
						   const TextControl * pTextCtl_in);
@end example
@subheading Description
@code{readTemplateFromAnalysis} fills in a @code{WordTemplate} data
structure from an AMPLE style analysis file.

The arguments to @code{readTemplateFromAnalysis} are as follows:
@table @code
@item pInputFP_in
is an input @code{FILE} pointer.

@item pTextCtl_in
points to a data structure that contains orthographic information.
@end table
@subheading Return Value
a pointer to a dynamically allocated @code{WordTemplate} data
structure, or @code{NULL} if either @code{EOF} or an error occurs
@subheading Example
@smallexample
#include "template.h"
#include "rpterror.h"
...
void synthesizeFile(
	char *              pszInputFile_in,
	char *              pszOutputFile_in,
	TextControl *       pTextCtl_in)
@{
FILE *                  pInputFP;
FILE *                  pOutputFP;
WordTemplate *          pWord;
WordAnalysis *          pAnal;
...
/*
 *  open the files
 */
if ((pszInputFile_in == NULL) || (pszOutputFile_in == NULL))
	return;
pInputFP  = fopen(pszInputFile_in, "r");
if (pInputFP == NULL)
	@{
	reportError(WARNING_MSG, "Cannot open input file %s\n",
				pszInputFile_in);
	return;
	@}
pOutputFP = fopen(pszOutputFile_g, "w");
if (pOutputFP == NULL)
	@{
	reportError(WARNING_MSG, "Cannot open output file %s\n",
				pszOutputFile_in);
	fclose(pInputFP);
	return;
	@}
/*
 *  process the data
 */
for (;;)
	@{
	pWord = readTemplateFromAnalysis(pInputFP, &pTextCtl_in);
	if (pWord == NULL)
		break;
	...
	for ( pAnal = pWord->pAnalyses ; pAnal ; pAnal = pAnal->pNext )
		@{
		...
		@}
	...
	writeTextFromTemplate( pOutputFP, pWord, pTextCtl_in);
	freeWordTemplate( pWord );
	@}
...
fclose(pInputFP);
fclose(pOutputFP);
@}
@end smallexample
@subheading Source File
@file{dtbin.c}

@c ----------------------------------------------------------------------------
@node readTemplateFromText, readTemplateFromTextString, readTemplateFromAnalysis, Functions
@page
@section readTemplateFromText
@subheading Syntax
@example
#include "template.h"   /* or opaclib.h */

WordTemplate * readTemplateFromText(FILE *              pInputFP_in,
									const TextControl * pTextCtl_in);
@end example
@subheading Description
@code{readTemplateFromText} reads a word from a text file into a
@code{WordTemplate} structure.

The arguments to @code{readTemplateFromText} are as follows:
@table @code
@item pInputFP_in
is an input @code{FILE} pointer.

@item pTextCtl_in
points to a data structure that contains orthographic information.
@end table
@subheading Return Value
a pointer to a dynamically allocated @code{WordTemplate} data
structure, or @code{NULL} if either @code{EOF} or an error occurs
@subheading Example
@ifset txt
See the example for @code{freeWordTemplate} above.
@end ifset
@ifclear txt
@xref{freeWordTemplate, , Example}.
@end ifclear
@subheading Source File
@file{textin.c}

@c ----------------------------------------------------------------------------
@node readTemplateFromTextString, reallocMemory, readTemplateFromText, Functions
@page
@section readTemplateFromTextString
@subheading Syntax
@example
#include "template.h"   /* or opaclib.h */

WordTemplate * readTemplateFromTextString(unsigned char **    ppszString_io,
										  const TextControl * pTextCtl_in);
@end example
@subheading Description
@code{readTemplateFromText} reads a word from a text string into a
@code{WordTemplate} structure.

The arguments to @code{readTemplateFromText} are as follows:
@table @code
@item ppszString_io
points to a pointer which points to the string to be "read".  The pointer
to the string will be updated by this routine.

@item pTextCtl_in
points to a data structure that contains orthographic information.
@end table
@subheading Return Value
a pointer to a dynamically allocated @code{WordTemplate} data
structure, or @code{NULL} if either the string consists merely of
@code{NUL} or an error occurs
@subheading Example
@smallexample
#include "template.h"
...
TextControl sTextCtl_g;
...
WordAnalysis * merge_analyses(
	WordAnalysis *  pList_in,
	WordAnalysis *  pAnal_in)
@{
...
@}
...
void process(
	unsigned char *pszInputText_in,
	FILE * pOutputFP_in)
@{
char *		pszInputText;
char *		pszWord;
WordTemplate *  pWord;
WordAnalysis *  pAnal;
unsigned        uiAmbiguityCount;
unsigned long   uiWordCount;

pszInputText = duplicateString(pszInputText_in);
pszWord = pszInputText;
for ( uiWordCount = 0L ;; )
	@{
	pWord = readTemplateFromTextString(&pszWord, &sTextCtl_g);
	if (pWord == NULL)
		break;
	uiAmbiguityCount = 0;
	if (pWord->paWord != NULL)
		@{
		for ( i = 0 ; pWord->paWord[i] ; ++i )
			@{
			pAnal = analyze(pWord->paWord[i]);
			pWord->pAnalyses = merge_analyses(pWord->pAnalyses,
											  pAnal);
			@}
		for (pAnal = pWord->pAnalyses ; pAnal ; pAnal = pAnal->pNext)
			++uiAmbiguityCount;
		@}
	writeTemplate(pOutputFP_in, NULL, pWord, &sTextCtl_g);
	freeWordTemplate(pWord);
	@}
freeMemory(pszInputText);
@}
@end smallexample
@subheading Source File
@file{textin.c}

@c ----------------------------------------------------------------------------
@node reallocMemory, recapitalizeWord, readTemplateFromTextString, Functions
@page
@section reallocMemory
@subheading Syntax
@example
#include "allocmem.h"   /* or opaclib.h */

void * reallocMemory(void * pBuffer_in,
					 size_t uiSize_in);
@end example
@subheading Description
@code{reallocMemory} adjusts an allocated buffer to a new size.
It provides a ``safe'' interface to either @code{realloc} or
@code{malloc}, depending on whether or not @code{pBuffer_in} is
@code{NULL}.  Running out of memory is handled the same as for
@code{allocMemory}; see
@ifset txt
@code{allocMemory} above.
@end ifset
@ifclear txt
@ref{allocMemory}.
@end ifclear

The arguments to @code{reallocMemory} are as follows:
@table @code
@item pBuffer_in
points to a dynamically allocated buffer previously returned by
@code{allocMemory}, @code{reallocMemory}, or @code{duplicateString}.
It also may be @code{NULL} to allocate a new block of memory.

@item uiSize_in
is the new size, either smaller or larger than the previous allocation
size.
@end table
@subheading Return Value
a pointer to a possibly reallocated block
@subheading Example
@ifset txt
See the example for @code{fitAllocStringExactly} above.
@end ifset
@ifclear txt
@xref{fitAllocStringExactly, , Example}.
@end ifclear
@subheading Source File
@file{allocmem.c}

@c ----------------------------------------------------------------------------
@node recapitalizeWord, removeDataFromTrie, reallocMemory, Functions
@page
@section recapitalizeWord
@subheading Syntax
@example
#include "template.h"   /* or opaclib.h */

void recapitalizeWord(char *              pszWord_io,
					  int                 iRecap_in,
					  const TextControl * pTextCtl_in);
@end example
@subheading Description
@code{recapitalizeWord} tries to reimpose capitalization as it was in
the original input text.

The arguments to @code{recapitalizeWord} are as follows:
@table @code
@item pszWord_io
points to the word to recapitalize.

@item iRecap_in
is the capitalization flag:
@table @code
@item 0 (NOCAP)
None of the characters are capitalized.
@item 1 (INITCAP)
Only the initial character is capitalized.
@item 2 (ALLCAP)
All of the characters are capitalized.
@item 4@value{endash}65535
These values are bitmaps of individually capitalized characters, with
@code{4} encoding the capitalization of the first character, @code{8}
encoding the second character, and so on.
@end table

@item pTextCtl_in
points to a data structure that contains orthographic information.
@end table
@subheading Return Value
none
@subheading Example
@smallexample
#include "template.h"

void fix_new_words(pTemplate_io, pTextCtl_in)
WordTemplate *          pTemplate_io;
const TextControl *     pTextCtl_in;
@{
StringList *    pWord;
char *          p;

if ((pTemplate_io == NULL) || (pTemplate_io->pNewWords == NULL))
	return;
if (pTextCtl_in == NULL)
	return;
/*
 *  apply orthography changes to the word and recapitalize it
 */
for ( pWord = pTemplate_io->pNewWords ; pWord ; pWord = pWord->pNext )
	@{
	/*
	 *  apply output orthography changes and recapitalize
	 */
	p = applyChanges(pWord->pszString, pTextCtl_in->pOutputChanges );
	recapitalizeWord( p, pTemplate_io->iCapital, pTextCtl_in);
	/*
	 *  store the modified wordform
	 */
	freeMemory(pWord->pszString);
	pWord->pszString = p;
	@}
@}
@end smallexample
@subheading Source File
@file{textout.c}

@c ----------------------------------------------------------------------------
@node removeDataFromTrie, removeFromStringList, recapitalizeWord, Functions
@page
@section removeDataFromTrie
@subheading Syntax
@example
#include "trie.h"       /* or opaclib.h */

int removeDataFromTrie(Trie *    pTrieHead_in,
					   char *    pszKey_in,
					   void *    pInfo_in,
					   void * (* pfRemoveInfo_in)(void * pOld_in,
												  void * pList_io));
@end example
@subheading Description
@code{removeDataFromTrie} removes a stored piece of information from a
trie.

The arguments to @code{removeDataFromTrie} are as follows:
@table @code
@item pTrieHead_in
points to the head of a trie.

@item pszKey_in
points to the key string.

@item pInfo_in
points to the actual data element to remove.

@item pfRemoveInfo_in
points to a function for removing the data element from the stored
information.  The function has two arguments:
@table @code
@item pOld_in
points to the item to remove from the collection (@code{pInfo_in}).
@item pList_io
points to a collection of items stored at a @code{Trie} node
(@code{Trieinfo}).
@end table
@noindent
The function returns the updated pointer to the data collection for
storing as the value of @code{pTrieInfo}.
@end table
@subheading Return Value
zero if successful, nonzero if an error occurs
@subheading Example
@smallexample
#include <string.h>
#include "trie.h"
#include "rpterror.h"
#include "allocmem.h"
...
typedef struct lex_item @{
	struct lex_item *   pLink;          /* link to next item */
	struct lex_item *   pNext;          /* link to next homograph */
	unsigned char *     pszForm;        /* lexical form (word) */
	unsigned char *     pszGloss;       /* lexical gloss */
	unsigned short      uiCategory;     /* lexical category */
	@} LexItem;
...
Trie *          pLexicon_g;
unsigned long   uiLexiconCount_g;
static char     szWhitespace_m[7] = " \t\r\n\f\v";
...
static void * remove_lex_item(void * pDefunct_in, void * pList_in)
@{
LexItem *       pLex;
LexItem *       pList;
/*
 *  be a little paranoid
 */
if (pDefunct_in == NULL)
	return pList_in;
/*
 *  handle removing the head of the list
 */
if (pDefunct_in == pList_in)
	return pDefunct_in->pLink;
/*
 *  unlink from the list of homographs
 */
/*
 *  unlink from both the general list and the list of homographs
 */
for ( pLex = (LexItem *)pList_in ; pLex ; pLex = pLex->pLink )
	@{
	if (pLex->pNext == pDefunct_in)
		pLex->pNext = pDefunct_in->pNext;
	if (pLex->pLink == pDefunct_in)
		@{
		pLex->pLink = pDefunct_in->pLink;
		break;          /* no need to check further */
		@}
	@}
return pList_in;
@}

void remove_from_lexicon(char * pszForm_in,
						 char * pszGloss_in,
						 char * pszCategory_in)
@{
LexItem *       pLex;
unsigned short  uiCategory;

if (    (pszForm_in     == NULL) ||
		(pszGloss_in    == NULL) ||
		(pszCategory_in == NULL) )
	return;

uiCategory = index_lexical_category(pszCategory_in);
for (   pLex = findDataInTrie(pLexicon_g, pszWord_in) ;
		pLex ;
		pLex = pLex->pLink )
	@{
	if (    (strcmp(pLex->pszForm,  pszWord_in)  == 0) &&
			(strcmp(pLex->pszGloss, pszGloss_in) == 0) &&
			(pLex->uiCategory    == uiCategory)        )
		@{
		removeDataFromTrie(pLexicon_g, pszForm_in, pLex,
						   remove_lex_item);
		break;
		@}
	@}
@}
@end smallexample
@subheading Source File
@file{trie.c}

@c ----------------------------------------------------------------------------
@node removeFromStringList, reportError, removeDataFromTrie, Functions
@page
@section removeFromStringList
@subheading Syntax
@example
#include "strlist.h"    /* or strclass.h or change.h or textctl.h
						   or template.h or opaclib.h */

StringList * removeFromStringList(StringList * pList_io,
								  const char * pszString_in);
@end example
@subheading Description
@code{removeFromStringList} removes the first occcurrence of a string
from a list of strings.

The arguments to @code{removeFromStringList} are as follows:
@table @code
@item pList_io
points to a list of strings.

@item pszString_in
points to the string to be removed.
@end table
@subheading Return Value
a pointer to the (possibly shorter) list, or @code{NULL} if the only
item in the list was removed
@subheading Example
@smallexample
#include "strlist.h"
...
static StringList *     pNameList_m;
...
char *  pszName;
...
pNameList_m = removeFromStringList(pNameList_m, pszName);
...
@end smallexample
@subheading Source File
@file{rmstr_sl.c}

@c ----------------------------------------------------------------------------
@node reportError, reportMessage, removeFromStringList, Functions
@page
@section reportError
@subheading Syntax
@example
#include "rpterror.h"   /* or opaclib.h */

void reportError(int          eMessageType_in,
				 const char * pszFormat_in,
				 ...);
@end example
@subheading Description
@code{reportError} reports an error message to the user.  For MS-DOS
and Unix, @code{reportError} writes to the standard error output.  The
message is also written to the standard output if it has been
redirected.  For GUI programs, the programmer must write a different
version of @code{reportError} to satisfy the link requirements of other
functions in the OPAC library.  This would typically display a message
box.

The arguments to @code{reportError} are as follows:
@table @code
@item eMessageType_in
is the type of error message being reported, one of the following:
@table @code
@item ERROR_MSG
is a message about an erroneous situation.
@item WARNING_MSG
is a message about a situation that is not quite an error, but not
normal either.
@item DEBUG_MSG
is a message that only the programmer is expected to understand.
@end table

@item pszFormat_in
points to a @code{printf} style format string for the (error) message.

@item @dots{}
represents zero or more arguments for the format string
(@code{pszFormat_in}).
@end table
@subheading Return Value
none
@subheading Example
@ifset txt
See the example for @code{addDataToTrie} above.
@end ifset
@ifclear txt
@xref{addDataToTrie, , Example}.
@end ifclear
@subheading Source File
@file{rpterror.c}

@c ----------------------------------------------------------------------------
@node reportMessage, reportProgress, reportError, Functions
@page
@section reportMessage
@subheading Syntax
@example
#include "rpterror.h"   /* or opaclib.h */

void reportMessage(int          bNotSilent_in,
				   const char * pszFormat_in,
				   ...);
@end example
@subheading Description
@code{reportMessage} displays a message with zero or more arguments.
For MS-DOS and Unix, @code{reportMessage} writes to the standard error
output.  The message is also written to the standard output if it has
been redirected.  For GUI programs, the programmer must write a different
version of @code{reportMessage} to satisfy the link requirements of other
functions in the OPAC library.  This would typically write to a message
window.

The arguments to @code{reportMessage} are as follows:
@table @code
@item bNotSilent_in
allows writing the message to the standard error output if @code{TRUE}
(nonzero).  If @code{FALSE} (zero), the message is written only to the
standard output (@code{stdout}), and then only if it has been
redirected.  This allows programs to have a ``quiet'' mode of
operation without requiring a global variable.

@item pszFormat_in
points to a @code{printf} style format string for the message.

@item @dots{}
represents zero or more arguments for the format string
(@code{pszFormat_in}).
@end table
@subheading Return Value
none
@subheading Example
@smallexample
#include "rpterror.h"
...
static int      iDebugLevel_m;
...
static int read_token(pszBuffer_in, uiBufferSize_in)
char *          pszBuffer_in;
unsigned        uiBufferSize_in;
@{
int     iTokenType;
...
if (iDebugLevel_m >= 8)
	@{
	reportMessage("DEBUG read_token(\"%s\",%u) => ",
				  pszBuffer_in, uiBufferSize_in);
	switch (iTokenType)
		@{
		case BECOMES:
			reportMessage("BECOMES_TOKEN");
			break;
		case KEYWORD:
			reportMessage("KEYWORD_TOKEN");
			break;
		case SYMBOL:
			reportMessage("SYMBOL_TOKEN");
			break;
		default:
			reportMessage("'%c'\t", iTokenType);
			break;
		@}
	reportMessage("\n");
	@}
return( iTokenType );
@}
@end smallexample
@subheading Source File
@file{rptmessg.c}

@c ----------------------------------------------------------------------------
@node reportProgress, resetTextControl, reportMessage, Functions
@page
@section reportProgress
@subheading Syntax
@example
#include "opaclib.h"

void reportProgress(unsigned long uiCount_in);
@end example
@subheading Description
@code{reportProgress} displays a progress report based on a progress
counter.

The standard version of @code{reportProgress} actually does nothing.
For GUI programs, the programmer may write a version of
@code{reportProgress} to display some sort of progress message using
the progress counter.

@code{reportProgress} has one argument:
@table @code
@item uiCount_in
is a progress count of some sort.
@end table

@subheading Return Value
none
@subheading Example
@smallexample
#include "opaclib.h"
...
static unsigned long    uiTokenCount_m;
...
static int read_token(pszBuffer_in, uiBufferSize_in)
char *          pszBuffer_in;
unsigned        uiBufferSize_in;
@{
int     iTokenType;
...
++uiTokenCount_m;
reportProgress( uiTokenCount_m );
return( iTokenType );
@}
@end smallexample
@subheading Source File
@file{rptprgrs.c}

@c ----------------------------------------------------------------------------
@node resetTextControl, resetWordFormationChars, reportProgress, Functions
@page
@section resetTextControl
@subheading Syntax
@example
#include "textctl.h"    /* or template.h or opaclib.h */

void resetTextControl(TextControl * pTextCtl_io);
@end example
@subheading Description
@code{resetTextControl} frees any memory allocated by either
@code{loadIntxCtlFile} or@* @code{loadOutxCtlFile}.  It does not free the
@code{TextControl} data structure itself.

@code{resetTextControl} has one argument:
@table @code
@item pTextCtl_io
points to a data structure that contains orthographic information.
@end table
@subheading Return Value
none
@subheading Example
@smallexample
#include <stdio.h>
#include "textctl.h"    /* include strclass.h */
#include "rpterror.h"
...
char               szIntxFilename_g[200];
TextControl        sTextControl_g;
StringClass *      pStringClasses_g = NULL;
static TextControl sDefaultTextControl_m = @{
	NULL,       /* filename */
	NULL,       /* ordered array of lowercase letters */
	NULL,       /* ordered array of matching uppercase letters */
	NULL,       /* array of caseless letters */
	NULL,       /* list of input orthography changes */
	NULL,       /* list of output (orthography) changes */
	NULL,       /* list of format markers (fields) to include */
	NULL,       /* list of format markers (fields) to exclude */
	'\\',       /* initial character of format markers (field codes) */
	'%',        /* character for marking ambiguities and failures */
	'-',        /* character for marking decomposition */
	'|',        /* initial character of secondary format markers */
	NULL,       /* (Manuscripter) bar codes */
	TRUE,       /* flag whether to capitalize individual letters */
	TRUE,       /* flag whether to decapitalize/recapitalize */
	100         /* maximum number of decapitalization alternatives */
	@};
...
memcpy(&sTextControl_g, &sDefaultTextControl_m, sizeof(TextControl));
fprintf(stderr, "Text Control File (xxINTX.CTL) [none]: ");
fgets( szIntxFilename_g, 200, stdin );
if (szIntxFilename_g[0])
	@{
	if (loadIntxCtlFile(szIntxFilename_g, ';',
						sTextControl_g, pStringClasses_g) != 0)
		@{
		reportError(ERROR_MSG, "Error reading text control file %s\n",
					szIntxFilename_g);
		@}
	@}
if (    (sTextControl_g.cBarMark == NUL) &&
		(sTextControl_g.pszBarCodes != NULL) )
	@{
	freeMemory(sTextControl_g.pszBarCodes);
	sTextControl_g.pszBarCodes = NULL;
	@}
if (    (sTextControl_g.cBarMark != NUL) &&
		(sTextControl_g.pszBarCodes == NULL) )
	@{
	sTextControl_g.pszBarCodes = (unsigned char *)duplicateString(
													"bdefhijmrsuvyz");
	@}
...
resetTextControl(&sTextControl_g);
@end smallexample
@subheading Source File
@file{resetxtc.c}

@c ----------------------------------------------------------------------------
@node resetWordFormationChars, setAllocMemoryTracing, resetTextControl, Functions
@page
@section resetWordFormationChars
@subheading Syntax
@example
#include "textctl.h"    /* or template.h or opaclib.h */

void resetWordFormationChars(TextControl * pTextCtl_io);
@end example
@subheading Description
@code{resetWordFormationChars} erases the stored information about word
formation characters stored by previous calls to either
@code{addWordFormationChars} or @code{addLowerUpperWFChars}.
This frees any allocated memory and sets the relevant pointers to
@code{NULL}.

@code{resetWordFormationChars} has one argument:
@table @code
@item pTextCtl_io
points to a data structure that contains orthographic information.
@end table
@subheading Return Value
none
@subheading Example
@ifset txt
See the example for @code{addLowerUpperWFChars} above.
@end ifset
@ifclear txt
@xref{addLowerUpperWFChars, , Example}.
@end ifclear
@subheading Source File
@file{myctype.c}

@c ----------------------------------------------------------------------------
@node setAllocMemoryTracing, setAllocMemoryTrap, resetWordFormationChars, Functions
@page
@section setAllocMemoryTracing
@subheading Syntax
@example
#include "allocmem.h"   /* or opaclib.h */

void setAllocMemoryTracing(const char * pszFilename_in);
@end example
@subheading Description
@code{setAllocMemoryTracing} turns debugging on (if a filename is
given) or off (if @code{pszFilename_in} is @code{NULL}).  If debugging
is on, every call to @code{allocMemory}, @code{reallocMemory}, and
@code{freeMemory} is logged to the given file for postmortem analysis.
Calls to @code{duplicateString} are logged as calls to
@code{allocMemory}, which @code{duplicateString} calls internally.

@code{setAllocMemoryTracing} has one argument:
@table @code
@item pszFilename_in
points to the name of the debugging output file, or is @code{NULL}.
@end table
@subheading Return Value
none
@subheading Example
@smallexample
#include <stdlib.h>
#include "allocmem.h"
...
extern int      getopt(int argc, char * const argv[],
					   const char *opts);
extern char *   optarg;
...
int main(int argc, char ** argv)
@{
void *          pTrapAddress = NULL;
unsigned        iTrapCount   = 0;
int             k;
char *          p;
...
while ((k = getopt(argc, argv, "ai:o:x:z:Z:")) != EOF)
	@{
	switch (k)
		@{
...
		case 'z':       /* memory allocation trace filename */
			setAllocMemoryTracing(optarg);
			break;

		case 'Z':       /* memory allocation trap address,count */
			pTrapAddress = (void *)strtoul(optarg, &p, 10);
			if (*p == ',')
				iTrapCount = (unsigned)strtoul(p+1, NULL, 10);
			if (iTrapCount == 0)
				iTrapCount = 1;
			setAllocMemoryTrap(pTrapAddress, iTrapCount);
			break;
...
		@}
	@}
...
@}
@end smallexample
@subheading Source File
@file{allocmem.c}

@c ----------------------------------------------------------------------------
@node setAllocMemoryTrap, showAmbiguousProgress, setAllocMemoryTracing, Functions
@page
@section setAllocMemoryTrap
@subheading Syntax
@example
#include "allocmem.h"   /* or opaclib.h */

void setAllocMemoryTrap(const void * pAddress_in,
						int          iCount_in);
@end example
@subheading Description
@code{setAllocMemoryTrap} sets a trap for the @code{iCount_in}'th
reference to the address @code{pAddress_in} by either
@code{allocMemory} or @code{freeMemory}.  This can be useful for
tracking down memory allocation bugs.

The arguments to @code{setAllocMemoryTrap} are as follows:
@table @code
@item pAddress_in
is the memory address to trap on.

@item iCount_in
is the occurrence to trap on.
@end table
@subheading Return Value
none
@subheading Example
@ifset txt
See the example for @code{setAllocMemoryTracing} above.
@end ifset
@ifclear txt
@xref{setAllocMemoryTracing, , Example}.
@end ifclear
@subheading Source File
@file{allocmem.c}

@c ----------------------------------------------------------------------------
@node showAmbiguousProgress, squeezeStringList, setAllocMemoryTrap, Functions
@page
@section showAmbiguousProgress
@subheading Syntax
@example
#include "opaclib.h"

unsigned long showAmbiguousProgress(unsigned      uiAmbiguityCount_in,
									unsigned long uiItemCount_in);
@end example
@subheading Description
@code{showAmbiguousProgress} displays the progress of the program in a
rudimentary fashion.  If @code{uiAmbiguityCount_in} is 0, then a star
(@samp{*}) is written to the screen, and if @code{uiAmbiguityCount_in}
is 1, then a dot (@samp{.}) is written to the screen.  Otherwise, if
@code{uiAmbiguityCount_in} is less than 10, the count digit is written,
and if it is greater than or equal to 10, a greater than sign
(@samp{>}) is written.  These progress characters are grouped in
bunches of 10, with 5 bunches on a line and space between each bunch.
Every other line ends with the total count of items thus far
(@code{uiItemCount_in}).

The arguments to @code{showAmbiguousProgress} are as follows:
@table @code
@item uiAmbiguityCount_in
is the number of alternative results to report for the current item.

@item uiItemCount_in
is the number of items that have been processed thus far.
@end table
@subheading Return Value
the updated value for uiItemCount_in
@subheading Example
@ifset txt
See the example for @code{freeWordTemplate} above.
@end ifset
@ifclear txt
@xref{freeWordTemplate, , Example}.
@end ifclear
@subheading Source File
@file{ambprog.c}

@c ----------------------------------------------------------------------------
@node squeezeStringList, tokenizeString, showAmbiguousProgress, Functions
@page
@section squeezeStringList
@subheading Syntax
@example
#include "strlist.h"    /* or strclass.h or change.h or textctl.h
						   or template.h or opaclib.h */

StringList * squeezeStringList(StringList * pList_io);
@end example
@subheading Description
@code{squeezeStringList} removes any redundant strings from a list of
strings.

@code{squeezeStringList} has one argument:
@table @code
@item pList_io
points to a list of strings.
@end table
@subheading Return Value
a pointer to the (possibly smaller) list of strings
@subheading Example
@smallexample
#include "template.h"   /* includes strlist.h */
...
static WordTemplate *   pTemplate_m = NULL;
...
/*
 *  eliminate identical results
 */
pTemplate_m->pNewWords = squeezeStringList( pTemplate_m->pNewWords );
@end smallexample
@subheading Source File
@file{sqz_sl.c}

@c ----------------------------------------------------------------------------
@node tokenizeString, trimTrailingWhitespace, squeezeStringList, Functions
@page
@section tokenizeString
@subheading Syntax
@example
#include "opaclib.h"

unsigned char * tokenizeString(unsigned char *       pszString_in,
							   const unsigned char * pszSeparate_in)

@end example
@subheading Description
@code{tokenizeString} splits the string (@code{pszString_in} into a
sequence of zero or more text tokens separated by spans of one or more
characters from @code{pszSeparate_in}.  Only the initial call provides
a value for @code{pszString_in}; successive calls must use a
@code{NULL} pointer for the first argument.  The first separater
character following the token in @code{pszString_in} is replaced by a
@code{NUL} character.  Subsequent calls to @code{tokenizeString} work
through @code{pszString_in} sequentially.  Note that
@code{pszSeparate_in} may change from one call to the next.

@code{tokenizeString} is like @code{strtok} except that it
operates on strings of @code{unsigned char} rather than strings of
@code{char}.

The arguments to @code{tokenizeString} are as follows:
@table @code
@item pszString_in
points to a @code{NUL}-terminated character string, or @code{NULL}.

@item pszSeparate_in
points to a @code{NUL}-terminated set of separator characters, or
@code{NULL}.  If it is @code{NULL}, then the rest of the string is
returned as the token.
@end table
@subheading Return Value
a pointer to the next token extracted from the input string, or
@code{NULL} if no more tokens exist
@subheading Example
@smallexample
#include "opaclib.h"
...
char    szWhitespace_m[7] = " \n\r\t\f\v";
char    szInputBuffer_m[1024];
char *  pszToken;
...
for (   pszToken = tokenizeString(szInputBuffer_m, szWhitespace_m) ;
		pszToken != NULL ;
		pszToken = tokenizeString(NULL, szWhitespace_m) )
	@{
	...
	@}
...
@end smallexample
@subheading Source File
@file{tokenize.c}

@c ----------------------------------------------------------------------------
@node trimTrailingWhitespace, unlinkStringList, tokenizeString, Functions
@page
@section trimTrailingWhitespace
@subheading Syntax
@example
#include "opaclib.h"

char * trimTrailingWhitespace(char * pszString_io);
@end example
@subheading Description
@code{trimTrailingWhitespace} removes any trailing white space
characters from the input string.

@code{trimTrailingWhitespace} has one argument:
@table @code
@item pszString_io
points to a character string.
@end table
@subheading Return Value
a pointer to the beginning of the input string
@subheading Example
@smallexample
#include "opaclib.h"
...
static char     szWhitespace_m[7] = " \t\r\n\f\v";
...
FILE *          pRulesFP;
unsigned        uiLineNumber;
char *          pszToken;
...
for ( uiLineNumber = 1 ;;)
	@{
	pszToken = readLineFromFile(pRulesFP, &uiLineNumber, ';');
	if (pszToken == NULL)
		break;
	/*
	 *  skip leading spaces and remove trailing spaces
	 */
	pszToken += strspn(pszToken, szWhitespace_m);
	if (*pszToken == NUL)
		continue;
	trimTrailingWhitespace(pszToken);
	...
	@}
@end smallexample
@subheading Source File
@file{trimspac.c}

@c ----------------------------------------------------------------------------
@node unlinkStringList, updateStringList, trimTrailingWhitespace, Functions
@page
@section unlinkStringList
@subheading Syntax
@example
#include "strlist.h"    /* or strclass.h or change.h or textctl.h
						   or template.h or opaclib.h */

void unlinkStringList(StringList ** ppList_io);
@end example
@subheading Description
@code{unlinkStringList} frees the @code{StringList} data structures in
a list of strings, while leaving intact the strings they point to.

The arguments to @code{unlinkStringList} are as follows:
@table @code
@item ppList_io
is the address of a pointer to the head of a list of strings to unlink.
@end table
@subheading Return Value
none
@subheading Example
@smallexample
#include "strlist.h"
...
StringList *    pList;
...
unlinkStringList(pList);
pList = NULL;
@end smallexample
@subheading Source File
@file{unlst_sl.c}

@c ----------------------------------------------------------------------------
@node updateStringList, walkTrie, unlinkStringList, Functions
@page
@section updateStringList
@subheading Syntax
@example
#include "strlist.h"    /* or strclass.h or change.h or textctl.h
						   or template.h or opaclib.h */

char * updateStringList(StringList ** ppList_io,
						const char *  pszString_in);
@end example
@subheading Description
@code{updateStringList} adds the string to the list if it is not
already in the list.  This function is similar to
@code{mergeIntoStringList}, except that it has a different argument and
returns a different value.

The arguments to @code{updateStringList} are as follows:
@table @code
@item ppList_io
is the address of a pointer to the list of strings to be updated.

@item pszString_in
points to the string to be added to the list of strings.
@end table
@subheading Return Value
a pointer to the copy of @code{pszString_in} stored in the list of
strings
@subheading Example
@smallexample
#include "strlist.h"
...
static StringList *     pCategories_m;
static char             szBuffer_m[100];
...
char *  pszCategory;
...
pszCategory = updateStringList( &pCategories_m, szBuffer_m );
...
@end smallexample
@subheading Source File
@file{updat_sl.c}

@c ----------------------------------------------------------------------------
@node walkTrie, writeAllocMemoryDebugMsg, updateStringList, Functions
@page
@section walkTrie
@subheading Syntax
@example
#include "trie.h"       /* or opaclib.h */

void walkTrie(Trie *  pTrieHead_in,
			  void (* pfWalk_in)(void * pList_in));
@end example
@subheading Description
@code{walkTrie} walks through a trie, processing the information stored
at each node.

The arguments to @code{walkTrie} are as follows:
@table @code
@item pTrieHead_in
points to the head of a trie.

@item pfWalk_in
points to a function for processing the stored information at each node
of the trie.  The function has one argument:
@table @code
@item pList_in
points to a collection of items stored at a @code{Trie} node
(@code{Trieinfo}).
@end table
@noindent
The function does not return a value.
@end table
@subheading Return Value
none
@subheading Example
@smallexample
#include <stdio.h>
#include "trie.h"
#include "rpterror.h"
...
typedef struct lex_item @{
	struct lex_item *   pLink;          /* link to next item */
	struct lex_item *   pNext;          /* link to next homograph */
	unsigned char *     pszForm;        /* lexical form (word) */
	unsigned char *     pszGloss;       /* lexical gloss */
	unsigned short      uiCategory;     /* lexical category */
	@} LexItem;
...
Trie *          pLexicon_g;
FILE *          pLexiconFP_m;
...
static void write_lex_items(void * pList_in)
@{
LexItem *       pLex;

if (pLexiconFP_m == NULL)
	return;
for ( pLex = (LexItem *)pList_in ; pLex ; pLex = pLex->pLink )
	@{
	fprintf(pLexiconFP_m, "%-20s %-20s %s\n",
			pLex->pszForm, pLex->pszGloss,
			get_lexical_category_name(pLex->uiCategory));
	@}
@}

void write_lexicon()
@{
if (pszLexiconFile_in == NULL)
	@{
	reportError(WARNING_MSG, "Missing output lexicon filename\n");
	return;
	@}
pLexiconFP_m = fopen(pszLexiconFile_in, "w");
if (pLexiconFP_m == NULL)
	@{
	reportError(WARNING_MSG,
				"Cannot open lexicon file %s for output\n",
				pszLexiconFile_in);
	return;
	@}
walkTrie(pLexicon_g, write_lex_items);
fclose(pLexiconFP_m);
@}
@end smallexample
@subheading Source File
@file{trie.c}

@c ----------------------------------------------------------------------------
@node writeAllocMemoryDebugMsg, writeChange, walkTrie, Functions
@page
@section writeAllocMemoryDebugMsg
@subheading Syntax
@example
#include "allocmem.h"   /* or opaclib.h */

void writeAllocMemoryDebugMsg(const char * pszFormat_in,
							  ...);
@end example
@subheading Description
@code{writeAllocMemoryDebugMsg} writes a message to the memory
allocation tracing file if it is open, and does nothing if that file is
not open.  The memory allocation tracing file is opened and closed by
@code{setAllocMemoryTracing}.  @code{writeAllocMemoryDebugMsg} is
similar to @code{printf} except that it writes to a specific (optional)
file rather than to the standard output.

The arguments to @code{writeAllocMemoryDebugMsg} are as follows:
@table @code
@item pszFormat_in
points to a @code{printf} style format string for the message.

@item @dots{}
represents zero or more arguments for the format string
(@code{pszFormat_in}).
@end table
@subheading Return Value
none
@subheading Example
@smallexample
#include "allocmem.h"
#include "strlist.h"
...
StringList * pStrings;
...
writeAllocMemoryDebugMsg("deleting %u strings\n",
						 getStringListSize(pStrings));
freeStringList(pStrings);
pStrings = NULL;
@end smallexample
@subheading Source File
@file{allocmem.c}

@c ----------------------------------------------------------------------------
@node writeChange, writeCodeTable, writeAllocMemoryDebugMsg, Functions
@page
@section writeChange
@subheading Syntax
@example
#include "change.h"

void writeChange(const Change * pChange_in,
				 FILE *         pOutputFP_in);
@end example
@subheading Description
@code{writeChange} writes the given @code{Change} data structure to the
output file as a human readable string consisting of a pair of quoted
strings followed by the environment constraint (if any).

The arguments to @code{writeChange} are as follows:
@table @code
@item pChange_in
points to a single consistent change data structure.  (The @code{pNext}
field of the @code{Change} data structure is ignored.)

@item pOutputFP_in
is an output FILE pointer.
@end table
@subheading Return Value
none
@subheading Example
@smallexample
#include <stdio.h>
#include "change.h"
...
void writeChangeList(FILE * pOutputFP_in, Change * pChanges_in)
@{
Change *        cp;

if (pOutputFP_in == NULL)
	return;
for ( cp = pChanges_in ; cp ; cp = cp->pNext )
	writeChange(cp, pOutputFP_in);
@}
@end smallexample
@subheading Source File
@file{change.c}

@c ----------------------------------------------------------------------------
@node writeCodeTable, writeStringClasses, writeChange, Functions
@page
@section writeCodeTable
@findex writeCodeTable
@subheading Syntax
@example
#include "record.h"

void writeCodeTable(FILE *            pOutputFP_in,
					const CodeTable * pTable_in);
@end example
@subheading Description
@code{writeCodeTable} writes the contents of a @code{CodeTable} data
structure to a file.  The output is useful only for debugging.

The arguments to @code{writeCodeTable} are as follows:
@table @code
@item pOutputFP_in
is an output FILE pointer.

@item pTable_in
points to a @code{CodeTable} data structure.
@end table
@subheading Return Value
none
@subheading Example
@smallexample
#include "record.h"
#include "ample.h"

AmpleData sAmpleData_g;
char szCodesFilename_g[100];
...
loadAmpleDictCodeTables(szCodesFilename_g, &sAmpleData_g, FALSE);
writeCodeTable( sAmpleData_g.pLogFP,
				sAmpleData_g.pPrefixTable );
@end smallexample
@subheading Source File
@file{loadtb.c}

@c ----------------------------------------------------------------------------
@node writeStringClasses, writeStringList, writeCodeTable, Functions
@page
@section writeStringClasses
@subheading Syntax
@example
#include "strclass.h"   /* or change.h or textctl.h or template.h
						   or opaclib.h */

void writeStringClasses(FILE *              pOutputFP_in,
						const StringClass * pClasses_in);
@end example
@subheading Description

@code{writeStringClasses} writes the contents of all the string classes
in the list to a file.

The arguments to @code{writeStringClasses} are as follows:
@table @code
@item pOutputFP_in
is an output FILE pointer.

@item pClasses_in
points to a list of string classes to write to a file.
@end table
@subheading Return Value
none
@subheading Example
@smallexample
#include <stdio.h>
#include "strclass.h"
...
static StringClass *    pClasses_m;
...
writeStringClasses(stdout, pClasses_m);
...
@}
@end smallexample
@subheading Source File
@file{strcla.c}

@c ----------------------------------------------------------------------------
@node writeStringList, writeTemplate, writeStringClasses, Functions
@page
@section writeStringList
@subheading Syntax
@example
#include "strlist.h"    /* or strclass.h or change.h or textctl.h
						   or template.h or opaclib.h */

void writeStringList(const StringList * pList_in,
					 const char *       pszSep_in,
					 FILE *             pOutputFP_in);
@end example
@subheading Description
@code{writeStringList} writes a list of strings to an output file,
separating the individual strings in the list by the indicated string.

The arguments to @code{writeStringList} are as follows:
@table @code
@item pList_in
points to a list of strings.

@item pszSep_in
points to the string used to separate the members of the list.

@item pOutputFP_in
is an output FILE pointer.
@end table
@subheading Return Value
none
@subheading Example
@smallexample
#include <stdio.h>
#include "strlist.h"
...
static StringList *     pCategories_m;
...
void showCategories()
@{
printf("Categories:  ");
writeStringList(pCategories_m, "  ", stdout);
printf("\n");
@}
@end smallexample
@subheading Source File
@file{write_sl.c}

@c ----------------------------------------------------------------------------
@node writeTemplate, writeTextFromTemplate, writeStringList, Functions
@page
@section writeTemplate
@subheading Syntax
@example
#include "template.h"   /* or opaclib.h */

void writeTemplate(FILE *               pOutputFP_in,
				   const char *         pszFilename_in,
				   const WordTemplate * pTemplate_in,
				   const TextControl *  pTextCtl_in);
@end example
@subheading Description
@code{writeTemplate} writes the results of a morphological analysis as
a database.  Each word is a record with these fields:
@table @code
@item \a
analysis (ambiguities and failures marked)
@item \d
morpheme decomposition (ambiguities and failures marked)
@item \cat
final category of word (ambiguities and failures marked)
@item \p
properties (ambiguities and failures marked)
@item \fd
feature descriptors (ambiguities and failures marked)
@item \u
underlying form (ambiguities and failures marked)
@item \w
original word
@item \f
preceding format marks
@item \c
capitalization
@item \n
trailing nonalphabetics
@end table
@noindent
Ambiguities are marked as @code{%n%Anal1%Anal2%...%analn%}.
Failures are marked as @code{%0%OriginalWord%} or @code{%0%%}.
(The separation character can be set to something other than @code{%}.)

The arguments to @code{writeTemplate} are as follows:
@table @code
@item pOutputFP_in
is an output FILE pointer.

@item pszFilename_in
points to the name of the output file.

@item pTemplate_in
points to a data structure that contains the word analysis
information.

@item pTextCtl_in
points to a data structure that contains orthographic information, and
also the ambiguity marker character.
@end table
@subheading Return Value
none
@subheading Example
@ifset txt
See the example for @code{freeWordTemplate} above.
@end ifset
@ifclear txt
@xref{freeWordTemplate, , Example}.
@end ifclear
@subheading Source File
@file{dtbout.c}

@c ----------------------------------------------------------------------------
@node writeTextFromTemplate, writeTrieData, writeTemplate, Functions
@page
@section writeTextFromTemplate
@subheading Syntax
@example
#include "template.h"   /* or opaclib.h */
void writeTextFromTemplate(FILE *               pOutputFP_in,
						   const WordTemplate * pTemplate_in,
						   const TextControl *  pTextCtl_in);
@end example
@subheading Description
@code{writeTextFromTemplate} writes the results of a morphological
synthesis to an output file, restoring all the formatting information
associated with the word in the original input to analysis.

Ambiguities are marked as @code{%n%Word1%Word2%...%Wordn%}.
Failures are marked as @code{%0%OriginalWord%}.
(The separation character can be set to something other than @code{%}.)

The arguments to @code{writeTextFromTemplate} are as follows:
@table @code
@item pOutputFP_in
is an output FILE pointer.

@item pTemplate_in
points to a data structure containing the word analysis and synthesis
information.

@item pTextCtl_in
points to a data structure that contains orthographic information, and
also the ambiguity marker character.
@end table
@subheading Return Value
none
@subheading Example
@ifset txt
See the example for @code{readTemplateFromAnalysis} above.
@end ifset
@ifclear txt
@xref{readTemplateFromAnalysis, , Example}.
@end ifclear
@subheading Source File
@file{textout.c}

@c ----------------------------------------------------------------------------
@node writeTrieData, writeWordAnalysisList, writeTextFromTemplate, Functions
@page
@section writeTrieData
@subheading Syntax
@example
#include "trie.h"       /* or opaclib.h */

void writeTrieData(Trie * pTrieHead_in,
				  void (* pfWriteInfo_in)(void * pList_in,
										  int    iIndent_in,
										  FILE * pOutputFP_in),
				  FILE *  pOutputFP_in);
@end example
@subheading Description
@code{writeTrieData} walks through a trie, writing the information
stored at each node to a file.  This is intended primarily for
debugging, as the trie structure is explicitly written to the output
file in indented form, together with the information stored in the
trie.

The arguments to @code{writeTrieData} are as follows:
@table @code
@item pTrieHead_in
points to the head of a trie.

@item pfShowInfo_in
points to a function for writing the stored information to a file.  The
function has three arguments:
@table @code
@item pList_in
points to a collection of items stored at a @code{Trie} node
(@code{Trieinfo}).
@item iIndent_in
is the number of spaces to indent the display of each data item in the
collection.
@item pOutputFP_in
is the output FILE pointer.
@end table
@noindent
The function does not return a value.

@item pOutputFP_in
is an output FILE pointer.
@end table
@subheading Return Value
none
@subheading Example
@smallexample
#include <stdio.h>
#include "trie.h"
#include "rpterror.h"
...
typedef struct lex_item @{
	struct lex_item *   pLink;          /* link to next item */
	struct lex_item *   pNext;          /* link to next homograph */
	unsigned char *     pszForm;        /* lexical form (word) */
	unsigned char *     pszGloss;       /* lexical gloss */
	unsigned short      uiCategory;     /* lexical category */
	@} LexItem;
...
Trie *          pLexicon_g;
...
static void debug_lex_items(void * pList_in,
							int    iIndent_in,
							FILE * pOutputFP_in)
@{
LexItem *       pLex;
int             i;

if (pOutputFP_in == NULL)
	return;
for ( pLex = (LexItem *)pList_in ; pLex ; pLex = pLex->pLink )
	@{
	for ( i = 0 ; i < iIndent_in ; ++i )
		fputc(' ', pOutputFP_in);
	fprintf(pOutputFP_in, "%-20s %-20s %u [%lu -> %lu]\n",
			pLex->pszForm, pLex->pszGloss, pLex->uiCategory,
			(unsigned long)pLex, (unsigned long)pLex->pNext);
	@}
@}

void debug_lexicon()
@{
printf("BEGIN LEXICON TRIE DATA\n");
writeTrieData(pLexicon_g, debug_lex_items, stdout);
printf("END LEXICON TRIE DATA\n");
@}
@end smallexample
@subheading Source File
@file{trie.c}

@c ----------------------------------------------------------------------------
@node writeWordAnalysisList, writeWordFormationChars, writeTrieData, Functions
@page
@section writeWordAnalysisList
@subheading Syntax
@example
#include "template.h"

void writeWordAnalysisList(const WordAnalysis * pAnalyses_in,
						   FILE *               pOutputFP_in);
@end example
@subheading Description
@code{writeWordAnalysisList} writes a list of @code{WordAnalysis} data
structures to an output file for debugging purposes.

The arguments to @code{writeWordAnalysisList} are as follows:
@table @code
@item pAnalyses_in
points to a list of @code{WordAnalysis} data structures.

@item pOutputFP_in
is an output FILE pointer.
@end table
@subheading Return Value
none
@subheading Example
@smallexample
#include <stdio.h>
#include "template.h"
...
void dumpWordTemplate(pTemplate_in, pOutputFP_in)
WordTemplate *  pTemplate_in;
FILE *          pOutputFP_in;
@{
if (pOutputFP_in == NULL)
	return;
if (pTemplate_in == NULL))
	@{
	fprintf(pOutputFP_in, "WordTemplate ptr is NULL\n");
	return;
	@}
putc('\n', pOutputFP_in);
fprintf(pOutputFP_in, "  orig_word = \"%s\"\n",
	   pTemplate_in->pszOrigWord ? pTemplate_in->pszOrigWord : "@{NULL@}" );
fprintf(pOutputFP_in, "  word      = \"%s\"\n",
	   pTemplate_in->paWord && pTemplate_in->paWord[0] ?
										pTemplate_in->paWord[0] : "@{NULL@}" );
fprintf(pOutputFP_in, "  format    = \"%s\"\n",
	   pTemplate_in->pszFormat ? pTemplate_in->pszFormat : "@{NULL@}" );
fprintf(pOutputFP_in, "  non_alpha = \"%s\"\n",
	   pTemplate_in->pszNonAlpha ? pTemplate_in->pszNonAlpha : "@{NULL@}" );
fprintf(pOutputFP_in, "  capital   = %d\n", pTemplate_in->iCapital );

writeWordAnalysisList(pTemplate_in->pAnalyses, pOutputFP_in);

fprintf(pOutputFP_in, "  new_words = ");
if (pTemplate_in->pNewWords)
	@{
	fprintf(pOutputFP_in, "\"");
	writeStringList( pTemplate_in->pNewWords, "\" \"", pOutputFP_in);
	fprintf(pOutputFP_in, "\"\n");
	@}
else
	fprintf(pOutputFP_in, "@{NULL@}\n");
@}
@end smallexample
@subheading Source File
@file{wordanal.c}

@c ----------------------------------------------------------------------------
@node writeWordFormationChars, , writeWordAnalysisList, Functions
@page
@section writeWordFormationChars
@subheading Syntax
@example
#include "textctl.h"    /* or template.h or opaclib.h */

void writeWordFormationChars(FILE *              pOutputFP_in,
							 const TextControl * pTextCtl_in);
@end example
@subheading Description
@code{writeWordFormationChars} writes the set of word formation
characters to an output file.  This function depends on previous calls
to @code{addWordFormationChars} and @code{addLowerUpperWFChars}.

The arguments to @code{writeWordFormationChars} are as follows:
@table @code
@item pOutputFP_in
is an output FILE pointer.

@item pTextCtl_in
points to a data structure that contains orthographic information.
@end table
@subheading Return Value
none
@subheading Example
@smallexample
#include <stdio.h>
#include "textctl.h"
...
static TextControl      sTextCtl_m;
...
printf("The word formation characters are:\n");
writeWordFormationChars(stdout, &sTextCtl_m);
...
@end smallexample
@subheading Source File
@file{myctype.c}

@c ----------------------------------------------------------------------------
@node Bibliography, , Functions, Top
@unnumbered Bibliography

@enumerate
@item
Antworth, Evan L.@. 1990.
@cite{PC-KIMMO: a two-level processor for morphological analysis}.
@tex
\break
@end tex
Occasional Publications in Academic Computing No.@: 16.
Dallas, TX: Summer Institute of Linguistics.

@item
Kew, Jonathan and Stephen R. McConnel. 1991.
@cite{Formatting interlinear text}.
Occasional Publications in Academic Computing No.@: 17.
Dallas, TX: Summer Institute of Linguistics.

@item
Knuth, Donald E.@. 1973.
@cite{Sorting and Searching}.
Volume 3 of @cite{The Art of Computer Programming}.
Reading, MA: Addison-Wesley.

@item
Weber, David J., H. Andrew Black, and Stephen R. McConnel. 1988.
@cite{AMPLE: a tool for exploring morphology}.
Occasional Publications in Academic Computing No.@: 12.
Dallas, TX: Summer Institute of Linguistics.

@item
Weber, David J., H. Andrew Black, Stephen R. McConnel, and Alan Buseman. 1990.
@cite{STAMP: a tool for dialect adaptation}.
Occasional Publications in Academic Computing No.@: 15.
Dallas, TX: Summer Institute of Linguistics.

@item
Weber, David J., Stephen R. McConnel, Diana D. Weber and Beth J. Bryson. 1994.
@cite{PRIMER: a tool for developing early reading materials}.
Occasional Publications in Academic Computing No.@: 18.
Dallas, TX: Summer Institute of Linguistics.
@end enumerate

@c ----------------------------------------------------------------------------
@contents
@bye
