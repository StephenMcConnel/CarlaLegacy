/* applrule.c  Apply rules to input  Alan B  6 Nov 90
*
* char *applyrules( Rule *rules, char *dicent )
*
* Change history:
* 0.2a 21-Jan-92 AB Remove need to list longest member of class first
* 0.2k 20-Mar-95 WM fix monitor digits to be less than 10.
* 0.2k 20-Mar-95 WM whitespace fixes;
* 0.2l 11-May-95 BJY Require field markers to be at beginning of line
* 0.2r 17-May-95 BJY Added ability to generate new allomorph with the
*                   combined environments of a rule and an allomorph
*                   previously generated by another rule.
* 0.2s 15-Sep-95 BJY ifdef out noload stuff added in 0.2q and fix bug of
*					base rule firing but not remembering changed base
*		22-Sep-98 JDH Converted all "printf" to  "fprintf(logfile,"
*					where logfile is set to stdout for the DOS version, a file for the dll version
*					"stderr" changed to "errlogfile"
*/

#include "phonrule.h"

#ifndef min
#define min(a,b) (((a) < (b)) ? (a) : (b))
#endif
extern int do_trace;
extern int do_monitor;
extern int num_apps;
extern int num_ents;
extern char comment_char;
extern char cut_char;
extern int base_becomes_allo;

extern char *allomark;
extern int allomarklen;
extern char *basemark;
extern int basemarklen;
extern char *catmark;
extern int catmarklen;
char *cat[20];                      /* Cats of entry */

static Allo *newallolist;            /* 0.2r BJY */

static char allo[300];              /* Place to build allo */
static Str *allolist;               /* List of allos already in entry */

static char *before_allo( Allo *al, char *dicent );
static int join_envirs( char *allo, Rule *ru, Allo *pallo );
static void add_new_allo( char *s, Allo *where, Rule *ru );
static char *apply_rule( char *base, Rule *ru, char *dicent, Allo *allo );
static char *after_allos( char *dicent );
static void insert_line( char *mark, char *allo, char *allo_ins );
static void add_allo( char *s );
static int in_allolist( char *s );

int minor_warnings = 1;                 /* 0.2r BJY */

extern FILE *logfile;
extern FILE *errlogfile;


#ifdef CSTUDIODLL
void preparePhnaGlobals()
{
	/* actually, it doesn't look there are any globals needing initialization here */
}
#endif

#ifdef C_terp
#define memmove mymemmove
/*
*  Memmove is here because my C_terp doesn't seem to have it.
*  This just moves down because I don't use memmove to move up.
*/
void *mymemmove( char *dest, char *src, int count )
{
src += count;                       /* Start at top */
dest += count;
for ( ; count > 0; src--, dest--, count-- )
	*dest = *src;
}
#endif



#ifndef _MSC_VER
#define strrev mystrrev
/*
*  strrev is here because THINK_C doesn't seem to have it.
*/
void mystrrev( char *str )
{
int len;
char *front, *back;
char tmp;

len = strlen(str);
for ( front = str, back = str + len - 1;
	  back > front;
	  front++, back-- )
	{
	tmp = *back;
	*back = *front;
	*front = tmp;
	}
}
#endif

/**************************************************************
 * NAME
 *      strnlstr
 * ARGS
 *      str - string to search
 *      srch_str - string to search for
 * DESC
 *      Works like strstr() except srch_str must be preceded
 *      by a nl in 'str'
 * RETN
 *      pointer to occurence of srch_str in str
 *
 * Added 5/95 BJY for 0.2l
 */
char *strnlstr( char *str, char *srch_str)
{
char *p = str - 1;

do
	{
	p = strstr( p+1, srch_str );
	if ( !p )
		return NULL;      /* strstr() couldn't find anything */

	} while ( *(p-1) != '\n' ); /* srch_str must be at beginning of line */

return p;   /* return pointer to this occurence of srch_str */
}

/**************************************************************
 * NAME
 *      applyrules
 * ARGS
 *      rules - list of rules to apply
 *      dicent - entry to apply rules to
 * DESC
 *      Apply rules to dic entry to add allomorphs.
 * RETN
 *      Pointer to modified entry.
 *
 * Major mods 5/95 0.2r BJY moved code into new func apply_rule()
 */
char *applyrules( Rule *rules, char *dicent )
{
Allo *al;           /* temporary allo pointer */
Rule *ru;           /* Temp rule */
char *s, *t;        /* Temp string pointer */
int i;              /* Index for cat array */
char *base;         /* Base form */
char remchar;       /* Removed char */
char *alloname;

if ( !rules )                       /* If no rules, return */
	return( dicent );

num_apps = 0;                       /* Clear number of rules applied */
allolist = NULL;                    /* Clear list of allos already in entry */
newallolist = NULL;                 /* 0.2r BJY */

s = strnlstr( dicent, basemark );           /* Find base */ /* 0.2l BJY */
if ( !s )                                   /* If no base, return */
	return( dicent );
s += basemarklen;                           /* Move to start of base */
											/* Find end of base */
for ( t = s;                                /* Stop at space or cutoff char */
		*t && !myisspace( *t ) && !( *t == cut_char );
		t++ );
base = mymemdup( s, t );                    /* Copy base */

s = strnlstr( dicent, catmark );            /* Find category line */ /* 0.2l BJY */
if ( !s )                                   /* If no cat, use null */
	cat[0] = NULL;
else
	{
	for ( t = s;
			*t && !(*t == comment_char) && !(*t == '\n');
			t++ )                          /* Find comment or end of line */
		;
	s = mymemdup( s, t );                   /* Copy cat line */

	i = 0;                                  /* Init index */
	while ( *(s = nextwd( s ) ) )           /* While another cat */
		cat[i++] = s;                       /* Remember it */
	cat[i] = NULL;                          /* Terminate list with null */
	}

								/* Make a list of allos already in entry */
allolist = NULL;                            /* Clear list of allos */
s = dicent - 1;
while ( (s = strnlstr( s + 1, allomark )) != NULL ) /* While another allo */ /* 0.2l BJY */
	{
	s += allomarklen;               /* Move to start of allo */
	s = skipwhite(s);               /* wm: 0.2k: skip white space */
	for ( t = s; *t && !myisspace( *t ); t++ ) /* Find end of allo */
		;
	remchar = *t;                   /* Remember char after allo */
	*t = '\0';                      /* Terminate allo */
	add_allo( s );                  /* Add allo to list */
	*t = remchar;                   /* Restore char after allo */
	}

for ( ru = rules; ru; ru = ru->next )       /* For each rule */
	{                                       /* begin 0.2r BJY */
	if ( *ru->match || *ru->repl )          /* don't apply 0 -> 0 rule to new allos */
		{
		for ( al = newallolist; al; al = al->next )
			{                               /* now try on each PHONRULE generated allo */

			s = strchr( al->name, ' ' );
			if ( s )
			  alloname = mymemdup( al->name, s ); /* if the name ends in a space, copy till space */
			else
			  alloname = mystrdup( al->name );    /* else copy all of it */

			apply_rule( alloname, ru, dicent, al );
			}
		}
	base = apply_rule( base, ru, dicent, NULL );   /* try rule on base word */ /* set base in case changed by base rule  0.2s BJY */
	}                                       /* end 0.2r BJY */

if ( base_becomes_allo                      /* If allo is base */
		&& !in_allolist( base ) )           /* And not already in */
	insert_line( allomark, base, after_allos( dicent ) ); /* Insert it into the entry */

num_ents++;                                 /* Count sentence */
if ( do_monitor )                           /* If monitor, give dot */
	{
	if (num_apps == 0)		/* hab 0.2p Conformed to standard practice */
	  putc('.', errlogfile);
	else if (num_apps < 10)
	  putc('0'+num_apps, errlogfile);
	else
	  putc('>', errlogfile);
	if ( num_ents % 100 == 0 )                      /* wm 0.2k: number by 100s */
		fprintf( errlogfile, " %5d", num_ents );
	if ( num_ents % 10 == 0 )
		fprintf( errlogfile, "  " );
	if ( num_ents % 50 == 0 )
		fprintf( errlogfile, "\n" );
	}

return( dicent );                             /* Return modified sent */
} /* function applyrules */



/**************************************************************
 * NAME
 *      apply_rule
 * ARGS
 *      entry - dictionary entry or allo name
 *      ru  - current rule to apply to entry
 *      dicent - current record being processed
 *      pallo - NULL if base word otherwise points to node
 *              in newallolist for allo to process
 * DESC
 *      Apply rules to dic entry or previously generated allomorphs
 *      to add new allomorphs.
 * RETN
 *      pointer to possibly new base word (same as entry unless changed by base rule) 0.2s BJY
 *
 * Created from code in applyrules 5/95 0.2r BJY
 */
static char *apply_rule( char *entry, Rule *ru, char *dicent, Allo *pallo )
{
char *curbase;      /* Current match char in base */
char *curmat;       /* Current match char in match */
char *curallo;      /* Current char in allo */
char *currep;       /* Current char in replace */
Str *longsl;        /* Longest matched string element */
int cat_found;      /* True if category found */
char *endcl;        /* End of class reference */
int matchok;        /* Flag for match ok so far */
int longnum;        /* Number of longest matched string element */
int slnum;          /* Number of current matched string element */
int class_num;      /* Number of current class */
int mem_num[10];    /* Number of member of each class matched */
int succ;           /* Temp flag for success on match */
int i;
char temps[100];    /* Temp string space */
Scl *scl;           /* Temp string class */
Scl *ccl;           /* Temp cat class */
Str *sl;            /* Temp string element */

*allo = '\0';                           /* Init allo */
for ( i = 0; i < 10; i++ )
	mem_num[i] = 0;

if ( *ru->cat )                         /* If cat restriction */
	{
	if ( *ru->cat == '[' )              /* If cat class, look it up */
		{
		ccl = find_ccl( ru->cat + 1 );
		for ( cat_found = FALSE, i = 0; cat[i]; i++ ) /* For each cat in dicentry */
			{
			for ( sl = ccl->class; sl; sl = sl->next ) /* For each cat in class */
				if ( streq( sl->name, cat[i] ) ) /* If same cat */
					{
					cat_found = TRUE;           /* Remember */
					break;
					}
			}
		}
	else
		{
		for ( cat_found = FALSE, i = 0; cat[i]; i++ ) /* For each cat in dicentry */
			{
			if ( streq( ru->cat, cat[i] ) ) /* If same cat */
				{
				cat_found = TRUE;           /* Remember */
				break;
				}
			}
		}
	if ( !cat_found )                   /* If no cat match */
		return entry;                   /* Don't try on this one */
	}

class_num = 0;                          /* Init number of class */

if ( !ru->begin )                       /* If rule applies at end */
	strrev( entry );                    /* Invert the word */

curbase = entry;
curmat = ru->match;
matchok = TRUE;
while( *curmat && matchok )         /* While more mat & still good */
	{
	matchok = FALSE;
	if ( *curmat == '[' )           /* If class */
		{
		endcl = strchr( curmat, ']' );  /* Find end of class */
		*endcl = '\0';                  /* Terminate class */
		scl = find_scl( curmat + 1 );   /* Find class */
		mem_num[class_num] = 0;         /* Init member number */
		longsl = NULL;                  /* Init longest */
		longnum = 0;                    /* Init number of longest */
		for ( sl = scl->class, slnum = 0; /* For each member */
				sl != NULL;
				sl = sl->next, slnum++ ) /* Count members */
			{
			succ = FALSE;
			if ( ru->begin )            /* If match at begin do normal match */
				succ = !strncmp( sl->name, curbase, strlen( sl->name ) );
			else                        /* Else invert class string before match */
				{
				strrev( sl->name );
				succ = !strncmp( sl->name, curbase, strlen( sl->name ) );
				strrev( sl->name );
				}
			if ( succ )
				{                   /* If first or longer than prev */
				if ( !longsl
					  || strlen( sl->name ) > strlen ( longsl->name ) )
					{
					longsl = sl;         /* Remember as longest found */
					longnum = slnum;     /* Remember number of longest */
					}
				}
			}
		if ( longsl )                /* If a match found */
			{
			matchok = TRUE;         /* Note found */
			curmat = endcl + 1;     /* Move to end of class */
			curbase += strlen( longsl->name ); /* Move past match */
			mem_num[class_num] = longnum; /* Set member number */
			}
		*endcl = ']';               /* Restore class terminator */
		class_num++;                /* Move to next class */
		}
	else if ( *curmat == '#' )      /* If word boundary */
		{
		curmat++;                   /* Move past pound sign */
		if ( !*curbase )            /* If at end of match */
			matchok = TRUE;         /* Note found */
		}
	else                            /* Else (not class) */
		if ( *curmat++ == *curbase++ )
			matchok = TRUE;         /* Note found */
	}
if ( matchok )                      /* If match */
	{
	class_num = 0;          /* Init number of class */
	curallo = allo;
	currep = ru->repl;
	while ( *currep )           /* While more replace */
		{
		if ( *currep == '[' )           /* If class */
			{
			endcl = strchr( currep, ']' );  /* Find end of class */
			*endcl = '\0';                  /* Terminate class */
			scl = find_scl( currep + 1 );   /* Find class */
											/* Count down to member number */
			for ( sl = scl->class;
					mem_num[class_num];
					sl = sl->next )
				mem_num[class_num]--;
			if ( ru->begin )            /* If match at begin do normal */
				strcpy( curallo, sl->name );    /* Insert member */
			else                        /* Else invert class string first */
				{
				strrev( sl->name );
				strcpy( curallo, sl->name );    /* Insert member */
				strrev( sl->name );
				}
			currep = endcl + 1;             /* Move to end of class */
			curallo += strlen( sl->name );  /* Move past match */

			*endcl = ']';               /* Restore class terminator */
			class_num++;                /* Move to next class */
			}
		else if ( *currep == '#' )      /* If word boundary */
			currep++;                   /* Move past pound sign */
		else                            /* Else (not class) */
			{
			*curallo++ = *currep++;     /* Insert char */
			*curallo = '\0';            /* Terminate allo */
			}
		}
	strcpy( curallo, curbase );     /* Put in rest of base */
	if ( !ru->begin )               /* If rule applies at end */
		strrev( allo );             /* Invert the base */
	}
if ( !ru->begin )                       /* If rule applies at end */
	strrev( entry );                    /* Invert the base */

if ( *allo )                            /* If an allomorph produced */
	{
	if ( ru->base )                     /* If base rule */
		{
		if ( do_trace )                     /* If tracing, show result */
			{
			fprintf(logfile,  "Base: %s\n", entry );
			disprule( ru );
			fprintf(logfile,  "Base: %s\n\n", allo );
			}
		entry = mystrdup( allo );           /* Make output new base */
		if ( *ru->envir )                   /* If a morpheme property */
			{
			strcpy( temps, "\\mp " );       /* Build \mp line to see if already there */
			strcat( temps, ru->envir );
			if ( !strnlstr( dicent, temps ) ) /* If property not already in */ /* 0.2l BJY */
				insert_line( "\\mp ", ru->envir, after_allos( dicent ) ); /* Insert it */
			}
		/* num_apps++; */ /* Don't monitor base rule applications */
		}
	else if ( !in_allolist( allo ) )        /* And not already in */
		{

		if ( pallo )                        /* working on a PHONRULE generated allo */
			{
			if ( join_envirs( allo, ru, pallo ) ) /* try to create a new allo by joining envirs */
				{       /* insert new allo just before the allo we just combined with */
				insert_line( allomark, allo, before_allo( pallo, dicent ) );
				add_new_allo( allo, pallo, ru );    /* add to list of allos generated by PHONRULE */
				if ( do_trace )                     /* If tracing, show result */
					{
					fprintf(logfile,  "Allo: %s\n", entry );
					disprule( ru );
					fprintf(logfile,  "Allo: %s\n\n", allo );
					}
				num_apps++;
				}
			}
		else            /* this allo generated from base */
			{
			strcat( allo, " " );
			strcat( allo, ru->envir );
			insert_line( allomark, allo, after_allos( dicent ) );   /* insert into dictionary */
			add_new_allo( allo, pallo, ru );    /* add to list of allos generated by PHONRULE */
			if ( do_trace )                     /* If tracing, show result */
				{
				fprintf(logfile,  "Base: %s\n", entry );
				disprule( ru );
				fprintf(logfile,  "Allo: %s\n\n", allo );
				}
			num_apps++;
			}

		}
	}
	return entry; /* return base possibly changed by base rule  0.2s BJY */
}

/* structures for describing an environment */
typedef struct {
	int side;       /* either LEFT or RIGHT (or both OR'd together) */
	int count;      /* number of this type of environments found */
} ENV;

typedef struct {
	ENV senv;       /* description of string environment */
	ENV menv;       /* description of morpheme environment */
} ENVSTRUCT;

#define LEFT  1     /* constants for describing which side of the underline an */
#define RIGHT 2     /*  environment is on */

#define INITIAL 1   /* constants for describing which kind of rule generated */
#define FINAL   2   /* an allomorph */

#define BOTH  3

/**************************************************************
 * NAME
 *      parse_envir
 * ARGS
 *      envinfo - pointer to structure to fill with info
 *      str - environment to parse
 * DESC
 *      Parse an environment string and fill env with the
 *      results.
 * RETN
 *      None
 *
 * Added 5/95 0.2r BJY
 */
static void parse_envir( ENVSTRUCT *envinfo, char *str )
{
char *s;
ENV *penv;

envinfo->menv.side = envinfo->menv.count = 0;
envinfo->senv.side = envinfo->senv.count = 0;

for ( s=strchr( str, '/' ); s; s=strchr( s, '/' ) ) /* find start of envir */
	{
	penv = ( *(s-1) == '+' ) ? &envinfo->menv : &envinfo->senv;   /* string or morpheme env */
	penv->count++;                          /* increment count of envs found */
	s = skipwhite( s+1 );                   /* step past slash and whitespace */
	if ( *s != '_' )                        /* stuff on left side */
		{
		penv->side |= LEFT;
		s = strchr( s, '_' );               /* advance to _ */
		}
	s = skipwhite( s+1 );                   /* skip _ and whitespace */
	if ( !*s )
		break;
	if ( *s != '+' && *s != '/' )           /* stuff on right side */
		penv->side |= RIGHT;
	}
}

#if 0
/**************************************************************
 * NAME
 *      copy_props
 * ARGS
 *      allobuf - buffer to build new allo into
 *      rulestr - rule environment string
 *      allostr - allo environment string
 * DESC
 *      Copy the properties from the rule and the allomorph
 *      used to generate this new allomorph into allobuf
 * RETN
 *
 * Added 5/95 0.2r BJY
 */
static void copy_props( char *allobuf, char *rulestr, char *allostr )
{
char *s, *p;

strcat( allobuf, " " );                     /* add a space after allo name */
s = strchr( allostr, '/' );
if ( s )
	{
	if ( *(s-1) == '+' )
		s--;                                /* backup for +/ */
	}
else
	s = allostr + strlen( allostr );        /* no envir, still need to look for property */

for ( p = allostr; ( p < s ) && !myisspace( *p ); p++ )     /* find first space */
	;
p = skipwhite( p );                         /* now find first non-space */
if ( p < s )                                /* must be a property name here */
	strncat( allobuf, p, s-p );             /* copy property name(s) to allobuf */

p = skipwhite( rulestr );                   /* see if rule has properties as well */
if ( ( *p == '/' ) || ( ( *p == '+' ) && ( *(p+1) == '/'  ) ) )
	return;                                 /* no properties in rule */

s = strchr( p, '/' );
if ( s )
	{
	if ( *(s-1) == '+' )
		s--;                                /* backup for +/ */
	}
else
	s = p + strlen( p );                    /* no envir, look for property */
strncat( allobuf, p, s-p );                 /* copy property name(s) to allobuf */
}
#endif

/**************************************************************
 * NAME
 *      join_envir
 * ARGS
 *      allobuf - buffer to build new allo into
 *      ru, al - pointers to ENV structures
 *      rulestr - rule environment string
 *      allostr - allo environment string
 *      is_menv - TRUE if doing +/ envirs
 * DESC
 *      Merge two environments
 * RETN
 *
 * Added 5/95 0.2r BJY
 */
static void join_envir( char *allobuf, ENV *ruleenv, ENV *alloenv,
							char *rulestr, char *allostr, int is_menv )
{
ENV *many, *one;
char *s, *p, *sr, *pr;  /* s is for single, p is for plural */
char *sstr, *pstr;
int slen, plen;

if ( ruleenv->count && alloenv->count )     /* have to merge envirs */
	{
	if ( ruleenv->count > 1 )               /* more than one envir in rule? */
		{
		many = ruleenv;                     /* multiple envirs in rule */
		one = alloenv;                      /* single envir in allo */
		pstr = rulestr;
		sstr = allostr;
		}
	else
		{
		many = alloenv;                     /* one or more envirs in allo */
		one = ruleenv;                      /* single envir in rule */
		sstr = rulestr;
		pstr = allostr;
		}
		/* find correct environment in string with single envir */
	for ( s=strchr( sstr, '/' );
		   ( *(s-1) == '+' ) ^ ( is_menv ); s=strchr( s+1, '/' ) )
		;
	if ( one->side == RIGHT )
		{
		s = strchr( s, '_' );               /* jump past _ */
		sr = strchr( s, '/' );
		if ( sr )
			{
			if ( *(sr-1) == '+' )
				sr--;                       /* back up before +/ */
			slen = sr-s;                    /* length of this environment */
			}
		else
			slen = strlen( s );             /* must be last environment in string */
		}
	else
		{
		sr = strchr( s, '_' );
		if ( sr )                           /* length of envir up to _ */
			slen = sr-s;
		else
			slen = strlen( s );             /* this shouldn't happen (no underscore) */
		}

		/* find correct environment in string with one or more envirs */
	for ( p=strchr( pstr, '/' ); p; p=strchr( p+1, '/' ) )
		{
		if ( ( *(p-1) == '+' ) ^ ( is_menv ) )  /* not right kind of envir */
			continue;
		if ( many->side == RIGHT )
			{
			p = strchr( p, '_' );           /* find _ */
			pr = strchr( p, '/' );
			if ( pr )
				{
				if ( *(pr-1) == '+' )
					pr--;                   /* back up before +/ */
				plen = pr-p;                /* length of this environment */
				}
			else
				plen = strlen( p );         /* must be last environment in string */
			}
		else
			{
			pr = strchr( p, '_' );
			if ( pr )                       /* length of envir up to _ */
				plen = pr-p;
			else
				plen = strlen( p );         /* this is some kind of user error */
			}
		if ( !myisspace( *( allobuf + strlen( allobuf ) - 1 ) ) )
			strcat( allobuf, " " );         /* give us a little padding */
		if ( is_menv )
			strcat( allobuf, "+" );         /* add + for +/ envir */

		if ( one->side == LEFT )
			{
			strncat( allobuf, s, slen );   /* concatenate envirs */
			strncat( allobuf, p, plen );
			}
		else
			{
			strncat( allobuf, p, plen );
			strncat( allobuf, s, slen );
			}
		}
	}
else                                        /* only one has an envir, so just copy it in */
	{
	if ( ruleenv->count )
		pstr = rulestr;                     /* figure out which one has an envir */
	else
		pstr = allostr;

		/* find correct environment (string or morpheme) */
	for ( p=strchr( pstr, '/' ); p; p=strchr( p+1, '/' ) )
		{
		if ( ( *(p-1) == '+' ) ^ ( is_menv ) )  /* not right kind of envir */
			continue;
		pr = strchr( p+1, '/' );
		if ( pr )
			{
			if ( *(pr-1) == '+' )
				pr--;                       /* back up before +/ */
			plen = pr-p;                    /* length of this environment */
			}
		else
			plen = strlen( p );             /* must be last environment in string */

		if ( !myisspace( *( allobuf + strlen( allobuf ) - 1 ) ) )
			strcat( allobuf, " " );         /* give us a little padding */
		if ( is_menv )
			strcat( allobuf, "+" );         /* add + for +/ envir */
		strncat( allobuf, p, plen );        /* add envir to allo environment */
		}
	}
}

/**************************************************************
 * NAME
 *      join_envirs
 * ARGS
 *      allobuf - buffer to build new allo into
 *      ru   - rule used to create this allo
 *      pallo - allo we're trying to join environments with
 * DESC
 *      Try to create a new allomorph with the combined
 *      environments of ru->envir and pallo.
 * RETN
 *      TRUE if successful, new allomorph in allo.
 *      else FALSE.
 *
 * Added 5/95 0.2r BJY
 */
static int join_envirs( char *allobuf, Rule *ru, Allo *pallo )
{
ENVSTRUCT rule;
ENVSTRUCT allo;
char *rp, rem;          /* used to remember char to restore at end of function */

rp = strchr( ru->envir, '|' );              /* comment mark */
if ( !rp )
	{
	rp = ru->envir + strlen( ru->envir );   /* no comment, just start at end of string */
	}
while ( ( rp > ru->envir ) && myisspace( *(rp-1) ) ) /* backtrack to real stuff */
	rp--;
rem = *rp;                                  /* save character */
*rp = '\0';

parse_envir( &rule, ru->envir );        /* parse rule environment */
parse_envir( &allo, pallo->name );      /* parse allomorph environment */

	/* don't join if rule and allo are same type ( initial or final ) */
if ( ( ru->begin && ( pallo->ruletype & INITIAL ) )
	|| ( !ru->begin && ( pallo->ruletype & FINAL ) ) )
	{
	*rp = rem;                          /* restore character */
	return FALSE;
	}

	/* can't join if both items have multiple envirs of same type */
if ( ( ( rule.senv.count > 1 ) && ( allo.senv.count > 1 ) )
  || ( ( rule.menv.count > 1 ) && ( allo.menv.count > 1 ) ) )
	{
	if ( minor_warnings )
		{
		fprintf(logfile,  "Warning: Can't combine multiple environments of same type\n" );
		fprintf(logfile,  "Allo: %s\n", pallo->name );
		disprule( ru );
		}
	*rp = rem;                          /* restore character */
	return FALSE;
	}

	/* can't join if envirs of same type have stuff on same side of underline */
if ( ( rule.senv.side & allo.senv.side )
  || ( rule.menv.side & allo.menv.side ) )
	{
	if ( minor_warnings )
		{
		fprintf(logfile,  "Warning: Can't combine environments on same side\n" );
		fprintf(logfile,  "Allo: %s\n", pallo->name );
		disprule( ru );
		}
	*rp = rem;                          /* restore character */
	return FALSE;
	}

/*copy_props( allobuf, ru->envir, pallo->name );*/  /* copy properties into final allo */

if ( rule.menv.count || allo.menv.count )       /* join morpheme envirs */
	join_envir( allobuf, &rule.menv, &allo.menv, ru->envir, pallo->name, TRUE );

if ( rule.senv.count || allo.senv.count )       /* join string envirs */
	join_envir( allobuf, &rule.senv, &allo.senv, ru->envir, pallo->name, FALSE );

*rp = rem;                              /* restore character */
return TRUE;
}


/**************************************************************
 * NAME
 *      before_allo
 * ARGS
 *      al - node in newallolist to insert before
 * DESC
 *      Find the occurance in dicent of the specified allomorph
 * RETN
 *      Pointer to al->name in dicent
 *
 * Created 5/95 0.2r BJY
 */
static char *before_allo( Allo *allo, char *dicent )
{
Allo *al;
Str *sl;
char *s = NULL;

if ( allolist )                                     /* first get past the allos */
	{                                               /* that were already in the entry */
	s = dicent-1;
	for ( sl = allolist; s && sl; sl = sl->next )   /* For each allo in list */
		s = strnlstr( s+1, allomark );              /* find an allo in dicentry */
	}

if ( newallolist )                                  /* find the all specified by al */
	{
	if ( !s )                                       /* nothing in first allo list? */
		s = dicent-1;
	s = strnlstr( s+1, allomark );
	for ( al = newallolist; s && ( al != allo ); al = al->next )   /* look for a match in new allos */
		s = strnlstr( s+1, allomark );
	}

if ( !s )           /* this really shouldn't happen */
	return( after_allos( dicent ) );
else
	return( s-1 );  /* backtrack to catch \n */
}


/**************************************************************
 * NAME
 *      after_allos
 * ARGS
 *      dicent - Start of dictionary entry.
 * DESC
 *      Find the end of the allomorph section in dicent.
 * RETN
 *      Pointer to end of allomorph list in dicent.
 *
 * Removed from insert_line() 5/95 0.2r BJY
 */
static char *after_allos( char *dicent )
{
char *s, *t, *last_allo;

s = dicent - 1;                     /* Find start of last allo */
last_allo = NULL;                   /* Init last allo */
while ( (s = strnlstr( s + 1, allomark )) != NULL ) /* While another allo */ /* 0.2l BJY */
	last_allo = s;                  /* Set last to it */

if ( last_allo )                    /* If last allo */
	s = last_allo;                  /* Insert after it */
else
	{
	s = strnlstr( dicent, basemark ); /* Find start of base */ /* 0.2l BJY */
	if ( (t = strnlstr( s, "\\_no" )) )  /* If Shoebox entry insert after it */
		s = t;
	}
s = strchr( s, '\n' );              /* Find end of base line */
if ( (t = strstr( s, allomark )) != NULL )       /* wm 0.2k: in case the last allo was multiline */
	s = t;
return( s );                        /* return pointer past allos */
}

/**************************************************************
 * NAME
 *      insert_line
 * ARGS
 *      mark -  Marker to put at front of line.
 *      allo -  Allo to insert.
 *      allo_ins - address to insert at.
 * DESC
 *      Insert a new line into dictionary entry.  Used to
 *      insert an allo line into a dictionary entry,
 *      and to insert a morpheme property line.
 * RETN
 *      None.
 *
 * Modified 5/95 0.2r BJY moved part of this func to after_allos()
 */
static void insert_line( char *mark, char *allo, char *allo_ins )
{
int allo_size;      /* Size of inserted allo */

allo_size = strlen( allo ) + strlen( mark ) + 1; /* Find size of insertion */

memmove( allo_ins + allo_size, allo_ins, strlen( allo_ins ) + 1 );

							/* Code below assumes a \n is at allo_ins */
strcpy( allo_ins + 1, mark );       /* Put in mark */
strcat( allo_ins, allo );           /* Put in allo */
*( allo_ins + allo_size ) = '\n';   /* Restore \n over \0 */
}


/**************************************************************
 * NAME
 *      add_new_allo
 * ARGS
 *      s - Complete allomorph string.
 *      where - if not NULL, node in newallolist to insert at
 *      ru - rule used to generate this allo
 * DESC
 *      Add or insert an allo into allolist only if it has
 *      an environment. Clean up by getting rid of comments
 *      and trailing whitespace.
 * RETN
 *      None.
 */
static void add_new_allo( char *s, Allo *where, Rule *ru )
{
Allo *al, *new;
char *p, rem;

p = strchr( s, '|' );           /* comment mark */
if ( !p )
	{
	p = s + strlen( s );        /* no comment, just start at end of string */
	}
while ( ( p > s ) && myisspace( *(p-1) ) )  /* backtrack to real stuff */
	p--;
/*if ( !( p > s ) )*/               /* no environment! */
/*    return;*/
rem = *p;                       /* save character */
*p = '\0';

new = Structalloc( Allo );           /* Get new list element */
new->name = mystrdup( s );             /* Point to copy of allo */
new->ruletype = ru->begin ? INITIAL : FINAL;
if ( where )
	new->ruletype |= where->ruletype;   /* should always be BOTH at this point */

if ( newallolist == where )     /* where and newallolist may be NULL */
	{
	new->next = newallolist;
	newallolist = new;          /* attach to beginning of list */
	}
else
	{                           /* find node in list to insert at */
	for ( al = newallolist; al->next != where; al = al->next )    /* where may be NULL */
		;                                                         /* (add to end of list) */
	new->next = al->next;       /* insert in middle? of list */
	al->next = new;
	}
*p = rem;                       /* restore character to allo string */
}


/**************************************************************
 * NAME
 *      add_allo
 * ARGS
 *      s - Allo to add.
 * DESC
 *      Add an allo to top of allolist.
 * RETN
 *      None.
 */
static void add_allo( char *s )
{
Str *sl;

sl = Structalloc( Str );            /* Get new list element */
sl->name = mystrdup( s );             /* Point to copy of allo */
sl->next = allolist;                /* Link to top of allo list */
allolist = sl;                      /* Set new top of list */
}


/**************************************************************
 * NAME
 *      in_allolist
 * ARGS
 *      s - Allo to look for.
 * DESC
 *      Check if allo in allolist.
 * RETN
 *      TRUE if in allolist, FALSE if not.
 */
static int in_allolist( char *s )
{
Str *sl;

for ( sl = allolist; sl; sl = sl->next )  /* For each allo in list */
	if ( streq( sl->name, s ) )         /* If found */
		return( TRUE );                 /* Return TRUE */

return( FALSE );                        /* If never found, return FALSE */
}
